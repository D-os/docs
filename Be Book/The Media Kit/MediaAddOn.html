<HTML><HEAD><TITLE>The Media Kit: BMediaAddOn</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Media Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Media%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Media Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="BMediaAddOn"></A>BMediaAddOn
</H1>
<P>
Derived from:  none
<P>
Declared in:  <A HREF="/boot/develop/headers/be/media/MediaAddOn.h">be/media/MediaAddOn.h</A>
<P>
Library:  libmedia.so
<P>
Allocation:  Constructor only
<P>
<H6><A HREF="MediaAddOn.summary.html"><i>Summary</i></A></H6>
<P>
A BMediaAddOn-derived object describes an executable program that lives in a disk file and is loaded by the Media Server when it's needed.  A BMediaAddOn tells the Media Server what kinds of nodes it can create and handles the actual creation of those nodes when called upon by the Media Server to do so.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
It's important to note that the functions in the BMediaAddOn class will typically only be called by the Media Kit (and from within the add-on itself).  These functions aren't called by client applications.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="Getting%20to%20Node%20You..."></A>Getting to Node You...
</H3>
<P>
A given node can support as many media kinds and formats as it wants (although if you support too many widely disparate media types, your add-on may get difficult to maintain, but that's another issue entirely).  For example, a node that supports video might support inputting AVI, QuickTime, and MPEG-2, but might only be able to output AVI.  This is information that the Media Kit needs to know.  For this reason, the BMediaAddOn needs to provide information about the media <B>flavors</B> it supports.
<P>
This is done using the flavor_info structure:
<P>
<PRE>&nbsp;&nbsp;&nbsp;struct flavor_info {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *info;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64 kinds;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 flavor_flags;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 internal_id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 possible_count;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 in_format_count;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 in_format_flags;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_format *in_formats;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 out_format_count;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 out_format_flags;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_format *out_formats;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 _reserved_[16];
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;private:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavor_info &amp; operator=(const flavor_info &amp;other);
&nbsp;&nbsp;&nbsp;};</PRE>
<P>
The <I><FONT  color=991122 face=HELVETICA>name</I></FONT> and <I><FONT  color=991122 face=HELVETICA>info</I></FONT> fields provide a human-readable name, and information  about the flavor.
<P>
The <I><FONT  color=991122 face=HELVETICA>kinds</I></FONT> field should indicate all the relevant kinds that the node matches; this is a bit field, and it's possible that more than one flag may be relevant.  See &nbsp;<a href="MediaNode.html#node_kind%20on%20page181">"node_kind" on page181</a>.
<P>
The <I><FONT  color=991122 face=HELVETICA>flavor_flags</I></FONT> field contains flags providing additional information about the flavor.
<P>
<TABLE BORDER cellpadding=4>
<TH><B>Constant</B></TH>
<TH>Description</TH>
<TR>
<TD><B><TT>B_FLAVOR_IS_GLOBAL</TT></B></TD>
<TD>The flavor will be forced into the Media Add-on Server, and only one instance of it will exist.</TD>
<TR>
<TD><B><TT>B_FLAVOR_IS_LOCAL</TT></B></TD>
<TD>The flavor will be forced into the loading application, and many instances of it may exist.</TD>
</TABLE>
<P>
If neither flag is specified, the Media Kit will decide what to do with the flavor.
<P>
The <I><FONT  color=991122 face=HELVETICA>internal_id</I></FONT> is an internal ID number that your add-on can use to identify the flavor; the flavor will be requested by the Media Kit using this ID number.
<P>
The <I><FONT  color=991122 face=HELVETICA>possible_count</I></FONT> field specifies to the Media Kit the maximum number of instances of your node can be in existence at the same time.  For example, if your node provides support for a particular sound card, this value should be equal to the number of cards you support that are currently installed in the computer.
<P>
<I><FONT  color=991122 face=HELVETICA>in_format_count</I></FONT> specifies how many input formats the flavor supports, and <I><FONT  color=991122 face=HELVETICA>in_formats</I></FONT> is a list of all the input formats supported by the flavor.
<P>
<I><FONT  color=991122 face=HELVETICA>in_format_flags</I></FONT> provides informational flags about the flavor's inputs.  There aren't any defined values for this field yet; be sure to set it to 0.
<P>
<I><FONT  color=991122 face=HELVETICA>out_format_count</I></FONT> specifies how many output formats the flavor supports, and <I><FONT  color=991122 face=HELVETICA>out_formats</I></FONT> is a list of all the output formats supported by the flavor.
<P>
<I><FONT  color=991122 face=HELVETICA>out_format_flags</I></FONT> provides informational flags about the flavor's outputs.  There aren't any defined values for this field yet; be sure to set it to 0.
<P>
If your node is a physical input, such as a sound card, your node's <I><FONT  color=991122 face=HELVETICA>kinds</I></FONT> field should include <B><TT><A HREF="MediaNode.html#B_PHYSICAL_INPUT">B_PHYSICAL_INPUT</A></TT></B> among the flags set therein.  Likewise, if your node is a physical output, or a system mixer, you should include <B><TT><A HREF="MediaNode.html#B_PHYSICAL_OUTPUT">B_PHYSICAL_OUTPUT</A></TT></B> or <B><TT><A HREF="MediaNode.html#B_SYSTEM_MIXER">B_SYSTEM_MIXER</A></TT></B>.
<P>
Your node's constructor should also call <B><TT><A HREF="MediaNode.html#AddNodeKind()">AddNodeKind()</A></TT></B> to add these kind flags; the base classes only add <B><TT><A HREF="MediaNode.html#B_BUFFER_CONSUMER">B_BUFFER_CONSUMER</A></TT></B>, <B><TT><A HREF="MediaNode.html#B_BUFFER_PRODUCER">B_BUFFER_PRODUCER</A></TT></B>, and so forth; the flags indicating that the node represents a physical input, physical output, or system mixer aren't added automatically.  For example, a sound digitizer node's constructor might have the following form:
<P>
<PRE>&nbsp;&nbsp;&nbsp;MyBufferProducer::MyBufferProducer(const char *name) :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BMediaNode(name),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BBufferProducer() {
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddNodeKind(B_PHYSICAL_INPUT);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* constructor stuff goes here */
&nbsp;&nbsp;&nbsp;}</PRE>
<P>
<HR>
<H2>
<A NAME="Hook%20Functions"></A><FONT SIZE=6>H</FONT>ook <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<UL>
<LI><B><TT><A HREF="#AutoStart()">AutoStart()</A>
<P>
</TT></B><LI><B><TT><A HREF="#CountFlavors()">CountFlavors()</A>
<P>
</TT></B><LI><B><TT><A HREF="#GetConfigurationFor()">GetConfigurationFor()</A>
<P>
</TT></B><LI><B><TT><A HREF="#GetFileFormatList()">GetFileFormatList()</A>
<P>
</TT></B><LI><B><TT><A HREF="#GetFlavorAt()">GetFlavorAt()</A>
<P>
</TT></B><LI><B><TT><A HREF="#InitCheck()">InitCheck()</A>
<P>
</TT></B><LI><B><TT><A HREF="#InstantiateNodeFor()">InstantiateNodeFor()</A>
<P>
</TT></B><LI><B><TT><A HREF="#SniffRef()">SniffRef()</A>
<P>
</TT></B><LI><B><TT><A HREF="#SniffType()">SniffType()</A>
<P>
</TT></B><LI><B><TT><A HREF="#SniffTypeKind()">SniffTypeKind()</A>
<P>
</TT></B><LI><B><TT><A HREF="#WantsAutoStart()">WantsAutoStart()</A>
<P>
</TT></B></UL>
<P>
<HR>
<H2>
<A NAME="Constructor%20and%20Destructor"></A><FONT SIZE=6>C</FONT>onstructor and <FONT SIZE=6>D</FONT>estructor
</H2>
<P>
<HR>
<H3>
<A NAME="BMediaAddOn()"></A>BMediaAddOn()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
explicit <B><TT><FONT  color=000022 size=+1>BMediaAddOn(</TT></B></FONT>image_id <I><FONT  color=991122 face=HELVETICA>image</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
This is the BMediaAddOn constructor; your derived class should perform whatever initialization is necessary in the constructor, and handle any activities necessary in order to properly comply with the media add-on protocol.
<P>
The image_id identifies the add-on image from which the add-on was loaded.  Your <B><TT><A HREF="#make_media_addon()">make_media_addon()</A></TT></B> function should be sure to save the image ID passed to it and pass that value through to the BMediaAddOn constructor, or the Media Kit will be unhappy with you.
<P>
<HR>
<H3>
<A NAME="~BMediaAddOn"></A>~BMediaAddOn
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>~BMediaAddOn()</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
You should never delete a BMediaAddOn yourself; the Media Server will do this when the add-on is no longer needed.  However, if you're implementing a media add-on, this is a good place to handle disposing of memory you've allocated.
<P>
<HR>
<H2>
<A NAME="Member%20Functions"></A><FONT SIZE=6>M</FONT>ember <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="AutoStart()"></A>AutoStart()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>AutoStart(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>index</I></FONT>, <A HREF="MediaNode.html#BMediaNode">BMediaNode</A> **<I><FONT  color=991122 face=HELVETICA>outNode,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I></FONT>int32 *<I><FONT  color=991122 face=HELVETICA>outInternalID</I></FONT>, bool *<I><FONT  color=991122 face=HELVETICA>outHasMore</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> = 0
<P>

</TABLE></TABLE>

<P>
If <B><TT><A HREF="#WantsAutoStart()">WantsAutoStart()</A></TT></B> returns <B><TT>true</TT></B>, you'll get repeated calls to <B><TT>AutoStart()</TT></B> when your add-on is loaded.
<P>
Your <B><TT>AutoStart()</TT></B> function should be implemented to instantiate nodes to your liking, one for each call to <B><TT>AutoStart()</TT></B>.  Each time <B><TT>AutoStart()</TT></B> is called, <I><FONT  color=991122 face=HELVETICA>index</I></FONT> will be one higher than the previous pass.  After creating the new node, store a pointer to it in <I><FONT  color=991122 face=HELVETICA>outNode</I></FONT>, and set <I><FONT  color=991122 face=HELVETICA>outInternalID</I></FONT> to the internal ID of the flavor represented by that node.
<P>
Before returning, set <I><FONT  color=991122 face=HELVETICA>outHasMore</I></FONT> to true if there are more nodes to start, and false if there aren't.
<P>
Return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> if you return a valid node.  If there aren't any more nodes to be started, return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_INDEX">B_BAD_INDEX</A></TT></B>.  If the specified index fails, but there may be other nodes to start, return <B><TT>B_ADDON_FAILED</TT></B>.
<P>
<HR>
<H3>
<A NAME="CountFlavors()"></A>CountFlavors()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual int32 <B><TT><FONT  color=000022 size=+1>CountFlavors(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
<HR>
<H3>
<A NAME="Implement"></A>Implement
, 
<A NAME="this"></A>this
, 
<A NAME="hook"></A>hook
, 
<A NAME="function"></A>function
, 
<A NAME="to"></A>to
, 
<A NAME="return"></A>return
, 
<A NAME="the"></A>the
, 
<A NAME="number"></A>number
, 
<A NAME="of"></A>of
, 
<A NAME="flavors"></A>flavors
, 
<A NAME="your"></A>your
, 
<A NAME="add-on"></A>add-on
, 
<A NAME="can"></A>can
, 
<A NAME="deal"></A>deal
, 
<A NAME="with."></A>with.
</H3>
<P>
<HR>
<H3>
<A NAME="GetConfigurationFor()"></A>GetConfigurationFor()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>GetConfigurationFor(</TT></B></FONT><A HREF="MediaNode.html#BMediaNode">BMediaNode</A> *<I><FONT  color=991122 face=HELVETICA>node</I></FONT>, <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>config</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
Implement this function to save information about how the given node is configured into the specified message.  This lets the node's configuration be saved to disk for future rehydration using <B><TT><A HREF="#InstantiateNodeFor()">InstantiateNodeFor()</A></TT></B>.
<P>
Note that it's not reasonable to save information about what connections are routed through the node, since the other nodes probably won't exist when the node is rehydrated.  It's up to the application to reconstruct the connections itself, as it wishes.
<P>
If the configuration information is stashed into <I><FONT  color=991122 face=HELVETICA>config</I></FONT> without errors, return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>; otherwise, return an appropriate error code.
<P>
<HR>
<H3>
<A NAME="GetFileFormatList()"></A>GetFileFormatList()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>GetFileFormatList(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>flavorID</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_file_format *<I><FONT  color=991122 face=HELVETICA>outWritableFormats</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 <I><FONT  color=991122 face=HELVETICA>inWriteItems</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 *<I><FONT  color=991122 face=HELVETICA>outWriteItems</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_file_format *<I><FONT  color=991122 face=HELVETICA>outReadableFormats</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 <I><FONT  color=991122 face=HELVETICA>inReadItems</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 *<I><FONT  color=991122 face=HELVETICA>outReadItems</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>reserved</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
If your add-on provides nodes that can either read or write media data from files, you should implement this function to describe the <B><TT>media_file_formats</TT></B> you can read and write.
<P>
On input, the <I><FONT  color=991122 face=HELVETICA>flavorID</I></FONT> argument indicates which flavor you should return information about.  You should fill the array <I><FONT  color=991122 face=HELVETICA>outWritableFormats</I></FONT> with a list of the file formats the corresponding flavor can write, and the <I><FONT  color=991122 face=HELVETICA>outReadableFormats</I></FONT> array with a list of the file formats the flavor can read.  The <I><FONT  color=991122 face=HELVETICA>inWriteItems</I></FONT> and <I><FONT  color=991122 face=HELVETICA>inReadItems</I></FONT> arguments indicate how many items can be stored in each array. 
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Both <I><FONT  color=991122 face=HELVETICA>outWritableFormats</I></FONT> and <I><FONT  color=991122 face=HELVETICA>outReadableFormats</I></FONT> can be <B><TT>NULL</TT></B>.  Don't write into these arrays if the corresponding pointer is <B><TT>NULL</TT></B>.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
On output, you should set <I><FONT  color=991122 face=HELVETICA>outWriteItems</I></FONT> to be the number of file formats you can write&mdash;even if it's larger than <I><FONT  color=991122 face=HELVETICA>inWriteItems</I></FONT>.  This lets the caller resize the array and call you back to get the complete list.  Likewise, <I><FONT  color=991122 face=HELVETICA>outReadItems</I></FONT> should be set to the number of file formats you can read.
<P>
The <I><FONT  color=991122 face=HELVETICA>reserved</I></FONT> argument isn't currently used, and should always be specified as <B><TT>NULL</TT></B>.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
Only implement this function if your node derives from BFileInterface.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
If an error occurs, return an appropriate error code; otherwise, return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.
<P>
<HR>
<H3>
<A NAME="GetFlavorAt()"></A>GetFlavorAt()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>GetFlavorAt(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>flavorNum</I></FONT>, const flavor_info **<I><FONT  color=991122 face=HELVETICA>outInfo</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
Implement <B><TT>GetFlavorAt()</TT></B> to store in <I><FONT  color=991122 face=HELVETICA>outInfo</I></FONT> a pointer to a static <B><TT><A HREF="#flavor_info">flavor_info</A></TT></B> structure describing one flavor supported by your add-on.  The data pointed to by <I><FONT  color=991122 face=HELVETICA>outInfo</I></FONT> will be copied by the Media Kit after <B><TT>GetFlavorAt()</TT></B> returns.  For example, if your add-on only supports one flavor:
<P>
<PRE>&nbsp;&nbsp;&nbsp;flavor_info flavorInfo;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;status_t MyMediaAddOn::GetFlavorAt(int32 n, const flavor_info **out_info) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (n != 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return B_ERROR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavorInfo->internal_id = n;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavorInfo->name = strdup("My Media Node");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavorInfo->info = strdup("This node receives video from spy cameras at area pizza parlors and determines which one is the least busy.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavorInfo->kinds = B_BUFFER_CONSUMER | B_PHYSICAL_OUTPUT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavorInfo->flavor_flags = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavorInfo->possible_count = 0;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set up the list of input formats.  We only support
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// raw video input.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavorInfo->in_format_count = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_format *aFormat = new media_format;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aFormat->type = B_MEDIA_RAW_VIDEO;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aFormat->u.raw_video = media_raw_video_format::wildcard;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavorInfo->in_formats = aFormat;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We don&gt;t output.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavorInfo->out_format_count = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavorInfo->out_formats = 0;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// And set up the result pointer
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*out_info = flavorInfo;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return B_OK;
&nbsp;&nbsp;&nbsp;}</PRE>
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
If you allocate memory for the <B><TT><A HREF="#flavor_info">flavor_info</A></TT></B> structure, be sure to discard it before your add-on is unloaded (the destructor is a good place to do this).  If you forget to discard the memory, you'll leak, and that can be really embarrassing.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
If <I><FONT  color=991122 face=HELVETICA>flavorNum</I></FONT> is greater than <B><TT><A HREF="#CountFlavors()">CountFlavors()</A></TT></B>-1 (in other words, if the requested number is larger than the number of flavors you support), return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  Otherwise, return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> or, if an error occurs, an appropriate error code.
<P>
<HR>
<H3>
<A NAME="ImageID()"></A>ImageID()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
image_id <B><TT><FONT  color=000022 size=+1>ImageID(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns the add-on's image ID, as specified by the BMediaAddOn constructor.
<P>
Your <B><TT><A HREF="#make_media_addon()">make_media_addon()</A></TT></B> function should be sure to save the image ID passed to it and pass that value through to the BMediaAddOn constructor, or the Media Kit will be unhappy with you.
<P>
<HR>
<H3>
<A NAME="InitCheck()"></A>InitCheck()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>InitCheck(</TT></B></FONT>const char **<I><FONT  color=991122 face=HELVETICA>outFailureText</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
Implement this hook function to set <I><FONT  color=991122 face=HELVETICA>outFailureText</I></FONT> to point to a static text buffer that contains a message explaining why your add-on failed the most recent operation requested by the Media Server.  This doesn't include errors reported by nodes instantiated by your add-on, but only to errors caused directly by your BMediaAddOn-derived object.
<P>
The buffer pointed to by <I><FONT  color=991122 face=HELVETICA>outFailureText</I></FONT> shouldn't go away until the add-on is reloaded or a new call to <B><TT>InitCheck()</TT></B> is made.
<P>
Also returned is the actual result code from that operation; if all is well, <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> should be returned.
<P>
<HR>
<H3>
<A NAME="InstantiateNodeFor()"></A>InstantiateNodeFor()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual <A HREF="MediaNode.html#BMediaNode">BMediaNode</A> *<B><TT><FONT  color=000022 size=+1>InstantiateNodeFor(</TT></B></FONT>const flavor_info *<I><FONT  color=991122 face=HELVETICA>info</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>config</I></FONT>, status_t *<I><FONT  color=991122 face=HELVETICA>outError</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
Given the information in <I><FONT  color=991122 face=HELVETICA>info</I></FONT> (which might be a copy of information you previously returned from a <B><TT><A HREF="#GetFlavorAt()">GetFlavorAt()</A></TT></B> call), you should instantiate a new object of the node class referenced by <I><FONT  color=991122 face=HELVETICA>info</I></FONT>'s internal_id field and return a pointer to that node.
<P>
The <I><FONT  color=991122 face=HELVETICA>config</I></FONT> message might contain information saved by a previous instance of the same flavor node, and should be used to configure the new node if possible.  <I><FONT  color=991122 face=HELVETICA>config</I></FONT> will never be <B><TT>NULL</TT></B>, although it may not have any fields of interest in it.
<P>
The simplest implementation of this function, in which there's no configuration possible, might look like this:
<P>
<PRE>&nbsp;&nbsp;&nbsp;BMediaNode *BMyConsumerAddOn::InstantiateNodeFor(const flavor_info *info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BMessage *config, status_t *outError) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new MyConsumerNode((const char *) "My Consumer Node");
&nbsp;&nbsp;&nbsp;}</PRE>
<P>
If a new instance can't be instantiated, set <I><FONT  color=991122 face=HELVETICA>outError</I></FONT> to an appropriate error code and return <B><TT>NULL</TT></B>.  Otherwise, set <I><FONT  color=991122 face=HELVETICA>outError</I></FONT> to <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.
<P>
<HR>
<H3>
<A NAME="SniffRef()"></A>SniffRef()
, 
<A NAME="SniffType()"></A>SniffType()
, 
<A NAME="SniffTypeKind()"></A>SniffTypeKind()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>SniffRef(</TT></B></FONT>const entry_ref &amp;<I><FONT  color=991122 face=HELVETICA>file</I></FONT>, <A HREF="../Release%20Notes/StorageKit.html#BMimeType">BMimeType</A> *<I><FONT  color=991122 face=HELVETICA>outMimeType</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float *<I><FONT  color=991122 face=HELVETICA>outQuality</I></FONT>, int32 *<I><FONT  color=991122 face=HELVETICA>outInternalID</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>SniffType(</TT></B></FONT><A HREF="../Release%20Notes/StorageKit.html#BMimeType">BMimeType</A> &amp;<I><FONT  color=991122 face=HELVETICA>mimeType</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float *<I><FONT  color=991122 face=HELVETICA>outQuality</I></FONT>, int32 *<I><FONT  color=991122 face=HELVETICA>outInternalID</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>SniffTypeKind(</TT></B></FONT><A HREF="../Release%20Notes/StorageKit.html#BMimeType">BMimeType</A> &amp;<I><FONT  color=991122 face=HELVETICA>mimeType</I></FONT>, uint64 <I><FONT  color=991122 face=HELVETICA>inKinds</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float *<I><FONT  color=991122 face=HELVETICA>outQuality</I></FONT>, int32 *<I><FONT  color=991122 face=HELVETICA>outInternalID</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>reserved</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
If your add-on supports <A HREF="FileInterface.html#BFileInterface">BFileInterface</A> nodes, you may implement <B><TT>SniffRef()</TT></B>.  Given the specified <I><FONT  color=991122 face=HELVETICA>file</I></FONT>, examine the file and set <I><FONT  color=991122 face=HELVETICA>outMimeType</I></FONT> to describe the MIME type of the file.
<P>
Additionally, you can implement <B><TT>SniffType()</TT></B> to report how well your add-on can handle a file containing data of the MIME type specified by <I><FONT  color=991122 face=HELVETICA>mimeType</I></FONT>.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
If your node deals with both producers and consumers, you shouldn't implement <B><TT>SniffType()</TT></B>.  Implement <B><TT><A HREF="#SniffTypeKind()">SniffTypeKind()</A></TT></B> instead.  If <B><TT><A HREF="#SniffTypeKind()">SniffTypeKind()</A></TT></B> is implemented, <B><TT>SniffType()</TT></B> won't be called.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<B><TT>SniffTypeKind()</TT></B>  limits the search to the kinds indicated by <I><FONT  color=991122 face=HELVETICA>inKinds</I></FONT>.  This lets the caller indicate whether it's looking for a consumer or a producer, for example.
<P>
In any case, you should also store, in <I><FONT  color=991122 face=HELVETICA>outQuality</I></FONT>, a value representing the quality level at which your add-on can interpret the data in the file (where 0.0 means you can't handle it well at all and 1.0 means you can handle it perfectly), and in <I><FONT  color=991122 face=HELVETICA>outInternalID</I></FONT>, the internal ID of the flavor that handles the data.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
Don't implement these functions if your add-on doesn't support <A HREF="FileInterface.html#BFileInterface">BFileInterface</A> nodes.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
Return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> if you've successfully identified the node; otherwise, return an appropriate error code.
<P>
<HR>
<H3>
<A NAME="WantsAutoStart()"></A>WantsAutoStart()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual bool <B><TT><FONT  color=000022 size=+1>WantsAutoStart(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
Implement this hook function to return <B><TT>true</TT></B> if there are one or more node flavors supported by your add-on that want to be instantiated automatically when the add-on is loaded, instead of waiting until they're explicitly instantiated by an application's request later.  Return <B><TT>false</TT></B> otherwise.
<P>
<HR>
<H2>
<A NAME="Global%20C%20Functions"></A><FONT SIZE=6>G</FONT>lobal <FONT SIZE=6>C</FONT> <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="make_media_addon()"></A>make_media_addon()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
BMediaAddOn *<B><TT><FONT  color=000022 size=+1>make_media_addon(</TT></B></FONT>image_id <I><FONT  color=991122 face=HELVETICA>addonID</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>make_media_addon()</TT></B> is the global C function your add-on needs to implement in order to make itself available to the world.  It will be called when the Media Server loads your add-on, and you should return an instance of your BMediaAddOn-derived class, with the appropriate overrides to the hook functions.
<P>
The <I><FONT  color=991122 face=HELVETICA>addonID</I></FONT> argument is your add-on's image ID.  Your <B><TT>make_media_addon()</TT></B> function should be sure to save the image ID passed to it and pass that value through to the BMediaAddOn constructor, or the Media Kit will be unhappy with you.
<P>
This function can be quite simple:
<P>
<PRE>&nbsp;&nbsp;&nbsp;BMediaAddOn *make_media_addon(image_id myImage) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new MyConsumerAddOn(myImage);
&nbsp;&nbsp;&nbsp;}</PRE>
<P>
It simply creates an instance of the add-on object (in this case, <B><TT>MyConsumerAddOn</TT></B>), and returns it.
<P>
<HR>
<H2>
<A NAME="Structures"></A><FONT SIZE=6>S</FONT>tructures
</H2>
<P>
<HR>
<H3>
<A NAME="dormant_flavor_info"></A>dormant_flavor_info
</H3>
<P>
Declared in:  &lt;be/media/MediaAddOn.h><PRE>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;struct dormant_flavor_info : public flavor_info, public BFlattenable {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dormant_node_info();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual ~dormant_node_info();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dormant_flavor_info(const dormant_flavor_info &amp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dormant_flavor_info&amp; operator=(const dormant_flavor_info &amp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dormant_flavor_info&amp; operator=(const flavor_info &amp;);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dormant_node_info node_info;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void set_name(const char *in_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void set_info(const char *in_info);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void add_in_format(const media_format &amp;in_format);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void add_out_format(const media_format &amp;out_format);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual bool IsFixedSize() const;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual type_code TypeCode() const;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual ssize_t FlattenedSize() const;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual status_t Flatten(void *buffer, ssize_t size) const;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual status_t Unflatten(type_code c, const void *buf, ssize_t size);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;private:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void assign_atoms(const flavor_info &amp;that);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_addon_id addon;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 flavor_id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char name[B_MEDIA_NAME_LENGTH];
&nbsp;&nbsp;&nbsp;private:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char reserved[128];
&nbsp;&nbsp;&nbsp;};</PRE>
<P>
The dormant_flavor_info structure describes a flavor in a dormant node.
<P>
<HR>
<H3>
<A NAME="dormant_node_info"></A>dormant_node_info
</H3>
<P>
Declared in:  &lt;be/media/MediaAddOn.h><PRE>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;struct dormant_node_info {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dormant_node_info();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~dormant_node_info();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_addon_id addon;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 flavor_id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char name[B_MEDIA_NAME_LENGTH];
&nbsp;&nbsp;&nbsp;private:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char reserved[128];
&nbsp;&nbsp;&nbsp;};</PRE>
<P>
The dormant_node_info structure describes a node that resides in an add-on and that may not be in memory.  You might use it when issuing the <B><TT><A HREF="MediaRoster.html#InstantiateDormantNode()">BMediaRoster::InstantiateDormantNode()</A></TT></B> to instantiate a node, for example.
<P>
The <I><FONT  color=991122 face=HELVETICA>addon</I></FONT> field indicates the ID number of the media add-on in which the node resides, and the <I><FONT  color=991122 face=HELVETICA>flavor_id</I></FONT> is the flavor ID internal to that add-on indicating which flavor the node should represent.  The <I><FONT  color=991122 face=HELVETICA>name</I></FONT> field is the node's name.
<P>
<HR>
<H3>
<A NAME="flavor_info"></A>flavor_info
</H3>
<P>
Declared in:  &lt;be/media/MediaAddOn.h><PRE>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;struct flavor_info {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *info;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64 kinds;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 flavor_flags;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 internal_id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 possible_count;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 in_format_count;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 in_format_flags;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_format *in_formats;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 out_format_count;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 out_format_flags;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_format *out_formats;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 _reserved_[16];
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;private:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavor_info &amp; operator=(const flavor_info &amp;other);
&nbsp;&nbsp;&nbsp;};</PRE>
<P>
The <I><FONT  color=991122 face=HELVETICA>name</I></FONT> and <I><FONT  color=991122 face=HELVETICA>info</I></FONT> fields provide a human-readable name, and information  about the flavor.
<P>
The <I><FONT  color=991122 face=HELVETICA>kinds</I></FONT> field should be set to the node kind.  See &nbsp;<a href="MediaNode.html#node_kind%20on%20page181">"node_kind" on page181</a>.
<P>
The <I><FONT  color=991122 face=HELVETICA>flavor_flags</I></FONT> field contain flags providing additional information about the flavor.
<P>
<TABLE BORDER cellpadding=4>
<TH>Constant</TH>
<TH>Description</TH>
<TR>
<TD><B><TT>B_FLAVOR_IS_GLOBAL</TT></B></TD>
<TD>The flavor will be forced into the Media Add-on Server, and only one instance of it will exist.</TD>
<TR>
<TD><B><TT>B_FLAVOR_IS_LOCAL</TT></B></TD>
<TD>The flavor will be forced into the loading application, and many instances of it may exist.</TD>
</TABLE>
<P>
If neither flag is specified, the Media Kit will decide what to do with the flavor.
<P>
The <I><FONT  color=991122 face=HELVETICA>internal_id</I></FONT> is an internal ID number that your add-on can use to identify the flavor; the flavor will be requested by the Media Kit using this ID number.
<P>
The <I><FONT  color=991122 face=HELVETICA>possible_count</I></FONT> field specifies to the Media Kit the maximum number of instances of your node can be in existence at the same time.  For example, if your node provides support for a particular sound card, this value should be equal to the number of cards you support that are currently installed in the computer.
<P>
<I><FONT  color=991122 face=HELVETICA>in_format_count</I></FONT> specifies how many input formats the flavor supports, and <I><FONT  color=991122 face=HELVETICA>in_formats</I></FONT> is a list of all the input formats supported by the flavor.
<P>
<I><FONT  color=991122 face=HELVETICA>in_format_flags</I></FONT> provides informational flags about the flavor's inputs.  There currently aren't any defined flags, so set this field to 0.
<P>
<I><FONT  color=991122 face=HELVETICA>out_format_count</I></FONT> specifies how many output formats the flavor supports, and <I><FONT  color=991122 face=HELVETICA>out_formats</I></FONT> is a list of all the output formats supported by the flavor.
<P>
<I><FONT  color=991122 face=HELVETICA>out_format_flags</I></FONT> provides informational flags about the flavor's outputs.  There currently aren't any defined flags, so set this field to 0.
<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Media Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Media%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Media Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

