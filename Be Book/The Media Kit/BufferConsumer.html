<HTML><HEAD><TITLE>The Media Kit: BBufferConsumer</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Media Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Media%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Media Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="BBufferConsumer"></A>BBufferConsumer
</H1>
<P>
Derived from:  virtual <A HREF="MediaNode.html#BMediaNode">BMediaNode</A>
<P>
Declared in:  <A HREF="/boot/develop/headers/be/media/BufferConsumer.h">be/media/BufferConsumer.h</A>
<P>
Library:  libmedia.so
<P>
Allocation:  Constructor only
<P>
<H6><A HREF="BufferConsumer.summary.html"><i>Summary</i></A></H6>
<P>
BBufferConsumer is the counterpart to the <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A> class&mdash;it receives BBuffers from the BBufferProducers that are connected to it, manipulates them in some fashion (either by altering the contents of the buffer or by playing the buffer's data to the speakers or to the screen), and possibly then passes them along to another BBufferConsumer (if the node also inherits from BBufferProducer).
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
The functions in this class aren't called by applications or by other nodes; they're called exclusively by the Media Kit to control and obtain information about a buffer consumer.
<P>
</UL>
<P>
A BBufferConsumer publishes certain inputs, identified by <B><TT><A HREF="misc_api.html#media_destination">media_destination</A></TT></B> structures, on which connections may be requested by a client application.
<P>
<HR>
<H2>
<A NAME="Hook%20Functions"></A><FONT SIZE=6>H</FONT>ook <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<UL>
<LI><B><TT><A HREF="#AcceptFormat()">AcceptFormat()</A>
<P>
</TT></B><LI><B><TT><A HREF="#BufferReceived()">BufferReceived()</A>
<P>
</TT></B><LI><B><TT><A HREF="#Connected()">Connected()</A>
<P>
</TT></B><LI><B><TT><A HREF="#Disconnected()">Disconnected()</A>
<P>
</TT></B><LI><B><TT><A HREF="#DisposeInputCookie()">DisposeInputCookie()</A>
<P>
</TT></B><LI><B><TT><A HREF="#GetLatencyFor()">GetLatencyFor()</A>
<P>
</TT></B><LI><B><TT><A HREF="#GetNextInput()">GetNextInput()</A>
<P>
</TT></B><LI><B><TT><A HREF="#HandleMessage()">HandleMessage()</A>
<P>
</TT></B><LI><B><TT><A HREF="#ProducerDataStatus()">ProducerDataStatus()</A>
<P>
</TT></B><LI><B><TT><A HREF="#FormatChanged()">FormatChanged()</A>
<P>
</TT></B><LI><B><TT><A HREF="#SeekTagRequested()">SeekTagRequested()</A>
<P>
</TT></B></UL>
<P>
<HR>
<H2>
<A NAME="Constructor%20and%20Destructor"></A><FONT SIZE=6>C</FONT>onstructor and <FONT SIZE=6>D</FONT>estructor
</H2>
<P>
<HR>
<H3>
<A NAME="BBufferConsumer()"></A>BBufferConsumer()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>BBufferConsumer(</TT></B></FONT>media_type <I><FONT  color=991122 face=HELVETICA>consumerType</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
The BBufferConsumer constructor.  Specify as <I><FONT  color=991122 face=HELVETICA>consumerType</I></FONT> the type of data the BBufferConsumer accepts.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
In BeOS Release 4.5.2 and earlier <I><FONT  color=991122 face=HELVETICA>consumerType</I></FONT> has a default value.  It no longer does.  You'll have to actually specify the media type from now on.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="~BBufferConsumer"></A>~BBufferConsumer
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>~BBufferConsumer()</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
The BBufferConsumer destructor.  You can augment this to handle whatever closing-out your consumer node requires.
<P>
If your node has created and set BBufferGroups for any producers, you should delete them in the destructor.
<P>
<HR>
<H2>
<A NAME="Member%20Functions"></A><FONT SIZE=6>M</FONT>ember <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="AcceptFormat()"></A>AcceptFormat()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>AcceptFormat(</TT></B></FONT>const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>destination</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_format *<I><FONT  color=991122 face=HELVETICA>format</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> = 0
<P>

</TABLE></TABLE>

<P>
Implement this hook function to check that the specified <I><FONT  color=991122 face=HELVETICA>format</I></FONT> is reasonable for the specified destination, and to fill in any wildcard fields for which your BBufferConsumer has specific requirements.
<P>
If the format isn't reasonable (or is of a class that's unsuitable for <I><FONT  color=991122 face=HELVETICA>dest</I></FONT>), return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_MEDIA_BAD_FORMAT">B_MEDIA_BAD_FORMAT</A></TT></B>.
<P>
When <B><TT>AcceptFormat()</TT></B> returns <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>, the Media Kit will expect a connection request on <I><FONT  color=991122 face=HELVETICA>destination</I></FONT> with the specified <I><FONT  color=991122 face=HELVETICA>format</I></FONT> not to fail due to a format incompatibility.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
Don't try to ask the upstream producer about the format; it's waiting synchronously for your response, and doing so will cause deadlock.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="BufferReceived()"></A>BufferReceived()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>BufferReceived(</TT></B></FONT><A HREF="Buffer.html#BBuffer">BBuffer</A> *<I><FONT  color=991122 face=HELVETICA>buffer</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> = 0
<P>

</TABLE></TABLE>

<P>
When a <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A> sends buffers to one of your BBufferConsumer's inputs, it will eventually arrive here, at the <B><TT>BufferReceived()</TT></B> function (usually after first being dispatched by <B><TT><A HREF="#HandleMessage()">HandleMessage()</A></TT></B>).
<P>
Override this hook function to add the <I><FONT  color=991122 face=HELVETICA>buffer</I></FONT> to your internal playback queue, or to do whatever your node needs to do with buffers you consume.  If you implement both <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A> and <A HREF="#BBufferConsumer">BBufferConsumer</A>, it's possible you might examine or alter the data in the <I><FONT  color=991122 face=HELVETICA>buffer</I></FONT> and then call BBufferPr<B><TT>oducer::SendBuffer()</TT></B> to send it along to someone else.
<P>
Information about the contents and timing requirements of the <I><FONT  color=991122 face=HELVETICA>buffer</I></FONT> can be obtained by calling <B><TT><A HREF="Buffer.html#Header()">BBuffer::Header()</A></TT></B> on it.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
If you're writing a node, and receive a buffer with the <B><TT>B_SMALL_BUFFER</TT></B> flag set, you must recycle the buffer before returning.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="Connected()"></A>Connected()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>Connected(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>source</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>destination</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_format *<I><FONT  color=991122 face=HELVETICA>format</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_input *<I><FONT  color=991122 face=HELVETICA>outInput</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> = 0
<P>

</TABLE></TABLE>

<P>
This hook function is called when a connection is being established to your input <I><FONT  color=991122 face=HELVETICA>destination</I></FONT> from the specified <I><FONT  color=991122 face=HELVETICA>source</I></FONT> producer.  The connection will be composed of media data with the specified <I><FONT  color=991122 face=HELVETICA>format</I></FONT> (which you've previously accepted via <B><TT><A HREF="#AcceptFormat()">AcceptFormat()</A></TT></B>).
<P>
Your implementation of <B><TT>Connected()</TT></B> should do whatever preparation you need to do to handle data input on the connection, and fill out the <I><FONT  color=991122 face=HELVETICA>outInput</I></FONT> buffer with information about the connection from your node's point-of-view.  You can set <I><FONT  color=991122 face=HELVETICA>outInput</I></FONT>'s destination field different from <I><FONT  color=991122 face=HELVETICA>destination</I></FONT> if <I><FONT  color=991122 face=HELVETICA>destination</I></FONT> is a global connection-establishing input that's used to negotiate a connection, then create a new input to actually handle the data stream.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Since your BBufferConsumer has already had the opportunity to reject the specified <I><FONT  color=991122 face=HELVETICA>format</I></FONT>, it's poor form to return an error from this function.  You should only return an error if the resources needed to establish the connection have become unavailable prior to the time <B><TT>Connected()</TT></B> was called.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
On entry, <I><FONT  color=991122 face=HELVETICA>outInput</I></FONT>'s name field contains the name given the connection by the producer (this may be an empty string if the producer didn't assign a name).  Your consumer should always make sure there's a valid name here, because it's a bad thing to have unnamed connections, and there's no guarantee that the producer will fill this in.  If you don't have a good, descriptive name for a connection, the name should minimally contain the name of the node and a number that makes the connection's name unique (such as "MyNode Input 1" or "MyNode Output 3").
<P>
If you want the producer to use a specific <A HREF="BufferGroup.html#BBufferGroup">BBufferGroup</A> (for example, if you want a video producer to fill <A HREF="../The%20Game%20Kit/DirectWindow.html#BDirectWindow">BDirectWindow</A> buffers), you should create the <A HREF="BufferGroup.html#BBufferGroup">BBufferGroup</A> here, then call <B><TT>BMediaRoster::SetOutputBuffersFor()</TT></B> to set the producer's buffer group:
<P>
<PRE>&nbsp;&nbsp;&nbsp;BBufferGroup *buffers = new BBufferGroup;
&nbsp;&nbsp;&nbsp;BMediaRoster::Roster()->SetOutputBuffersFor(producer, buffers);</PRE>
<P>
Return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> if the connection is started safely, otherwise, return an appropriate error code.
<P>
<HR>
<H3>
<A NAME="ConsumerType()"></A>ConsumerType()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
media_type <B><TT><FONT  color=000022 size=+1>ConsumerType(</TT></B></FONT>const void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns the type of media the BBufferConsumer consumes.
<P>
<HR>
<H3>
<A NAME="Disconnected()"></A>Disconnected()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Disconnected(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>producer</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>whichInput</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> = 0
<P>

</TABLE></TABLE>

<P>
This hook function is called when a connection is being terminated.  You should do whatever needs to be done in order to ensure that future inquiries about the media_source connected to the media_input indicated by <I><FONT  color=991122 face=HELVETICA>whichInput</I></FONT> reference <B><TT>media_source::null</TT></B> (or, if another connection is later established on the input, that producer).
<P>
If your consumer node has created and set a <A HREF="BufferGroup.html#BBufferGroup">BBufferGroup</A> for the producer, you shouldn't delete or reclaim it here, because the producer has a clone of the <A HREF="BufferGroup.html#BBufferGroup">BBufferGroup</A> that references the same buffers; deleting the <A HREF="BufferGroup.html#BBufferGroup">BBufferGroup</A> would free those buffers, leaving the producer in deadlock.  Instead, delete (or reclaim) the when <B><TT><A HREF="#Connected()">Connected()</A></TT></B> is called again, and be sure to delete any remaining BBufferGroups in your destructor.
<P>
<HR>
<H3>
<A NAME="DisposeInputCookie()"></A>DisposeInputCookie()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>DisposeInputCookie(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> = 0
<P>

</TABLE></TABLE>

<P>
If the cookie value you return in <B><TT><A HREF="#GetNextInput()">GetNextInput()</A></TT></B> is a pointer to an object that needs to be deleted when the iteration process is completed, be sure to implement <B><TT>DisposeInputCookie()</TT></B> to do so.
<P>
<HR>
<H3>RequestFormatChange()</H3>
<P>
<HR>
<H3>
<A NAME="GetLatencyFor()"></A>GetLatencyFor()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>GetLatencyFor(</TT></B></FONT>const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>forWhom</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bigtime_t *<I><FONT  color=991122 face=HELVETICA>outLatency</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_node_id *<I><FONT  color=991122 face=HELVETICA>outTimeSource</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> = 0
<P>

</TABLE></TABLE>

<P>
Implement this hook function to calculate the total latency for the media_destination specified by <I><FONT  color=991122 face=HELVETICA>forWhom</I></FONT> and store the resulting value in <I><FONT  color=991122 face=HELVETICA>outLatency</I></FONT>.  Also, return the time source your node is slaved to in <I><FONT  color=991122 face=HELVETICA>outTimeSource</I></FONT>.
<P>
If your node is a BBufferProducer<A HREF="BufferProducer.html#BBufferProducer">RequestFormatChange()</A> as well as a <A HREF="#BBufferConsumer">BBufferConsumer</A>, you should include in your computed latency the latency of any nodes downstream from the specified connection that are slaved to the same time source.
<P>
Return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> if you successfully compute the latency; otherwise, return an appropriate error.
<P>
<HR>
<H3>
<A NAME="GetNextInput()"></A>GetNextInput()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>GetNextInput(</TT></B></FONT>int32 *<I><FONT  color=991122 face=HELVETICA>cookie</I></FONT>, media_input *<I><FONT  color=991122 face=HELVETICA>outInput</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> = 0
<P>

</TABLE></TABLE>

<P>
The first time a client calls this function, the value pointed to by <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT> will be 0.  You should fill the buffer pointed to by <I><FONT  color=991122 face=HELVETICA>outInput</I></FONT> with information about your first input, and set the value at <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT> to something (other than zero) that will let you keep track of what to return the next time <B><TT>GetNextInput()</TT></B> is called.
<P>
Each successive call to <B><TT>GetNextInput()</TT></B> will pass back, in <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT>, the value you returned in <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT> the last time the function was called by that client, and you should fill <I><FONT  color=991122 face=HELVETICA>outInput</I></FONT> with information about the next input, and store a new value in <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT> to continue to track your progress through the inputs.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Whenever this function is called with a value of zero in <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT>, you must start over with the first input.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
When you reach the last input, return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_INDEX">B_BAD_INDEX</A></TT></B> to indicate that there aren't any more inputs.
<P>
<HR>
<H3>
<A NAME="HandleMessage()"></A>HandleMessage()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>HandleMessage(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>message</I></FONT>, const void *<I><FONT  color=991122 face=HELVETICA>data</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
When your node derived from BBufferConsumer receives a message on its control port, you should try dispatching it by calling <B><TT><A HREF="#BBufferConsumer::HandleMessage()">BBufferConsumer::HandleMessage()</A></TT></B>. If BBufferConsumer doesn't understand the message, it'll return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B> and you can try dispatching it to another class from which your node is derived, or handle it yourself.
<P>
If this function returns <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>, the message has been handled.
<P>
<B>See also:  <TT><A HREF="MediaNode.html#HandleMessage()">BMediaNode::HandleMessage()</A></TT></B>, &nbsp;<a href="Intro.html#About%20Multiple%20Virtual%20Inheritance%20on%20page21">"About Multiple Virtual Inheritance" on page21</a>
<P>
<HR>
<H3>
<A NAME="NotifyLateProducer()"></A>NotifyLateProducer()
</H3>
<P>
static:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>NotifyLateProducer(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>source</I></FONT>, bigtime_t <I><FONT  color=991122 face=HELVETICA>howLate</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bigtime_t <I><FONT  color=991122 face=HELVETICA>performanceTime</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Notifies the <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A> specified by <I><FONT  color=991122 face=HELVETICA>source</I></FONT> that it's running late by <I><FONT  color=991122 face=HELVETICA>howLate</I></FONT> microseconds; the notification conditions as of the specified <I><FONT  color=991122 face=HELVETICA>performanceTime</I></FONT>.  Call this function when you detect that data is arriving too late and the run mode is <B><TT><A HREF="MediaNode.html#B_DECREASE_PRECISION">B_DECREASE_PRECISION</A></TT></B>, <B><TT><A HREF="MediaNode.html#B_INCREASE_LATENCY">B_INCREASE_LATENCY</A></TT></B>, or <B><TT><A HREF="MediaNode.html#B_DROP_DATA">B_DROP_DATA</A></TT></B> (any of which permits adjustment of the media playback to maintain timeliness).
<P>
The producer should process this notification immediately and take the appropriate action.
<P>
<HR>
<H3>
<A NAME="ProducerDataStatus()"></A>ProducerDataStatus()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>ProducerDataStatus(</TT></B></FONT>const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>destination</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 <I><FONT  color=991122 face=HELVETICA>status</I></FONT>, bigtime_t <I><FONT  color=991122 face=HELVETICA>atPerformanceTime</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> = 0
<P>

</TABLE></TABLE>

<P>
This hook function is called to inform your consumer about changes in the availability of buffers from the producer that's connected to the input <I><FONT  color=991122 face=HELVETICA>destination</I></FONT>.  The <I><FONT  color=991122 face=HELVETICA>status</I></FONT> argument specifies what change has occurred, and <I><FONT  color=991122 face=HELVETICA>atPerformanceTime</I></FONT> indicates when the change happened (or when it will happen).
<P>
This lets you keep track of which inputs you should await data from; for example, if your consumer is processing data arriving from four producers, and one of them stops sending buffers to the consumer, the producer that's stopping will cause a call to <B><TT>ProducerDataStatus()</TT></B> to let you know not to await buffers anymore.  This way, you know that when buffers have arrived from the other three inputs, it's okay to begin processing the buffers.
<P>
<TABLE BORDER cellpadding=4>
<TH><B>Constant</B></TH>
<TH>Meaning</TH>
<TR>
<TD><B><TT>B_DATA_NOT_AVAILABLE</TT></B></TD>
<TD>The producer doesn't have any data available.</TD>
<TR>
<TD><B><TT>B_DATA_AVAILABLE</TT></B></TD>
<TD>The producer has data available.</TD>
<TR>
<TD><B><TT>B_PRODUCER_STOPPED</TT></B></TD>
<TD>The producer has been stopped.</TD>
</TABLE>
<P>
<HR>
<H3>
<A NAME="RegionToClipData()"></A>RegionToClipData()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
static status_t <B><TT><FONT  color=000022 size=+1>RegionToClipData(</TT></B></FONT>const <A HREF="../Release%20Notes/InterfaceKit.html#BRegion">BRegion</A> *<I><FONT  color=991122 face=HELVETICA>region</I></FONT>, int32 *<I><FONT  color=991122 face=HELVETICA>format</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 *<I><FONT  color=991122 face=HELVETICA>ioSize</I></FONT>, void *<I><FONT  color=991122 face=HELVETICA>data</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Converts a <A HREF="../Release%20Notes/InterfaceKit.html#BRegion">BRegion</A> into the clipping format used internally by the Media Kit.  Prior to calling <B><TT>RegionToClipData()</TT></B>, <I><FONT  color=991122 face=HELVETICA>ioSize</I></FONT> is set to the size of the buffer pointed to by <I><FONT  color=991122 face=HELVETICA>data</I></FONT>.  On return, <I><FONT  color=991122 face=HELVETICA>format</I></FONT> is the format of the clipping data, <I><FONT  color=991122 face=HELVETICA>ioSize</I></FONT> is changed to the actual number of bytes of data returned, and <I><FONT  color=991122 face=HELVETICA>data</I></FONT> contains the actual clipping data.
<P>
The clip data format is described in the section &nbsp;<a href="BufferProducer.html#Video%20Clipping%20on%20page85">"Video Clipping" on page85</a>.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  Clip data returned without errors.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_NO_MEMORY">B_NO_MEMORY</A></TT></B>.  The <I><FONT  color=991122 face=HELVETICA>data</I></FONT> buffer isn't big enough.
<P>
</UL>
<P>
<B>See also:  </B>&nbsp;<a href="BufferProducer.html#Video%20Clipping%20on%20page85">"Video Clipping" on page85</a>
<P>
<HR>
<H3>
<A NAME="RequestAdditionalBuffer()"></A>RequestAdditionalBuffer()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>RequestAdditionalBuffer(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>source</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="Buffer.html#BBuffer">BBuffer</A> *<I><FONT  color=991122 face=HELVETICA>previousBuffer,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I></FONT>void *<I><FONT  color=991122 face=HELVETICA>_reserved_</I></FONT> = <FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>RequestAdditionalBuffer(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>source</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bigtime_t <I><FONT  color=991122 face=HELVETICA>startTime,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I></FONT>void *<I><FONT  color=991122 face=HELVETICA>_reserved_</I></FONT> = <FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Asks the upstream producer specified by <I><FONT  color=991122 face=HELVETICA>source</I></FONT> to immediately send the next buffer, instead of waiting until the appropriate time.  The most obvious use for this function is in cases where a codec requires multiple buffers in order to decode a frame of output (MPEG is a good example).
<P>
The requested buffer can be identified either by a <I><FONT  color=991122 face=HELVETICA>startTime</I></FONT> parameter, which indicates the time for which a buffer is requested, or by a <I><FONT  color=991122 face=HELVETICA>previousBuffer</I></FONT>, which specifies the buffer prior to the one being requested.
<P>
This function will cause the producer's <B><TT><A HREF="BufferProducer.html#AdditionalBufferRequested()">AdditionalBufferRequested()</A></TT></B> function to be called.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The change was requested successfully.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_MEDIA_BAD_SOURCE">B_MEDIA_BAD_SOURCE</A></TT></B>.  The <I><FONT  color=991122 face=HELVETICA>source</I></FONT> isn't valid.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_VALUE">B_BAD_VALUE</A></TT></B>.  The <I><FONT  color=991122 face=HELVETICA>previousBuffer</I></FONT> pointer is <B><TT>NULL</TT></B>.
<P>
<LI><B><TT><A HREF="../The%20Kernel%20Kit/Semaphores.html#B_TIMEOUT">B_TIMEOUT</A></TT></B>.  The request to the Media Server timed out.
<P>
<LI>Port errors.  An error occurred communicating with the Media Server.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="RequestFormatChange"></A>RequestFormatChange
, 
<A NAME="FormatChanged()"></A>FormatChanged()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>RequestFormatChange(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>source</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>destination</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_format &amp;<I><FONT  color=991122 face=HELVETICA>toFormat</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>userData</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 *<I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>_reserved_</I></FONT> = <FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>FormatChanged(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>source</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>destination</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 <I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_format &amp;<I><FONT  color=991122 face=HELVETICA>newFormat</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> = 0
<P>

</TABLE></TABLE>

<P>
<B><TT>RequestFormatChange()</TT></B> requests that the producer <I><FONT  color=991122 face=HELVETICA>source</I></FONT> connected to the consumer <I><FONT  color=991122 face=HELVETICA>destination</I></FONT> change the format it produces to the format specified by <I><FONT  color=991122 face=HELVETICA>toFormat</I></FONT>.  The Media Kit returns in <I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT> the tag value that will be received by your <B><TT><A HREF="MediaNode.html#RequestCompleted()">RequestCompleted()</A></TT></B> function once the change takes effect; the change tag lets you match up the call to <B><TT><A HREF="MediaNode.html#RequestCompleted()">RequestCompleted()</A></TT></B> with this request.  This function will receive a <B><TT><A HREF="misc_api.html#media_request_info">media_request_info</A></TT></B> structure with the indicated <I><FONT  color=991122 face=HELVETICA>userData</I></FONT> and <I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT>.
<P>
<B><TT>FormatChanged()</TT></B> is called by the upstream producer when the media format your node will be receiving changes, and indicates the new format in <I><FONT  color=991122 face=HELVETICA>newFormat</I></FONT> and the change tag value at which the new format will take effect in <I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT>.  You should implement this function so your node will know that the data format is going to change.  Note that this may be called in response to your <B><TT><A HREF="#AcceptFormat()">AcceptFormat()</A></TT></B> call, if your <B><TT><A HREF="#AcceptFormat()">AcceptFormat()</A></TT></B> call alters any wildcard fields in the specified format.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Because <B><TT>FormatChanged()</TT></B> is called by the producer, you don't need to (and shouldn't) ask it if the new format is acceptable.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
If the format change isn't possible, return an appropriate error from <B><TT>FormatChanged()</TT></B>; this error will be passed back to the producer that initiated the new format negotiation in the first place.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  No error.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_MEDIA_BAD_SOURCE">B_MEDIA_BAD_SOURCE</A></TT></B>.  The specified source isn't valid.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_MEDIA_BAD_DESTINATION">B_MEDIA_BAD_DESTINATION</A></TT></B>.  The specified destination is invalid.
<P>
<LI>Port errors.  See
<P>
<HR>
<H1>
<A NAME="Port"></A>Port
</H1>
<P>
s.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="SeekTagRequested()"></A>SeekTagRequested()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>SeekTagRequested(</TT></B></FONT>const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>destination</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bigtime_t <I><FONT  color=991122 face=HELVETICA>inTargetTime,</I></FONT> uint32 <I><FONT  color=991122 face=HELVETICA>inFlags</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_seek_tag *<I><FONT  color=991122 face=HELVETICA>outSeekTag</I></FONT>, bigtime_t *<I><FONT  color=991122 face=HELVETICA>outTaggedTime</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 *<I><FONT  color=991122 face=HELVETICA>outFlags</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This function is provided to aid in supporting media formats in which the outer encapsulation layer doesn't supply timing information.  Producers will tag the buffers they generate with seek tags; these tags can be used to locate key frames in the media data.
<P>
It's the consumer's job to match up seek tags with performance times.  As the consumer processes each incoming buffer, it should cache the seek tag and the performance time at which it occurs (if there's a tag on the buffer).  When the producer needs to know the seek tag and corresponding time that's closest to a given performance time, this function is resonsible for returning that information.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  No error.
<P>
<UL>
<LI>Other errors, depending on the node's implementation.
<P>
</UL>
<P>
<B>See also:  </B><a href="BufferProducer.html#Seek%20Tags">"Seek Tags"</a>
<P>
<HR>
<H3>
<A NAME="SendLatencyChange()"></A>SendLatencyChange()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SendLatencyChange(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>source</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_destination &amp;<I><FONT  color=991122 face=HELVETICA>destination,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>newLatency</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = <FONT  face=HELVETICA>0</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Lets the upstream producer know that the consumer node's latency has changed.  <I><FONT  color=991122 face=HELVETICA>newLatency</I></FONT> indicates your new latency, in microseconds.  The <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> are currently unused and should always be 0.
<P>
You should call this whenever something happens to cause a change in your latency.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  No error.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_MEDIA_BAD_SOURCE">B_MEDIA_BAD_SOURCE</A></TT></B>.  The source is invalid.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_MEDIA_BAD_DESTINATION">B_MEDIA_BAD_DESTINATION</A></TT></B>.  The destination is invalid.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_TIMED_OUT">B_TIMED_OUT</A></TT></B>.  The attempt to communicate with the Media Server timed out.
<P>
<LI>Port errors.  An error occurred communicating with the Media Server.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="SetOutputBuffersFor()"></A>SetOutputBuffersFor()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SetOutputBuffersFor(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>source</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>destination</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="BufferGroup.html#BBufferGroup">BBufferGroup</A> *<I><FONT  color=991122 face=HELVETICA>group,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I></FONT>void *<I><FONT  color=991122 face=HELVETICA>userData</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 *<I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool <I><FONT  color=991122 face=HELVETICA>willReclaim</I></FONT> = <FONT  face=HELVETICA>false</FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>_reserved_</I></FONT> = <FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Specifies that the <A HREF="BufferGroup.html#BBufferGroup">BBufferGroup</A> <I><FONT  color=991122 face=HELVETICA>group</I></FONT> will provide the buffers for the connection between <I><FONT  color=991122 face=HELVETICA>source</I></FONT> and <I><FONT  color=991122 face=HELVETICA>destination</I></FONT>.  If <I><FONT  color=991122 face=HELVETICA>willReclaim</I></FONT> is <B><TT>false</TT></B>, the Media Kit will dispose of the group for you; you can forget about it once this call returns.  Otherwise, you're informing the Media Server that you want the group back, and that you'll delete it when you're done with it.
<P>
The Media Kit returns in <I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT> the tag value that will be received by your <B><TT><A HREF="MediaNode.html#RequestCompleted()">RequestCompleted()</A></TT></B> function once the change takes effect; the change tag lets you match up the call to <B><TT><A HREF="MediaNode.html#RequestCompleted()">RequestCompleted()</A></TT></B> with this request.  This function will receive a <B><TT><A HREF="misc_api.html#media_request_info">media_request_info</A></TT></B> structure with the indicated <I><FONT  color=991122 face=HELVETICA>userData</I></FONT> and <I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT>.
<P>
The ability to request that certain buffers be used by a particular output can save you from having to perform unnecessary copies; you might be able to use BBuffers that represent a graphics card frame buffer, for example, so that a video producer's output goes directly to video memory.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Before reclaiming your buffers, be sure to call <B><TT>SetOutputBuffersFor(output, NULL)</TT></B> to let the Media Kit know your producer no longer has permission to use them.  If you forget this step, the producer will hang onto the buffers until it's deleted, and your <B><TT>BMediaRoster::<A HREF="BufferGroup.html#ReclaimAllBuffers()">ReclaimAllBuffers()</A></TT></B> call will hang, possibly forever.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The change was requested successfully.
<P>
<UL>
<LI>Other errors.  The change could not be made.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="SetOutputEnabled()"></A>SetOutputEnabled()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
static status_t <B><TT><FONT  color=000022 size=+1>SetOutputEnabled(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>source</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>destination</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool <I><FONT  color=991122 face=HELVETICA>enabled</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>userData</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 *<I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>_reserved_</I></FONT> = <FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Specifies whether or not the specified <I><FONT  color=991122 face=HELVETICA>output</I></FONT> should be transmitting buffers to the <I><FONT  color=991122 face=HELVETICA>destination</I></FONT>.  If <I><FONT  color=991122 face=HELVETICA>enabled</I></FONT> is <B><TT>true</TT></B>, the producer should transmit buffers; otherwise it should not.
<P>
The Media Kit returns in <I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT> the tag value that will be received by your <B><TT><A HREF="MediaNode.html#RequestCompleted()">RequestCompleted()</A></TT></B> function once the change takes effect; the change tag lets you match up the call to <B><TT><A HREF="MediaNode.html#RequestCompleted()">RequestCompleted()</A></TT></B> with this request.  This function will receive a <B><TT><A HREF="misc_api.html#media_request_info">media_request_info</A></TT></B> structure with the indicated <I><FONT  color=991122 face=HELVETICA>userData</I></FONT> and <I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT>.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The change was requested successfully.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_MEDIA_BAD_SOURCE">B_MEDIA_BAD_SOURCE</A></TT></B>.  The <I><FONT  color=991122 face=HELVETICA>source</I></FONT> is invalid.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="SetVideoClippingFor()"></A>SetVideoClippingFor()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SetVideoClippingFor(</TT></B></FONT>const media_source &amp;<I><FONT  color=991122 face=HELVETICA>output</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_destination &amp;<I><FONT  color=991122 face=HELVETICA>destination</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int16 *<I><FONT  color=991122 face=HELVETICA>shortsList</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 <I><FONT  color=991122 face=HELVETICA>shortCount</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const media_video_display_info &amp;<I><FONT  color=991122 face=HELVETICA>display</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>userData</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 *<I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>_reserved_</I></FONT> = <FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This function requests that video buffers sent by the specified <I><FONT  color=991122 face=HELVETICA>output</I></FONT> to the specified <I><FONT  color=991122 face=HELVETICA>destination</I></FONT> clip all its writing in buffers it sends to the BBufferConsumer to the clipping region described by <I><FONT  color=991122 face=HELVETICA>shortsList</I></FONT> and <I><FONT  color=991122 face=HELVETICA>shortCount</I></FONT>.  The clip data format is described in the section &nbsp;<a href="BufferProducer.html#Video%20Clipping%20on%20page85">"Video Clipping" on page85</a>.
<P>
The Media Kit returns in <I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT> the tag value that will be received by your <B><TT><A HREF="MediaNode.html#RequestCompleted()">RequestCompleted()</A></TT></B> function once the change takes effect; the change tag lets you match up the call to <B><TT><A HREF="MediaNode.html#RequestCompleted()">RequestCompleted()</A></TT></B> with this request.  This function will receive a <B><TT><A HREF="misc_api.html#media_request_info">media_request_info</A></TT></B> structure with the indicated <I><FONT  color=991122 face=HELVETICA>userData</I></FONT> and <I><FONT  color=991122 face=HELVETICA>changeTag</I></FONT>.
<P>
The <B><TT><A HREF="misc_api.html#media_video_display_info">media_video_display_info</A></TT></B> structure referenced by <I><FONT  color=991122 face=HELVETICA>display</I></FONT> describes the current configuration of the video in terms of color space, resolution, and so forth.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The clipping request has been sent without errors.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_MEDIA_BAD_CLIP_FORMAT">B_MEDIA_BAD_CLIP_FORMAT</A></TT></B>.  The clipping data isn't formatted correctly.
<P>
<LI>Port errors.  See <a href="../../r3kernelPorts.html#Ports">Ports</a>.
<P>
</UL>
<P>
<B>See also:  </B>&nbsp;<a href="BufferProducer.html#Video%20Clipping%20on%20page85">"Video Clipping" on page85</a>
<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Media Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Media%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Media Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

