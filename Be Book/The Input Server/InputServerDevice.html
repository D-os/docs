<HTML><HEAD><TITLE>The Input Server: BInputServerDevice</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Input Server Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Input%20Server%20Master%20Index.html"><FONT face=HELVETICA>The Input Server Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="BInputServerDevice"></A>BInputServerDevice
</H1>
<P>
Derived from:  none
<P>
Declared in:  <A HREF="/boot/develop/headers/be/add-ons/input_server/InputServerDevice.h">be/add-ons/input_server/InputServerDevice.h</A>
<P>
Library:  The Input Server
<P>
Allocation:  By the Input Server only
<P>
<H6><A HREF="InputServerDevice.summary.html"><i>Summary</i></A></H6>
<P>
BInputServerDevice is a base class for <I>input devices</I>; these are instances of BInputServerDevice subclasses that generate <I>input events</I>.  In most cases, an input device corresponds to a device driver that handles a specific brand or model of hardware (mouse, keyboard, tablet, etc.), but it doesn't have to:  an input device can get events from the Net, or generate them algorithmically, for example.  Also, a single BInputServerDevice can handle more than one device driver.
<P>
BInputServerDevice objects are created and deleted by the Input Server only&mdash;you never create or delete these objects themselves.
<P>
<HR>
<H2>
<A NAME="Starting%20and%20Sending%20Messages"></A><FONT SIZE=6>S</FONT>tarting and <FONT SIZE=6>S</FONT>ending <FONT SIZE=6>M</FONT>essages
</H2>
<P>
For each device that your object registers, it gets a <B><TT><A HREF="#Start()">Start()</A></TT></B> function call.  This is the Input Server's way of telling your object that it can begin generating input events (for the designated device).  So far, all of this&mdash;from the add-on load to the <B><TT><A HREF="#Start()">Start()</A></TT></B> call&mdash;happens within a single Input Server thread (for all input devices).  When your <B><TT><A HREF="#Start()">Start()</A></TT></B> function is called, you should spawn a thread so your object can generate events without blocking the Server.  Events are generated and sent through the <B><TT><A HREF="#EnqueueMessage()">EnqueueMessage()</A></TT></B> function.
<P>
<HR>
<H2>
<A NAME="Device%20Types%20and%20Control%20Messages"></A><FONT SIZE=6>D</FONT>evice <FONT SIZE=6>T</FONT>ypes and <FONT SIZE=6>C</FONT>ontrol <FONT SIZE=6>M</FONT>essages
</H2>
<P>
The Input Server knows about two types of devices:  keyboards, and pointing devices (mice, tablets, etc).  When you register your object's devices (through <B><TT><A HREF="#RegisterDevices()">RegisterDevices()</A></TT></B>) you have to indicate the <I>device type</I>.  The Input Server uses the device type to predicate the <I>input device control messages</I> it sends to the devices.  These messages, delivered in <B><TT><A HREF="#Control()">Control()</A></TT></B> calls, tell a device that there's been a change downstream that applies specifically to that type of device.  For example, when the user changes the mouse speed, each pointing device receives a <B><TT><A HREF="InputServerMessages.html#B_MOUSE_SPEED_CHANGED">B_MOUSE_SPEED_CHANGED</A></TT></B> notification.
<P>
The Be-defined control messages are predicated on device type only.
<P>
If your BInputServerDevice object manages a device other than a pointer or a keyboard, you tell the Input Server that the device is undefined.  In this case, the Input Server won't send your device any device-specific messages; to send your device a message you (or an application that knows about your device) have to use a <A HREF="InputDevice.html#BInputDevice">BInputDevice</A> object.
<P>
<HR>
<H3>
<A NAME="Pointing%20Devices"></A>Pointing Devices
</H3>
<P>
Pointing devices such as mice, trackballs, drawing tablets, etc. generate <B><TT><A HREF="../Messages/GeneralMessages.html#B_MOUSE_MOVED">B_MOUSE_MOVED</A></TT></B> messages (which trigger a BView&gt;s <B><TT><A HREF="../The%20Interface%20Kit/TextView.html#MouseMoved()">MouseMoved()</A></TT></B> function) featuring a <I><FONT  color=991122 face=HELVETICA>where</I></FONT> field representing the cursor&gt;s location in view co-ordinates.  Unfortunately, your BInputServerDevice doesn&gt;t know anything about views; that&gt;s the App Server&gt;s job. You'll still need to add this information to the <B><TT><A HREF="../Messages/GeneralMessages.html#B_MOUSE_MOVED">B_MOUSE_MOVED</A></TT></B> messages generated by your <A HREF="#BInputServerDevice">BInputServerDevice</A>, and the App Server will adjust it to view co-ordinates for you.
<P>
When generating a <B><TT><A HREF="../Messages/GeneralMessages.html#B_MOUSE_MOVED">B_MOUSE_MOVED</A></TT></B> message, you add <I><FONT  color=991122 face=HELVETICA>x</I></FONT> and <I><FONT  color=991122 face=HELVETICA>y</I></FONT> fields in one of two ways:
<P>
<UL>
<LI>an offset relative to the cursor&gt;s previous position (<B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B> values)
<P>
<LI>an absolute position expressed in the range 0.0 to 1.0 (<B><TT><A HREF="../The%20Support%20Kit/misc.html#B_FLOAT_TYPE">B_FLOAT_TYPE</A></TT></B> values)
<P>
</UL>
<P>
Mice always use relative locations; tablets can use either (though they usually provide absolute values).
<P>
<H4>
<A NAME="Relative%20Locations"></A>Relative Locations
</H4>
<P>
All mice (and some drawing tablets) express the pointer location relative to its previous position.  If your pointing device is operating in relative co-ordinate mode, you add <I><FONT  color=991122 face=HELVETICA>x</I></FONT> and <I><FONT  color=991122 face=HELVETICA>y</I></FONT> entries as <B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B> values in device-defined units.  The App Server interprets these units as pixels, so you may need to scale your output:
<P>
<PRE>&nbsp;&nbsp;&nbsp;int32 xVal, yVal;
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;event->AddInt32( "x", xVal );
&nbsp;&nbsp;&nbsp;event->AddInt32( "y", yVal );</PRE>
<P>
<H4>
<A NAME="Absolute%20Locations"></A>Absolute Locations
</H4>
<P>
Drawing tablets or other pointing devices that provide absolute locations add the <I><FONT  color=991122 face=HELVETICA>x</I></FONT> and <I><FONT  color=991122 face=HELVETICA>y</I></FONT> entries as <B><TT><A HREF="../The%20Support%20Kit/misc.html#B_FLOAT_TYPE">B_FLOAT_TYPE</A></TT></B>s:
<P>
<PRE>&nbsp;&nbsp;&nbsp;float xVal, yVal;
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;event->AddFloat( "x", xVal );
&nbsp;&nbsp;&nbsp;event->AddFloat( "y", yVal );</PRE>
<P>
These values must be in the range [0.0 to 1.0].  The app_server scales them to the screen&gt;s co-ordinate system so (0.0, 0.0) is the left-top, and (1.0, 1.0) is the right-bottom of the screen.  This lets the pointing device work with any screen resolution, automatically.
<P>
<H4>
<A NAME="Now%20where?"></A>Now where?
</H4>
<P>
When the Application Server receives one of these <B><TT><A HREF="../Messages/GeneralMessages.html#B_MOUSE_MOVED">B_MOUSE_MOVED</A></TT></B> messages, it converts the <I><FONT  color=991122 face=HELVETICA>x</I></FONT> and <I><FONT  color=991122 face=HELVETICA>y</I></FONT> values into absolute values in the target view&gt;s co-ordinate system, and then throws away the <I><FONT  color=991122 face=HELVETICA>x</I></FONT> and <I><FONT  color=991122 face=HELVETICA>y</I></FONT> entries in the message.  Because of this, and the fact that some applications might want more accurate positional information from tablets, fill in the <I><FONT  color=991122 face=HELVETICA>be:tablet_x</I></FONT> and <I><FONT  color=991122 face=HELVETICA>be:tablet_y</I></FONT> fields as well:
<P>
<PRE>&nbsp;&nbsp;&nbsp;float xVal, yVal;
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;event->AddFloat( "x", xVal );
&nbsp;&nbsp;&nbsp;event->AddFloat( "y", yVal );
&nbsp;&nbsp;&nbsp;event->AddFloat( "be:tablet_x", xVal );
&nbsp;&nbsp;&nbsp;event->AddFloat( "be:tablet_y", yVal );</PRE>
<P>
<H4>
<A NAME="Other%20Useful%20Information"></A>Other Useful Information
</H4>
<P>
Pressure information is stored in the <I><FONT  color=991122 face=HELVETICA>be:tablet_pressure</I></FONT> field, as a float in the range [0.0 to 1.0] (minimum pressure to maximum pressure):
<P>
<PRE>&nbsp;&nbsp;&nbsp;float pressure;
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;event->AddFloat( "be:tablet_pressure", pressure );</PRE>
<P>
If the tablet supports tilt information, store it in <I><FONT  color=991122 face=HELVETICA>be:tablet_tilt_x</I></FONT> and <I><FONT  color=991122 face=HELVETICA>be:tablet_tilt_y</I></FONT>, scaling the information to the range [0.0 to 1.0].  A tilt of (-1.0, -1.0) tilts to the left-top, (1.0, 1.0) tilts to the right-bottom, and (0.0, 0.0) is no tilt.
<P>
<PRE>&nbsp;&nbsp;&nbsp;float tilt_x, tilt_y;
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;event->AddFloat( "be:tablet_tilt_x", tilt_x );
&nbsp;&nbsp;&nbsp;event->AddFloat( "be:tablet_tilt_y", tilt_y );</PRE>
<P>
Tablets with pens that support an eraser store the eraser&gt;s state in the <I><FONT  color=991122 face=HELVETICA>be:tablet_eraser</I></FONT> field.  A value of 1 means the pen is reversed (i.e. the eraser is on), and 0 means it should behave normally.
<P>
<PRE>&nbsp;&nbsp;&nbsp;int32 erase_mode;
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;event->AddInt32( "be:tablet_eraser", erase_mode );</PRE>
<P>
<HR>
<H2>
<A NAME="Device%20State"></A><FONT SIZE=6>D</FONT>evice <FONT SIZE=6>S</FONT>tate
</H2>
<P>
The <B><TT><A HREF="#Control()">Control()</A></TT></B> protocol is designed to accommodate queries (in addition to commands).  Currently, however, the Input Server maintains the keyboard and pointing device state and answers these queries itself; it doesn't forward any of the Be-defined query messages. For example, when an application asks for the current mouse speed setting (through <B><TT><A HREF="InputFunctions.html#get_mouse_speed()">get_mouse_speed()</A></TT></B>), the query gets no further than the Input Server itself&mdash;it doesn't get passed as a control message to a pointing device.
<P>
If you're designing a BInputServerDevice that manages a keyboard or pointing device, you must keep in mind that your device is not responsible for its "Be-defined" state. The elements of the state&mdash;mouse speed, key map, etc.&mdash;correspond to the control messages listed in <a href="InputServerMessages.html#Input%20Device%20Control%20Messages">"Input Device Control Messages"</a>.
<P>
<HR>
<H2>
<A NAME="Dynamic%20Devices"></A><FONT SIZE=6>D</FONT>ynamic <FONT SIZE=6>D</FONT>evices
</H2>
<P>
As hardware devices are attached and detached from the computer, you can add and remove items from your BInputServerDevice's list of registered devices (by calling <B><TT>RegisterDevice()</TT></B>/<B><TT>UnregisterDevice()</TT></B>).  But your object has to first <I>notice</I> that a physical device has been added or removed.  It does this by placing a node monitor on the device directory (<B>/dev</B>).  As a convenience&mdash;and to help conserve resources&mdash;the BInputServerDevice class provides the <B><TT>Start</TT></B>/<B><TT>StopMonitoringDevices()</TT></B> functions which install and remove node monitors for you.
<P>
<HR>
<H2>
<A NAME="Creating%20and%20Registering"></A><FONT SIZE=6>C</FONT>reating and <FONT SIZE=6>R</FONT>egistering
</H2>
<P>
To create a new input device, you must:
<P>
<UL>
<LI>create a subclass of BInputServerDevice
<P>
<LI>implement the <B><TT>instantiate_input_device()</TT></B> C function to create an instance of your BInputServerDevice subclass
<P>
<LI>compile the class and the function as an add-on
<P>
<LI>install the add-on in one of the <I>input device directories
<P>
</I></UL>
<P>
At boot time, the Input Server loads the add-ons it finds in the input device directories.   For each add-on it loads, the Server invokes <B><TT>instantiate_input_device()</TT></B> to get a pointer to the add-on's BInputServerDevice object.  After constructing the object, the Server calls <B><TT><A HREF="#InitCheck()">InitCheck()</A></TT></B> to give the add-on a chance to bail out if the constructor failed.  If the add-on wants to continue, it calls <B><TT><A HREF="#RegisterDevices()">RegisterDevices()</A></TT></B> (from within <B><TT><A HREF="#InitCheck()">InitCheck()</A></TT></B>) to tell the Server which physical or virtual devices it handles.  
<P>
<HR>
<H2>
<A NAME="Installing%20an%20Input%20Device"></A><FONT SIZE=6>I</FONT>nstalling an <FONT SIZE=6>I</FONT>nput <FONT SIZE=6>D</FONT>evice
</H2>
<P>
The input server looks for input devices in the "<B>input_server/devices</B>" subdirectories of <B><TT>B_BEOS_ADDONS_DIRECTORY</TT></B>, <B><TT>B_COMMON_ADDONS_DIRECTORY,</TT></B> and <B><TT>B_USER_ADDONS_DIRECTORY</TT></B>.  
<P>
<UL>
<LI>You can install your input devices in the latter two directories&mdash;i.e. those under <B><TT>B_COMMON_ADDONS_DIRECTORY</TT></B>, and <B><TT>B_USER_ADDONS_DIRECTORY</TT></B>.  
<P>
<LI>The <B><TT>B_BEOS_ADDONS_DIRECTORY</TT></B> is reserved for add-ons that are supplied by the BeOS. 
<P>
</UL>
<P>
<HR>
<H2>
<A NAME="Hook%20Functions"></A><FONT SIZE=6>H</FONT>ook <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<UL>
<LI><B><TT><A HREF="#Control()">Control()</A>
<P>
</TT></B><LI><B><TT><A HREF="#InitCheck()">InitCheck()</A>
<P>
</TT></B><LI><B><TT><A HREF="#Start()">Start()</A>
<P>
</TT></B><LI><B><TT><A HREF="#Stop()">Stop()</A>
<P>
</TT></B><LI><B><TT><A HREF="#SystemShuttingDown()">SystemShuttingDown()</A>
<P>
</TT></B></UL>
<P>
<HR>
<H2>
<A NAME="Constructor%20and%20Destructor"></A><FONT SIZE=6>C</FONT>onstructor and <FONT SIZE=6>D</FONT>estructor
</H2>
<P>
<HR>
<H3>
<A NAME="BInputServerDevice()"></A>BInputServerDevice()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>BInputServerDevice(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
Creates a new BInputServerDevice object.  You can initialize your object&mdash;set initial values, spawn (but not necessarily resume; do that in <B><TT><A HREF="#Start()">Start()</A></TT></B>) threads, open drivers, etc.&mdash;either here or in the <B><TT><A HREF="#InitCheck()">InitCheck()</A></TT></B> function, which is called immediately after the constructor.  
<P>
<HR>
<H3>
<A NAME="~BInputServerDevice()"></A>~BInputServerDevice()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>~</TT></B></FONT>BInputServerDevice<B><TT><FONT  color=000022 size=+1>()
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Deletes the BInputServerDevice object.  The destructor is invoked by the Input Server only&mdash;you never delete a BInputServerDevice object from your own code.  When the destructor is called, the object's devices will already be unregistered and <B><TT><A HREF="#Stop()">Stop()</A></TT></B> will already have been called.  If this object spawned its own threads or allocated memory on the heap, it must clean up after itself here.
<P>
<HR>
<H2>
<A NAME="Member%20Functions"></A><FONT SIZE=6>M</FONT>ember <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="Control()"></A>Control()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t  <B><TT><FONT  color=000022 size=+1>Control(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>name</I></FONT>, 
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>cookie</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 <I><FONT  color=991122 face=HELVETICA>command</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>message</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
The <B><TT><A HREF="#Control()">Control()</A></TT></B> hook function is invoked by the Input Server to send an <I>input device control message</I> or a Node Monitor message to this object.  <I><FONT  color=991122 face=HELVETICA>name</I></FONT> and <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT> are the readable name and pointer-to-whatever-you-want that you used when registering the device (with the <B><TT><A HREF="#RegisterDevices()">RegisterDevices()</A></TT></B> function).
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The function's return value is ignored.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<H5>
<A NAME="Input%20Device%20Control%20Messages"></A>Input Device Control Messages
</H5>
<P>
An input device control message is sent when a downstream change needs to be propagated to an input device.  For example, when the user resets the mouse speed (through the <B>Mouse</B> preference), a <B><TT><A HREF="InputServerMessages.html#B_MOUSE_SPEED_CHANGED">B_MOUSE_SPEED_CHANGED</A></TT></B> control message is sent to all objects that have registered a <B><TT><A HREF="InputDefs.html#Device%20Types">B_POINTING_DEVICE</A></TT></B> device (see <B><TT><A HREF="#RegisterDevices()">RegisterDevices()</A></TT></B>).  <I><FONT  color=991122 face=HELVETICA>name</I></FONT> and <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT> identify the device that this message applies to.  The control message itself is represented by the <I><FONT  color=991122 face=HELVETICA>command</I></FONT> constant, optionally supplemented by <I><FONT  color=991122 face=HELVETICA>message</I></FONT>.  
<P>
See <a href="InputServerMessages.html#Input%20Device%20Control%20Messages">"Input Device Control Messages"</a> for a list of the control messages that the BeOS defines, and instructions for how to respond to them.  An application can send a custom control message through a <A HREF="InputDevice.html#BInputDevice">BInputDevice</A> object; see <B><TT><A HREF="InputDevice.html#Control()">BInputDevice::Control()</A></TT></B> for details.
<P>
<H5>
<A NAME="Node%20Monitor%20Messages"></A>Node Monitor Messages
</H5>
<P>
A Node Monitor message is sent if an entry is added to or removed from one of the device directories that the object is monitoring, as set through <B><TT><A HREF="#StartMonitoringDevice()">StartMonitoringDevice()</A></TT></B>.  In this case, <I><FONT  color=991122 face=HELVETICA>name</I></FONT> and <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT> are <B><TT>NULL</TT></B>, command is <B><TT><A HREF="../Messages/GeneralMessages.html#B_NODE_MONITOR">B_NODE_MONITOR</A></TT></B>, and <I><FONT  color=991122 face=HELVETICA>message</I></FONT> describes the file that was added or deleted.  The message's <B><TT>opcode</TT></B> field will be <B><TT><A HREF="../The%20Storage%20Kit/Directory.html#B_ENTRY_CREATED">B_ENTRY_CREATED</A></TT></B> or <B><TT><A HREF="../The%20Storage%20Kit/Directory.html#B_ENTRY_REMOVED">B_ENTRY_REMOVED</A></TT></B> (or, potentially but nonsensically, <B><TT><A HREF="../The%20Storage%20Kit/Directory.html#B_ENTRY_MOVED">B_ENTRY_MOVED</A></TT></B>).  For instructions on how to read these messages, see  <a href="../The Storage KitNodeMonitor.html#The%20Node%20Monitor">"The Node Monitor"</a> in the Storage Kit (or click on the opcode constants). 
<P>
<HR>
<H3>
<A NAME="EnqueueMessage()"></A>EnqueueMessage()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>EnqueueMessage(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>message</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Sends an event message to the Input Server, which passes it through the input methods and input filters before sending it to the App Server.  The message you create should be appropriate for the action you're trying to depict.  For example, if the user presses a key, you should create and send a <B><TT><A HREF="../Messages/GeneralMessages.html#B_KEY_DOWN">B_KEY_DOWN</A></TT></B> message.  A list of the system-defined event messages that an input device is expected to create and send is given in <a href="InputServerMessages.html#Input%20Device%20Event%20Messages">"Input Device Event Messages"</a>.   
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The message was sent.
<P>
<UL>
<LI><I>Anything else</I>.  The connection to the App Server has been broken&mdash;this isn't good, and you may want to check the <B><TT><A HREF="../The%20Kernel%20Kit/SysTime.html#is_computer_on_fire()">is_computer_on_fire()</A></TT></B> function found in the Kernel Kit.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="InitCheck()"></A>InitCheck()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>InitCheck(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
Invoked by the Input Server immediately after the object is constructed to test the validity of the initialization.  If the object is properly initialized (i.e. all required resources are located or allocated), this function should return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  <B><TT><A HREF="#Start()">Start()</A></TT></B> will be invoked soon if you need to do any extra initialization.  If the object returns non-<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>, the object is deleted and the add-on is unloaded.  
<P>
The default implementation returns <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. 
<P>
<HR>
<H3>
<A NAME="RegisterDevices()"></A>RegisterDevices()
, 
<A NAME="UnregisterDevices()"></A>UnregisterDevices()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>RegisterDevices(</TT></B></FONT>input_device_ref **<I><FONT  color=991122 face=HELVETICA>devices</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>UnregisterDevices(</TT></B></FONT>input_device_ref **<I><FONT  color=991122 face=HELVETICA>devices</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT><A HREF="#RegisterDevices()">RegisterDevices()</A></TT></B> tells the Input Server that this object is responsible for the listed <I><FONT  color=991122 face=HELVETICA>devices</I></FONT>.  This means that when a control message is sent back upstream, the message&mdash;which is tagged as being relevant for a specific device, or type of device&mdash;will be forwarded (through the <B><TT><A HREF="#Control()">Control()</A></TT></B> hook) to the responsible BInputServerDevice object(s).  Typically, you initially register your devices as part of the constructor or <B><TT><A HREF="#InitCheck()">InitCheck()</A></TT></B>.  Registration is cumulative&mdash;each <B><TT><A HREF="#RegisterDevices()">RegisterDevices()</A></TT></B> call adds to the object's current list of devices.
<P>
<B><TT><A HREF="#UnregisterDevices()">UnregisterDevices()</A></TT></B> tells the Input Server that this object is no longer responsible for the listed devices.  The devices are automatically unregistered when your object is deleted.
<P>
<B><TT><A HREF="#RegisterDevices()">RegisterDevices()</A></TT></B> invokes <B><TT><A HREF="#Start()">Start()</A></TT></B> for each device in the <I><FONT  color=991122 face=HELVETICA>devices</I></FONT> list; <B><TT><A HREF="#UnregisterDevices()">UnregisterDevices()</A></TT></B> invokes <B><TT><A HREF="#Stop()">Stop()</A></TT></B>.
<P>
For both functions, the <I><FONT  color=991122 face=HELVETICA>devices</I></FONT> list must be <B><TT>NULL</TT></B>-terminated, and the caller retains ownership of the list and its contents.
<P>
Note that the BeOS currently only targets the device types when sending a <B><TT><A HREF="#Control()">Control()</A></TT></B> message.  For example, let's say you've registered two pointing devices and a keyboard:
<P>
<PRE>&nbsp;&nbsp;&nbsp;status_t MyISDevice::InitCheck()
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_device_ref **devices = 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(input_device_ref **)malloc(sizeof(*input_device_ref * 4));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_device_ref mouse1 = {"Mouse 1", B_POINTING_DEVICE, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           (void *)this)};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_device_ref mouse2 = {"Mouse 2", B_POINTING_DEVICE, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           (void *)this)};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_device_ref keyboard = {"Keyboard", B_KEYBOARD_DEVICE, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                             (void *)this)};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devices[0] = &amp;mouse1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devices[1] = &amp;mouse2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devices[2] = &amp;keyboard;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devices[3] = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RegisterDevices(devices);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;}</PRE>
<P>
When the user fiddles with the <B>Mouse</B> preference (more specifically, if an application calls <B><TT><A HREF="InputFunctions.html#set_mouse_speed()">set_mouse_speed()</A></TT></B> et. al.), this object will receive two <B><TT><A HREF="#Control()">Control()</A></TT></B> messages: one targets "Mouse 1", and the other targets "Mouse 2".  That's because the mouse and keyboard functions (as defined by the BeOS and as used by the system preferences) know which type of device to control, but they don't provide a means for more granular identification.  If you need a UI that identifies specific devices, you have to create the UI yourself, and use a <A HREF="InputDevice.html#BInputDevice">BInputDevice</A> object to tune the control messages that are sent back upstream.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  At least one of the devices was registered.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  None of the devices were registered.
<P>
</UL>
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The functions don't let you un/register the same device definition twice, and <B><TT><A HREF="#RegisterDevices()">RegisterDevices()</A></TT></B> won't register a device that doesn't have a name (although the name can be <B><TT>""</TT></B>).  However, the functions don't complain about violations of these conditions as long as at least one definition is properly formed.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="Start()"></A>Start()
, 
<A NAME="Stop()"></A>Stop()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>Start(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>name</I></FONT>, void *<I><FONT  color=991122 face=HELVETICA>cookie</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>Stop(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>name</I></FONT>, void *<I><FONT  color=991122 face=HELVETICA>cookie</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT><A HREF="#Start()">Start()</A></TT></B> is invoked by the Input Server to tell the object that it can begin sending events for the registered device identified by the arguments.  The values of the arguments are taken from the <B><TT><A HREF="InputDefs.html#input_device_ref">input_device_ref</A></TT></B> structure you used to register the device (see <B><TT><A HREF="#RegisterDevices()">RegisterDevices()</A></TT></B>).   If your object needs to resume a thread (spawned in the constructor, in <B><TT><A HREF="#InitCheck()">InitCheck()</A></TT></B>, or here), this is the place to do it.
<P>
<B><TT><A HREF="#Stop()">Stop()</A></TT></B> is invoked to tell the object to stop sending events for the registered device.  The device is not unregistered&mdash;you can still receive <B><TT><A HREF="#Control()">Control()</A></TT></B> messages for the device while it's stopped.  You should pause or kill any threads associated with the device (that were spawned by this object) from here.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The return value (for both of these functions) is ignored.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="StartMonitoringDevice()"></A>StartMonitoringDevice()
, 
<A NAME="StopMonitoringDevice()"></A>StopMonitoringDevice()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>StartMonitoringDevice(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>deviceDir</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>StopMonitoringDevice(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>deviceDir</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These are convenient covers for the Node Monitor's <B><TT><A HREF="../The%20Storage%20Kit/NodeMonitor.html#watch_node()">watch_node()</A></TT></B> and <B><TT><A HREF="../The%20Storage%20Kit/NodeMonitor.html#stop_watching()">stop_watching()</A></TT></B> functions.  You use them to watch for physical devices that are attached and detached, as indicated by changes to subdirectories of the system device directory (<B>/dev</B>).  
<P>
<I><FONT  color=991122 face=HELVETICA>deviceDir</I></FONT> is the name of the device subdirectory that you want to watch.  The "<B>/dev/</B>" root is automatically prepended; for example, if you want to watch for new ps2 mice, you would pass "<B>input/mouse/ps2</B>" as the <I><FONT  color=991122 face=HELVETICA>deviceDir</I></FONT> name.  The Node Monitor is told to look for changes to the directory (<B><TT>B_WATCH_DIRECTORY</TT></B> opcode).  When an entry is added or removed, this object receives a <B><TT><A HREF="../Messages/GeneralMessages.html#B_NODE_MONITOR">B_NODE_MONITOR</A></TT></B> message delivered to its <B><TT><A HREF="#Control()">Control()</A></TT></B> function.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  Success.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  Unspecified failure.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_NOT_A_DIRECTORY">B_NOT_A_DIRECTORY</A></TT></B>.  You're trying to monitor a node that isn't a directory.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_VALUE">B_BAD_VALUE</A></TT></B>.  <I><FONT  color=991122 face=HELVETICA>deviceDir</I></FONT> not found.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="SystemShuttingDown()"></A>SystemShuttingDown()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>SystemShuttingDown</TT></B></FONT><B><TT><FONT  color=000022 size=+1>(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Tells the object that the Input Server is in the process of shutting down.  Unless something interrupts the shutdown, this notification will be followed by a<B><TT> <A HREF="#Stop()">Stop()</A></TT></B> and <B><TT>delete</TT></B>, thus you don't have to do much from this function (other than note that the end is near).  
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The return value is ignored.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>UnregisterDevices  see  <A HREF="#RegisterDevices()">RegisterDevices()</A></H3>
<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Input Server Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Input%20Server%20Master%20Index.html"><FONT face=HELVETICA>The Input Server Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

