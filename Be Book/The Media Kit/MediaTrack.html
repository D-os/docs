<HTML><HEAD><TITLE>The Media Kit: BMediaTrack</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Media Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Media%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Media Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="BMediaTrack"></A>BMediaTrack
</H1>
<P>
Derived from:  none
<P>
Declared in:  <A HREF="/boot/develop/headers/be/media/MediaTrack.h">be/media/MediaTrack.h</A>
<P>
Library:  libmedia.so
<P>
Allocation:  BMediaFile::TrackAt()<B><TT>
<P>
</TT></B><H6><A HREF="MediaTrack.summary.html"><i>Summary</i></A></H6>
<P>
The BMediaTrack class provides access to a particular track in a media file.  It's always instantiated using the <B><TT><A HREF="MediaFile.html#TrackAt()">BMediaFile::TrackAt()</A></TT></B> or <B><TT><A HREF="MediaFile.html#CreateTrack()">BMediaFile::CreateTrack()</A></TT></B> function.
<P>
The BMediaTrack constructor searches for a codec that can handle the encoded data in the track; once that's been done, the track is ready to be used.
<P>
If you opened the file for writing, you can write data into the track.  If you specified the <B><TT>B_MEDIA_FILE_REPLACE_MODE</TT></B> flag when constructing the <A HREF="MediaFile.html#BMediaFile">BMediaFile</A>, you can both read and write from the file.  If no decoder is available for the track, you can still use <B><TT><A HREF="#ReadChunk()">ReadChunk()</A></TT></B> to access the encoded data directly.
<P>
After instantiating the <A HREF="#BMediaTrack">BMediaTrack</A>, using the <A HREF="MediaFile.html#BMediaFile">BMediaFile</A> functions for doing so, you should call <B><TT><A HREF="#InitCheck()">InitCheck()</A></TT></B> to be sure the track is valid.  You can then use <B><TT><A HREF="#ReadFrames()">ReadFrames()</A></TT></B> and <B><TT><A HREF="#WriteFrames()">WriteFrames()</A></TT></B> to read and write data to the file, as appropriate.  For video data, you should work one frame at a time.
<P>
You can also seek particular times or frames using <B><TT><A HREF="#SeekToTime()">SeekToTime()</A></TT></B> or <B><TT><A HREF="#SeekToFrame()">SeekToFrame()</A></TT></B>.
<P>
For an example of how to use BMediaTrack to read and write tracks in media files, see <a href="encode_sample.html#Reading%20and%20Writing%20Media%20Files">"Reading and Writing Media Files"</a>
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
As a general rule, you can't use wildcards in any structures used by BMediaTrack functions.  You tell BMediaTrack what format you have, and BMediaTrack will simply tell you whether or not that format is supported.
<P>
</UL>
<P>
<HR>
<H2>
<A NAME="Destructor"></A><FONT SIZE=6>D</FONT>estructor
</H2>
<P>
<HR>
<H3>
<A NAME="~BMediaTrack()"></A>~BMediaTrack()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual <B><TT><FONT  color=000022 size=+1>~BMediaTrack(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
Destructor.  You shouldn't delete a BMediaTrack directly; instead, use <B><TT><A HREF="MediaFile.html#ReleaseTrack()">BMediaFile::ReleaseTrack()</A></TT></B> or <B><TT><A HREF="MediaFile.html#ReleaseAllTracks()">BMediaFile::ReleaseAllTracks()</A></TT></B>, or let <A HREF="MediaFile.html#BMediaFile">BMediaFile</A> destroy the track objects when it's deleted.
<P>
<HR>
<H2>
<A NAME="Member%20Functions"></A><FONT SIZE=6>M</FONT>ember <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="AddCopyright()"></A>AddCopyright()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>AddCopyright(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>data</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Sets the track's copyright notice to the text specified by <I><FONT  color=991122 face=HELVETICA>data</I></FONT>, replacing the existing copyright notice if one exists.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The BMediaTrack class doesn't automatically perform any locking to prevent multiple writes to the track from occurring at the same time.  If you have multiple threads writing into the same <A HREF="#BMediaTrack">BMediaTrack</A>, you must use a locking mechanism (such as a semaphore) to keep writes from overlapping.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The copyright was set.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#EPERM">EPERM</A></TT></B>.  The file isn't opened for writing.
<P>
<LI>Other errors, depending on the codec.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="AddTrackInfo()"></A>AddTrackInfo()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>AddTrackInfo(</TT></B></FONT>uint32 <I><FONT  color=991122 face=HELVETICA>code</I></FONT>, const void *<I><FONT  color=991122 face=HELVETICA>data</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Adds an informational record of the specified <I><FONT  color=991122 face=HELVETICA>type</I></FONT> to the track.  The record is specified by the <I><FONT  color=991122 face=HELVETICA>data</I></FONT> pointer, and is <I><FONT  color=991122 face=HELVETICA>size</I></FONT> bytes long.  <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> contains flags that modify the operation (none are defined at this time).
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The BMediaTrack class doesn't automatically perform any locking to prevent multiple writes to the track from occurring at the same time.  If you have multiple threads writing into the same <A HREF="#BMediaTrack">BMediaTrack</A>, you must use a locking mechanism (such as a semaphore) to keep writes from overlapping.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The format was successfully returned.
<P>
<UL>
<LI>Other errors.  The error returned depends on the codec interpreting the data.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="CountFrames()"></A>CountFrames()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
int64 <B><TT><FONT  color=000022 size=+1>CountFrames(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns the total number of frames in the track.
<P>
<HR>
<H3>
<A NAME="CurrentFrame()"></A>CurrentFrame()
, 
<A NAME="const"></A>const
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
int64 <B><TT><FONT  color=000022 size=+1>CurrentFrame(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns the current frame in the track (the frame that will be read next by <B><TT>GetNextFrames()</TT></B>.
<P>
<HR>
<H3>
<A NAME="CurrentTime()"></A>CurrentTime()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
bigtime_t <B><TT><FONT  color=000022 size=+1>CurrentTime(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns the current position within the track, expressed in microseconds since the start of the track.
<P>
<HR>
<H3>
<A NAME="DecodedFormat()"></A>DecodedFormat()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>DecodedFormat(</TT></B></FONT>media_format *<I><FONT  color=991122 face=HELVETICA>ioFormat</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Negotiates the format that the codec will output when decoding the track's data.  Pass in <I><FONT  color=991122 face=HELVETICA>ioFormat</I></FONT> the format that you want (with wildcards as applicable).  The codec will find and return in <I><FONT  color=991122 face=HELVETICA>ioFormat</I></FONT> its best matching format; this format will then be used when outputting decoded data via <B><TT><A HREF="#ReadFrames()">ReadFrames()</A></TT></B>.
<P>
The format is typically of a <B><TT>B_MEDIA_RAW_AUDIO</TT></B> or <B><TT>B_MEDIA_RAW_VIDEO</TT></B> flavor.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The format was successfully negotiated and returned.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  The BMediaTrack wasn't properly initialized, or there's no codec for the track's data.
<P>
<LI>Other errors.  The error returned depends on the codec interpreting the data.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="Duration()"></A>Duration()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
bigtime_t <B><TT><FONT  color=000022 size=+1>Duration(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns the total duration of the track, in microseconds.
<P>
<HR>
<H3>
<A NAME="EncodedFormat()"></A>EncodedFormat()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>EncodedFormat(</TT></B></FONT>media_format *<I><FONT  color=991122 face=HELVETICA>outFormat</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns the "native" encoded format of the track's data.  This is the format of the data returned by <B><TT><A HREF="#ReadChunk()">ReadChunk()</A></TT></B>.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The format was successfully returned.
<P>
<UL>
<LI>Other errors.  The error returned depends on the codec interpreting the data.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="FindKeyFrameForTime()"></A>FindKeyFrameForTime()
, 
<A NAME="FindKeyFrameForFrame()"></A>FindKeyFrameForFrame()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>FindKeyFrameForTime(</TT></B></FONT>bigtime_t *<I><FONT  color=991122 face=HELVETICA>inOutTime</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>FindKeyFrameForFrame(</TT></B></FONT>int64 *<I><FONT  color=991122 face=HELVETICA>inOutFrame</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
FindKeyFrameForTime() accepts in inOutTime a time, and returns in inOutTime the time at which the closest key frame to that time begins.  Likewise, FindKeyFrameForFrame() returns the closest key frame number to the specified frame.
<P>
The flags argument lets you indicate whether to seek forward or backward for the key frame.
<P>
If you want to find the nearest key frame before the indicated frame or time, specify <B><TT>B_MEDIA_SEEK_CLOSEST_BACKWARD</TT></B> in <I><FONT  color=991122 face=HELVETICA>flags</I></FONT>.  If you want to find the nearest key frame after the indicated frame or time, specify <B><TT>B_MEDIA_SEEK_CLOSEST_FORWARD</TT></B>.
<P>
<HR>
<H3>
<A NAME="Flush()"></A>Flush()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>Flush(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
Flushes all buffered encoded data to disk; you should call this function after you've finished writing the last frame to the track.  This ensures that everything's flushed at the right offset into the file.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The buffers were flushed.
<P>
<UL>
<LI>Other errors, depending on the codec.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="GetCodecInfo()"></A>GetCodecInfo()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>GetCodecInfo(</TT></B></FONT>media_codec_info *<I><FONT  color=991122 face=HELVETICA>codecInfo</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns information about the codec being used to read or write the track's data.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The codec info was returned.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_TYPE">B_BAD_TYPE</A></TT></B>.  There's no valid codec in use by the track.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="GetEncodeParameters()"></A>GetEncodeParameters()
, 
<A NAME="SetEncodeParameters()"></A>SetEncodeParameters()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>GetEncodeParameters(</TT></B></FONT>encode_parameters *<I><FONT  color=991122 face=HELVETICA>parameters</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SetEncodeParameters(</TT></B></FONT>encode_parameters *<I><FONT  color=991122 face=HELVETICA>parameters</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>GetEncodeParameters()</TT></B> returns the encode_parameters being used when encoding data on the track.
<P>
<B><TT>SetEncodeParameters()</TT></B> changes the encode_parameters being used while encoding data.
<P>
<HR>
<H3>GetParameterValue() see <A HREF="#SetParameterValue()">SetParameterValue()</A></H3>
<P>
<HR>
<H3>
<A NAME="GetParameterView()"></A>GetParameterView()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<A HREF="../Release%20Notes/InterfaceKit.html#BView">BView</A> *<B><TT><FONT  color=000022 size=+1>GetParameterView(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns a <A HREF="../Release%20Notes/InterfaceKit.html#BView">BView</A> containing controls for adjusting the codec's and track's parameters.  Returns <B><TT>NULL</TT></B> if there isn't a view available.
<P>
<HR>
<H3>GetQuality() see <A HREF="#SetQuality()">SetQuality()</A></H3>
<P>
<HR>
<H3>
<A NAME="InitCheck()"></A>InitCheck()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>InitCheck(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns a status code indicating whether or not the track was successfully and completely instantiated.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The track was constructed properly.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_VALUE">B_BAD_VALUE</A></TT></B>.  An error occurred setting up the track.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="ReadChunk()"></A>ReadChunk()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>ReadChunk(</TT></B></FONT>char **<I><FONT  color=991122 face=HELVETICA>outBuffer</I></FONT>, int32 *<I><FONT  color=991122 face=HELVETICA>ioSize</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_header *<I><FONT  color=991122 face=HELVETICA>header</I></FONT> = <FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns in <I><FONT  color=991122 face=HELVETICA>outBuffer</I></FONT> a pointer to the next <I><FONT  color=991122 face=HELVETICA>ioSize</I></FONT> bytes of the media track; the actual number of bytes returned is returned in <I><FONT  color=991122 face=HELVETICA>ioSize</I></FONT>; this may be different if the end of the track is reached.  The <I><FONT  color=991122 face=HELVETICA>header</I></FONT> is set to describe the returned buffer.
<P>
The data returned by this function isn't decoded.  Typically you'll only use this function if there's no codec available to decode the media data.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The format was successfully negotiated and returned.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  The BMediaTrack wasn't properly initialized, or there's no codec for the track's data.
<P>
<LI>Other errors.  The error returned depends on the codec interpreting the data.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="ReadFrames()"></A>ReadFrames()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>ReadFrames(</TT></B></FONT>void *<I><FONT  color=991122 face=HELVETICA>outBuffer</I></FONT>, int64 *<I><FONT  color=991122 face=HELVETICA>outFrameCount</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_header *<I><FONT  color=991122 face=HELVETICA>outHeader</I></FONT> = <FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>ReadFrames(</TT></B></FONT>void *<I><FONT  color=991122 face=HELVETICA>outBuffer</I></FONT>, int64 *<I><FONT  color=991122 face=HELVETICA>outFrameCount</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_header *<I><FONT  color=991122 face=HELVETICA>outHeader</I></FONT> = <FONT  face=HELVETICA>NULL</FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_decode_info *<I><FONT  color=991122 face=HELVETICA>info</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Fills the buffer pointed to by <I><FONT  color=991122 face=HELVETICA>outBuffer</I></FONT> with the next frames or samples from the track, starting at the current position.  For video tracks, the next frame of video is decoded and stored into the output buffer.  For audio tracks, the buffer is filled with the number of frames negotiated using <B><TT><A HREF="#DecodedFormat()">DecodedFormat()</A></TT></B>.  If the end of the track is reached before the buffer is filled, a partial buffer will be returned.
<P>
On return, <I><FONT  color=991122 face=HELVETICA>outFrameCount</I></FONT> indicates the number of frames returned, and <I><FONT  color=991122 face=HELVETICA>outHeader</I></FONT>, if you specified a non-<B><TT>NULL</TT></B> value, contains the header of the buffer containing the frame or frames.  You can obtain useful information (such as the media start time for the buffer) from the header.
<P>
The second form of this function lets you provide a media_decode_info structure to provide additional information to the decoder, such as how much time it's allowed to use to decode the data and format- and codec-specific information.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The frames have been returned.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#EPERM">EPERM</A></TT></B>.  The file wasn't opened for reading.
<P>
<LI>Other errors.  The error returned depends on the codec interpreting the data.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="ReplaceFrames()"></A>ReplaceFrames()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>ReplaceFrames(</TT></B></FONT>void *<I><FONT  color=991122 face=HELVETICA>inBuffer</I></FONT>, int64 *<I><FONT  color=991122 face=HELVETICA>ioFrameCount</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_header *<I><FONT  color=991122 face=HELVETICA>header</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Replaces the number of frames specified in <I><FONT  color=991122 face=HELVETICA>ioFrameCount</I></FONT> in the track.  <I><FONT  color=991122 face=HELVETICA>inBuffer</I></FONT> points to the source buffer for the new frames.
<P>
<HR>
<H3>
<A NAME="SeekToFrame()"></A>SeekToFrame()
, 
<A NAME="SeekToTime()"></A>SeekToTime()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SeekToFrame(</TT></B></FONT>int64 *<I><FONT  color=991122 face=HELVETICA>ioFrame</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SeekToTime(</TT></B></FONT>bigtime_t *<I><FONT  color=991122 face=HELVETICA>ioTime</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Seeks to the specified position in the track.  <B><TT>SeekToFrame()</TT></B> accepts a destination position as a frame number, and <B><TT>SeekToTime()</TT></B> accepts a destination position as time in microseconds.  They each return (in <I><FONT  color=991122 face=HELVETICA>ioFrame</I></FONT> or in <I><FONT  color=991122 face=HELVETICA>ioTime</I></FONT>) the position to which they actually moved.
<P>
For example, if a video codec is only capable of seeking to key frames, the returned <I><FONT  color=991122 face=HELVETICA>ioFrame</I></FONT> might be different than the one specified on input.
<P>
If you want to seek explicitly to the nearest key frame before the current frame, specify <B><TT>B_MEDIA_SEEK_CLOSEST_BACKWARD</TT></B> in <I><FONT  color=991122 face=HELVETICA>flags</I></FONT>.  If you want to find the nearest key frame after the current time, specify <B><TT>B_MEDIA_SEEK_CLOSEST_FORWARD</TT></B>.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The format was successfully returned.
<P>
<UL>
<LI>Other errors.  The error returned depends on the codec interpreting the data.
<P>
</UL>
<P>
<HR>
<H3>SetEncodeParameters() see <A HREF="#GetEncodeParameters()">GetEncodeParameters()</A></H3>
<P>
<HR>
<H3>
<A NAME="SetParameterValue()"></A>SetParameterValue()
, 
<A NAME="GetParameterValue()"></A>GetParameterValue()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SetParameterValue(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>id</I></FONT>, const void *<I><FONT  color=991122 face=HELVETICA>value</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>


<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>GetParameterValue(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>id</I></FONT>, const void *<I><FONT  color=991122 face=HELVETICA>value</I></FONT>, size_t *<I><FONT  color=991122 face=HELVETICA>size</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>SetParameterValue()</TT></B> sets the value of the parameter specified by <I><FONT  color=991122 face=HELVETICA>id</I></FONT> to the data pointed to by <I><FONT  color=991122 face=HELVETICA>value</I></FONT>; this data is <I><FONT  color=991122 face=HELVETICA>size</I></FONT> bytes long.
<P>
<B><TT>GetParameterValue()</TT></B> returns in <I><FONT  color=991122 face=HELVETICA>value</I></FONT> the value of the specified parameter, and the size of the value in bytes in the <I><FONT  color=991122 face=HELVETICA>size</I></FONT> argument.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  No error.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#EPERM">EPERM</A></TT></B>.  The codec ins't configurable.
<P>
<LI>Other errors, depending on the codec.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="SetQuality()"></A>SetQuality()
, 
<A NAME="GetQuality()"></A>GetQuality()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SetQuality(</TT></B></FONT>float <I><FONT  color=991122 face=HELVETICA>quality</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>GetQuality(</TT></B></FONT>float *<I><FONT  color=991122 face=HELVETICA>quality</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions set and return the codec's quality setting (where 1.0 means maximum quality).
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  No error.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  The codec doesn't support a quality setting.
<P>
<LI>Other errors, depending on the codec.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="Web()"></A>Web()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<A HREF="ParameterWeb.html#BParameterWeb">BParameterWeb</A> *<B><TT><FONT  color=000022 size=+1>Web(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns a <A HREF="ParameterWeb.html#BParameterWeb">BParameterWeb</A> that can be used for configuring the track and codec.  Returns <B><TT>NULL</TT></B> if the codec doesn't support user configuration.
<P>
<HR>
<H3>
<A NAME="WriteChunk()"></A>WriteChunk()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>WriteChunk(</TT></B></FONT>void *<I><FONT  color=991122 face=HELVETICA>data</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Writes the data pointed to by <I><FONT  color=991122 face=HELVETICA>data</I></FONT>, which contains <I><FONT  color=991122 face=HELVETICA>size</I></FONT> bytes of data, into the track.  Specify <B><TT>B_MEDIA_KEY_FRAME</TT></B> for <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> if the frame is a key frame.  It's assumed that the data is already encoded.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The BMediaTrack class doesn't automatically perform any locking to prevent multiple writes to the track from occurring at the same time.  If you have multiple threads writing into the same <A HREF="#BMediaTrack">BMediaTrack</A>, you must use a locking mechanism (such as a semaphore) to keep writes from overlapping.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
In general, you should only use <B><TT>WriteChunk()</TT></B> if you're reading compressed data from one file and copying it into another, without trying to interpret the data.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The frames have been written.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#EPERM">EPERM</A></TT></B>.  The file wasn't opened for writing.
<P>
<LI>Other errors.  The error returned depends on the codec writing the data.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="WriteFrames()"></A>WriteFrames()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>WriteFrames(</TT></B></FONT>void *<I><FONT  color=991122 face=HELVETICA>data</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>numFrames</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Writes the data pointed to by <I><FONT  color=991122 face=HELVETICA>data</I></FONT>, which contains <I><FONT  color=991122 face=HELVETICA>numFrame</I></FONT> frames, into the track.  Specify <B><TT>B_MEDIA_KEY_FRAME</TT></B> for <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> if the frame is a key frame.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The BMediaTrack class doesn't automatically perform any locking to prevent multiple writes to the track from occurring at the same time.  If you have multiple threads writing into the same <A HREF="#BMediaTrack">BMediaTrack</A>, you must use a locking mechanism (such as a semaphore) to keep writes from overlapping.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
You always have to select an encoder before writing frames into a media track, even if the data is raw audio or video.  When writing raw audio or video data into a <A HREF="#BMediaTrack">BMediaTrack</A>, you need to use the raw encoder.  Even though this doesn't transform the data, it sets up internal data that's necessary for the file to be played back properly after it's created.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. The frames have been written.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#EPERM">EPERM</A></TT></B>.  The file wasn't opened for writing.
<P>
<LI>Other errors.  The error returned depends on the codec writing the data.
<P>
</UL>
<P>
<HR>
<H2>
<A NAME="Constants"></A><FONT SIZE=6>C</FONT>onstants
</H2>
<P>
<HR>
<H3>
<A NAME="media_seek_type"></A>media_seek_type
</H3>
<P>
Declared in:  <A HREF="/boot/develop/headers/be/media/MediaTrack.h">be/media/MediaTrack.h</A>
<P>
<TABLE BORDER cellpadding=4>
<TH><B>Constant</B></TH>
<TH>Description</TH>
<TR>
<TD><B><TT>B_MEDIA_SEEK_CLOSEST_FORWARD</TT></B></TD>
<TD>Seek to the nearest key frame after the current position in the track.</TD>
<TR>
<TD><B><TT>B_MEDIA_SEEK_CLOSEST_BACKWARD</TT></B></TD>
<TD>Seek to the nearest key frame before the current position in the track.</TD>
<TR>
<TD><B><TT>B_MEDIA_SEEK_DIRECTION_MASK</TT></B></TD>
<TD>Mask the seek flags with this value to obtain the seek direction.</TD>
</TABLE>
<P>
These flags, used when calling <B><TT><A HREF="#SeekToTime()">SeekToTime()</A></TT></B> and <B><TT><A HREF="#SeekToFrame()">SeekToFrame()</A></TT></B>, let you look for the nearest key frame after or before the current position in the file, without having to guess the time or frame number at which it's located.
<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Media Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Media%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Media Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

