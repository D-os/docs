<HTML><HEAD><TITLE>The Interface Kit: BTextView</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Interface Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Interface%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Interface Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="BTextView"></A>BTextView
</H1>
<P>
Derived from:  public <A HREF="View.html#BView">BView</A>
<P>
Declared in:  <A HREF="/boot/develop/headers/be/interface/TextView.h">be/interface/TextView.h</A>
<P>
Library:  libbe.so
<P>
<H6><A HREF="TextView.summary.html"><i>Summary</i></A></H6>
<P>
A BTextView object displays text on-screen, and provides these text manipulating features:
<P>
<LI>It lets the user enter, select, and edit text from the keyboard and mouse.
<P>
<LI>It supports standard Cut, Copy, Paste, Delete, and Select All editing commands
<P>
<LI>It provides an Undo mechanism.
<P>
</UL>
<P>
By default, a BTextView displays all its text in a single font and color.  The <B><TT><A HREF="#SetStylable()">SetStylable()</A></TT></B> turns on support for multiple character formats.
<P>
Paragraph formats&mdash;such as alignment and tab widths&mdash;are uniform for all text the BTextView displays.  These properties can be set, but the setting always applies to the entire text.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The BTextView class isn't multi-thread safe; don't issue BTextView calls on a BTextView object from multiple threads, or you may see unusual behavior; in general, only the thread that created the BTextView should issue calls on it.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<A NAME="13948:%20head2:%20Offsets"></A>
<P>
<HR>
<H3>
<A NAME="Offsets"></A>Offsets
</H3>
<P>
The BTextView locates particular characters in its text buffer by offsets from the beginning of the data.  The offsets count bytes, not characters, and begin at 0.  A single character is identified by the offset of the first byte of the character.  A group of characters&mdash;the current selection, for example&mdash;is delimited by the offsets that bound its first and last characters; all characters beginning with the first offset up to, but not including, the last offset are part of the group.
<P>
For example, suppose the BTextView contains the following text in Unicode UTF-8 encoding,
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/BULLET_GOES_HERE.gif">
					<TD><FONT FACE="helvetica">
The BeOS(TM)  is . . .
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
and "BeOS(TM) " is selected.  <B><TT><A HREF="#GetSelection()">GetSelection()</A></TT></B> would return 4 and 11 as the offsets that enclose the selection.  The character 'B' occupies the fourth byte of text and the space following the trademark symbol is the eleventh byte of text.  The characters in "BeOS" are each encoded in one byte, but '(TM) ' takes up three bytes in UTF-8.  Thus the five-character selection occupies 7 bytes (and offsets) of text.
<P>
Although offsets count bytes, they can also be thought of as designating positions between characters.  The position at the beginning of the text is offset 0, the position between the space and the 'B' in the example above is at offset 4, the position between the '(TM) ' and the space is at offset 11, and so on.  Thus, even if no characters are selected, the insertion point (and location of the caret) can still be designated by an offset.
<P>
Most BTextView functions expect the offsets they're passed to mark positions between characters; the results are not defined if a character-internal offset is specified instead.
<P>
<HR>
<H3>
<A NAME="Graphics%20Primitives"></A>Graphics Primitives
</H3>
<P>
The BTextView's mechanism for formatting and drawing text uses the graphics primitives it inherits from the <A HREF="View.html#BView">BView</A> class.  However, it largely presents its own API for determining the appearance of the text it draws.  You should not attempt to affect the BTextView by calling primitive <A HREF="View.html#BView">BView</A> functions like <B><TT>MovePen()</TT></B>, <B><TT><A HREF="Slider.html#SetFont()">SetFont()</A></TT></B>, or <B><TT><A HREF="ViewGraphicsState.html#SetHighColor()">SetHighColor()</A></TT></B>.  Instead, use BTextView functions like <B><TT><A HREF="#SetFontAndColor()">SetFontAndColor()</A></TT></B> and let the object take care of formatting and drawing the text.
<P>
The one inherited function that can influence the BTextView is <B><TT><A HREF="ViewGraphicsState.html#SetViewColor()">SetViewColor()</A></TT></B>.  This function determines the background against which the text is drawn and the color that is used in antialiasing calculations.
<P>
<HR>
<H3>
<A NAME="Resizing"></A>Resizing
</H3>
<P>
A BTextView can be made to resize itself to exactly fit the text that the user enters.  This is sometimes appropriate for small one-line text fields.  See the <B><TT><A HREF="#MakeResizable()">MakeResizable()</A></TT></B> function.
<P>
<HR>
<H3>
<A NAME="BTextView%20and%20BScrollBars"></A>BTextView and BScrollBars
</H3>
<P>
If you add scrollbars to control the position of the BTextView's document&mdash;this includes using a BTextView as the target of a <A HREF="ScrollView.html#BScrollView">BScrollView</A>&mdash;the BTextView will update the scrollbars for you.  (Note that it doesn't <I>own</I> the scrollbars; you still have to delete them yourself if you created them.)  When the BTextView is first displayed and thereafter resized, the scrollbars' ranges, step sizes, and scroller positions and proportions are automatically reset to reflect the BTextView object's bounds.  Attempts to set these parameters directly (through <B><TT><A HREF="ScrollBar.html#SetRange()">BScrollBar::SetRange()</A></TT></B> etc.), are <I>worse</I> than ignored; they're actually applied, and then (at some point) the BTextView will notice the change in the scrollbars and reset them.  Looks like flicker to me.
<P>
<A NAME="11090:%20head2:%20Shortcuts%20and%20Menu%20Items"></A>
<P>
<HR>
<H3>
<A NAME="Shortcuts%20and%20Menu%20Items"></A>Shortcuts and Menu Items
</H3>
<P>
When it's the focus view for its window, a BTextView automatically responds to a set of keyboard shortcuts:
<P>
<UL>
<LI>Command+<I>x</I> cuts text and copies it to the clipboard
<P>
<LI>Command+<I>c</I> copies text to the clipboard without cutting it
<P>
<LI>Command+<I>v</I> pastes text taken from the clipboard
<P>
<LI>Command+<I>a</I> selects all of the text in the BTextView
<P>
<LI>Command+z undoes the previous action
<P>
</UL>
<P>
If you create menu items for these actions, you have to assign the <A HREF="MenuItem.html#BMenuItem">BMenuItem</A> shortcuts and command constants yourself:
<P>
<TABLE BORDER cellpadding=4>
<TH>Action</TH>
<TH>Constant</TH>
<TH>Shortcut</TH>
<TR>
<TD>Cut</TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_CUT">B_CUT</A></TT></B></TD>
<TD>Command+<I>x</TD>
<TR>
<TD></I>Copy</TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_COPY">B_COPY</A></TT></B></TD>
<TD>Command+<I>c</TD>
<TR>
<TD></I>Paste</TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_PASTE">B_PASTE</A></TT></B></TD>
<TD>Command+<I>v</TD>
<TR>
<TD></I>Select all</TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_SELECT_ALL">B_SELECT_ALL</A></TT></B></TD>
<TD>Command+<I>a</TD>
<TR>
<TD></I>Undo</TD>
<TD><B><TT>B_UNDO</TT></B></TD>
<TD>Command+z</TD>
</TABLE>
 
<P>
<HR>
<H2>
<A NAME="Hook%20Functions"></A><FONT SIZE=6>H</FONT>ook <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<B><TT><A HREF="#AcceptsDrop()">AcceptsDrop()</A></TT></B>&nbsp;&nbsp;&nbsp;
<br>
Determines whether a <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> that's dragged to the BTextView has data that the object can insert; can be reimplemented to prevent the BTextView from accepting dropped text or to allow it to accept data it currently doesn't understand.
<P>
<B><TT><A HREF="#AcceptsPaste()">AcceptsPaste()</A></TT></B>&nbsp;&nbsp;&nbsp;
<br>
Determines whether the BTextView can take data from the clipboard; can be reimplemented to prevent text from being pasted or to make the BTextView accept data it currently doesn't understand.
<P>
<B><TT><A HREF="#CanEndLine()">CanEndLine()</A></TT></B>&nbsp;&nbsp;&nbsp;
<br>
Determines where a line can end; can be overridden to follow a different criterion than the default.
<P>
<B><TT><A HREF="#DeleteText()">DeleteText()</A></TT></B>&nbsp;&nbsp;&nbsp;
<br>
Deletes characters from the text; can be augmented to preview the deletions and accept or reject them before the text is removed from the display.  This function is called to carry out all deletions.
<P>
<B><TT><A HREF="#FindWord()">FindWord()</A></TT></B>&nbsp;&nbsp;&nbsp;
<br>
Finds the boundaries of a word when the user double-clicks; can be overridden to redefine what a word is or to provide a definition of a word for other languages.
<P>
<B><TT><A HREF="#GetDragParameters()">GetDragParameters()</A></TT></B>&nbsp;&nbsp;&nbsp;
<br>
Invoked when a drag is initiated.  You can override the function to supply parameters, such as a bitmap, that are used during the drag. 
<P>
<B><TT><A HREF="#InsertText()">InsertText()</A></TT></B>&nbsp;&nbsp;&nbsp;
<br>
Inserts new characters into the text; can be augmented to preview the characters the user types, pastes, or drops and accept or reject them before they're added to the display.  All insertions pass through this function.
<P>
<B><TT><A HREF="#Undo()">Undo()</A></TT></B>&nbsp;&nbsp;&nbsp;
<br>
Invoked when the object gets a <B><TT>B_UNDO</TT></B> message. You can augment or replace the default undo response by implementing this function.
<P>
<HR>
<H2>
<A NAME="Constructor%20and%20Destructor"></A><FONT SIZE=6>C</FONT>onstructor and <FONT SIZE=6>D</FONT>estructor
</H2>
<P>
<HR>
<H3>
<A NAME="BTextView()"></A>BTextView()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>BTextView(</TT></B></FONT><A HREF="Rect.html#BRect">BRect</A> <I><FONT  color=991122 face=HELVETICA>frame</I></FONT>, const char *<I><FONT  color=991122 face=HELVETICA>name</I></FONT>, <A HREF="Rect.html#BRect">BRect</A>&nbsp;<I><FONT  color=991122 face=HELVETICA>textRect</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 <I><FONT  color=991122 face=HELVETICA>resizingMode</I></FONT>, uint32&nbsp;<I><FONT  color=991122 face=HELVETICA>flags</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
<B><TT><FONT  color=000022 size=+1>BTextView(</TT></B></FONT><A HREF="Rect.html#BRect">BRect</A> <I><FONT  color=991122 face=HELVETICA>frame</I></FONT>, const char *<I><FONT  color=991122 face=HELVETICA>name</I></FONT>, <A HREF="Rect.html#BRect">BRect</A>&nbsp;<I><FONT  color=991122 face=HELVETICA>textRect</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;<A HREF="Font.html#BFont">BFont</A>&nbsp;*<I><FONT  color=991122 face=HELVETICA>font</I></FONT>, const&nbsp;rgb_color&nbsp;*<I><FONT  color=991122 face=HELVETICA>color</I></FONT>, 
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 <I><FONT  color=991122 face=HELVETICA>resizingMode</I></FONT>, uint32&nbsp;<I><FONT  color=991122 face=HELVETICA>flags</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
<B><TT><FONT  color=000022 size=+1>BTextView(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>archive</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Initializes the BTextView to the <I><FONT  color=991122 face=HELVETICA>frame</I></FONT> rectangle, stated in its eventual parent's coordinate system, assigns it an identifying <I><FONT  color=991122 face=HELVETICA>name</I></FONT>, sets its resizing behavior to <I><FONT  color=991122 face=HELVETICA>resizingMode</I></FONT> and its drawing behavior with <I><FONT  color=991122 face=HELVETICA>flags</I></FONT>.  These four arguments&mdash;<I><FONT  color=991122 face=HELVETICA>frame</I></FONT>, <I><FONT  color=991122 face=HELVETICA>name</I></FONT>, <I><FONT  color=991122 face=HELVETICA>resizingMode</I></FONT>, and <I><FONT  color=991122 face=HELVETICA>flags</I></FONT>&mdash;are identical to those declared for the <A HREF="View.html#BView">BView</A> class and are passed to the <A HREF="View.html#BView">BView</A> constructor.  The <I><FONT  color=991122 face=HELVETICA>frame</I></FONT>, <I><FONT  color=991122 face=HELVETICA>name</I></FONT>, and <I><FONT  color=991122 face=HELVETICA>resizingMode</I></FONT> arguments are passed to the <A HREF="View.html#BView">BView</A> class unchanged, but two flags are added to the <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> argument&mdash;<B><TT><A HREF="ViewGeneral.html#B_FRAME_EVENTS">B_FRAME_EVENTS</A></TT></B>, so that the BTextView can reformat the text when it's resized, and <B><TT><A HREF="ViewGeneral.html#B_PULSE_NEEDED">B_PULSE_NEEDED</A></TT></B>, so that the caret marking the insertion point can "blink" in time with <B><TT><A HREF="misc.html#B_PULSE">B_PULSE</A></TT></B> messages.  Later, <B><TT><A HREF="#AttachedToWindow()">AttachedToWindow()</A></TT></B> will set the window's pulse rate to 500,000 microseconds.
<P>
The text rectangle, <I><FONT  color=991122 face=HELVETICA>textRect</I></FONT>, is stated in the BTextView's coordinate system.  It determines where text in placed within the view's bounds rectangle:
<P>
<UL>
<LI>The first line of text is placed at the top of the text rectangle.  As additional lines of text are entered into the view, the text grows downward and may actually extend beyond the bottom of the rectangle.
<P>
<LI>The left and right sides of the text rectangle determine where lines of text are placed within the view.  Lines can be aligned to either side of the rectangle, or they can be centered between the two sides.  See the <B><TT><A HREF="#SetAlignment()">SetAlignment()</A></TT></B> function.
<P>
<LI>When lines wrap on word boundaries, the width of the text rectangle determines the maximum length of a line; each line of text can be as long as the rectangle is wide.  When word wrapping isn't turned on, lines can extend beyond the boundaries of the text rectangle.  See the <B><TT><A HREF="#SetWordWrap()">SetWordWrap()</A></TT></B> function.
<P>
</UL>
<P>
The bottom of the text rectangle is ignored; it doesn't limit the amount of text the view can contain.  The text can be limited by the number of characters, but not by the number of lines.
<P>
If a default <I><FONT  color=991122 face=HELVETICA>font</I></FONT> is provided, the BTextView will display its text in that font, unless another font is later set.  Similarly, if a default <I><FONT  color=991122 face=HELVETICA>color</I></FONT> is specified, the text will be displayed in that color, unless the color is subsequently changed.  If the <I><FONT  color=991122 face=HELVETICA>font</I></FONT> is <B><TT>NULL</TT></B> or not specified, the BTextView uses the system plain font, <B><TT><A HREF="Font.html#be_plain_font">be_plain_font</A></TT></B>.  If the <I><FONT  color=991122 face=HELVETICA>color</I></FONT> pointer is <B><TT>NULL</TT></B> or not specified, the text is drawn in black.
<P>
The constructor establishes the following default properties for a new BTextView:
<P>
<UL>
<LI>The text is selectable and editable.  (See <B><TT><A HREF="#MakeSelectable()">MakeSelectable()</A></TT></B> and <B><TT><A HREF="#MakeEditable()">MakeEditable()</A></TT></B>.)
<P>
<LI>Multiple character formats are not permitted.  (See <B><TT><A HREF="#SetStylable()">SetStylable()</A></TT></B>.)
<P>
<LI>The text is left-aligned.  (See <B><TT><A HREF="#SetAlignment()">SetAlignment()</A></TT></B>.)
<P>
<LI>The tab width is 28.0 coordinate units.  (See <B><TT><A HREF="#SetTabWidth()">SetTabWidth()</A></TT></B>.)
<P>
<LI>Word wrapping is turned on.  (See <B><TT><A HREF="#SetWordWrap()">SetWordWrap()</A></TT></B>.)
<P>
<LI>Automatic indenting is turned off.  (See <B><TT><A HREF="#SetAutoindent()">SetAutoindent()</A></TT></B>.)
<P>
<LI>The maximum amount of data is permitted.  (See <B><TT><A HREF="#SetMaxBytes()">SetMaxBytes()</A></TT></B>.)
<P>
<LI>The view doesn't grow to accommodate more characters.  (See <B><TT><A HREF="#MakeResizable()">MakeResizable()</A></TT></B>.)
<P>
<LI>All characters the user may type are acceptable.  (See <B><TT><A HREF="#DisallowChar()">DisallowChar()</A></TT></B>.)
<P>
</UL>
<P>
<B>See also:  <TT><A HREF="#AttachedToWindow()">AttachedToWindow()</A></TT></B>, <B><TT><A HREF="#SetFontAndColor()">SetFontAndColor()</A></TT></B>, the <A HREF="View.html#BView">BView</A> constructor
<P>
<HR>
<H3>
<A NAME="~BTextView()"></A>~BTextView()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual <B><TT><FONT  color=000022 size=+1>~BTextView()
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Frees the memory the BTextView allocated to hold the text and to store information about it.
<P>
<HR>
<H2>
<A NAME="Static%20Functions"></A><FONT SIZE=6>S</FONT>tatic <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="FlattenRunArray()"></A>FlattenRunArray()
, 
<A NAME="UnflattenRunArray()"></A>UnflattenRunArray()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
static void *<B><TT><FONT  color=000022 size=+1>FlattenRunArray(</TT></B></FONT>const text_run_array *<I><FONT  color=991122 face=HELVETICA>runs</I></FONT>, int32&nbsp;*<I><FONT  color=991122 face=HELVETICA>numBytes</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
static text_run_array *<B><TT><FONT  color=000022 size=+1>UnflattenRunArray(</TT></B></FONT>const void *<I><FONT  color=991122 face=HELVETICA>data</I></FONT>, int32&nbsp;*<I><FONT  color=991122 face=HELVETICA>numBytes</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions flatten and unflatten a <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> structure so that it can be treated as an untyped stream of bytes.  A <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> that's saved on-disk will be valid when the user reboots the machine only if it's saved as flat data.  Both functions return pointers to memory they allocate (with <B><TT>malloc()</TT></B>).  The caller is responsible for freeing the memory when it's no longer needed.
<P>
<B><TT><A HREF="#FlattenRunArray()">FlattenRunArray()</A></TT></B> flattens the <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> and returns the flat data.  <B><TT><A HREF="#UnflattenRunArray()">UnflattenRunArray()</A></TT></B> reconstructs a <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> from previously flattened <I><FONT  color=991122 face=HELVETICA>data</I></FONT> and returns a pointer to the structure.
<P>
If a <I><FONT  color=991122 face=HELVETICA>numBytes</I></FONT> argument is provided, both functions place the number of bytes they allocated for the data in the variable that <I><FONT  color=991122 face=HELVETICA>numBytes</I></FONT> refers to.
<P>
<B>See also:  <TT><A HREF="#SetRunArray()">SetRunArray()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="Instantiate()"></A>Instantiate()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
static <A HREF="../The%20Support%20Kit/Archivable.html#BArchivable">BArchivable</A> *<B><TT><FONT  color=000022 size=+1>Instantiate(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>archive</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
Returns a new BTextView object, allocated by <B><TT>new</TT></B> and created by the version of the constructor that takes a <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> <I><FONT  color=991122 face=HELVETICA>archive</I></FONT>.  However, if the archive doesn't contain data for a BTextView object, the return value will be <B><TT>NULL</TT></B>. 
<P>
<B>See also:  <TT><A HREF="../The%20Support%20Kit/Archivable.html#Instantiate()">BArchivable::Instantiate()</A></TT></B>, <B><TT><A HREF="#Archive()">Archive()</A></TT></B> 
<P>
<HR>
<H3>UnflattenRunArray()   see <A HREF="#FlattenRunArray()">FlattenRunArray()</A></H3>
<P>
<HR>
<H2>
<A NAME="Member%20Functions"></A><FONT SIZE=6>M</FONT>ember <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="AcceptsDrop()"></A>AcceptsDrop()
, 
<A NAME="AcceptsPaste()"></A>AcceptsPaste()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual bool <B><TT><FONT  color=000022 size=+1>AcceptsDrop(</TT></B></FONT>const <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>message</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> 
<P>


<TR><TD>
virtual bool <B><TT><FONT  color=000022 size=+1>AcceptsPaste(</TT></B></FONT><A HREF="../The%20Application%20Kit/Clipboard.html#BClipboard">BClipboard</A> *<I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
These functions look at the data in their arguments, and return <B><TT>true</TT></B> if its "acceptable."  The default implementations return <B><TT>true</TT></B> if both of the following are true:
<P>
<UL>
<LI>the BTextView is editable 
<P>
<LI>the <I><FONT  color=991122 face=HELVETICA>message</I></FONT> or <I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT> contains <B><TT><A HREF="../The%20Support%20Kit/misc.html#B_MIME_TYPE">B_MIME_TYPE</A></TT></B> data stored under the name "text/plain".  
<P>
</UL>
<P>
If the data isn't acceptable, the drop or paste operation is aborted.
<P>
<B><TT>AcceptsDrop()</TT></B> is invoked in two places:  When a message is dragged over the <A HREF="#BTextView">BTextView</A>, and when the message is dropped on the object.  <B><TT><A HREF="#AcceptsPaste()">AcceptsPaste()</A></TT></B> is called when a <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_PASTE">B_PASTE</A></TT></B> message is received.  If you augment these functions to accept more types, you'll also have to augment the <B><TT><A HREF="#MessageReceived()">MessageReceived()</A></TT></B> and <B><TT><A HREF="#Paste()">Paste()</A></TT></B> functions to insert the text found in <I><FONT  color=991122 face=HELVETICA>message</I></FONT> or <I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT>. 
<P>
<HR>
<H3>Alignment()   see <A HREF="#SetAlignment()">SetAlignment()</A></H3>
<P>
<HR>
<H3>AllowChar()   see <A HREF="#DisallowChar()">DisallowChar()</A></H3>
<P>
<HR>
<H3>
<A NAME="Archive()"></A>Archive()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>Archive(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>archive</I></FONT>, bool <I><FONT  color=991122 face=HELVETICA>deep</I></FONT> = <FONT  face=HELVETICA>true</FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Calls the inherited version of <B><TT><A HREF="#Archive()">Archive()</A></TT></B> and stores the BTextView in the <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> <I><FONT  color=991122 face=HELVETICA>archive</I></FONT>.
<P>
<B>See also:  <TT><A HREF="../The%20Support%20Kit/Archivable.html#Archive()">BArchivable::Archive()</A></TT></B>, <B><TT><A HREF="#Instantiate()">Instantiate()</A></TT></B> static function 
<P>
<HR>
<H3>
<A NAME="AttachedToWindow()"></A>AttachedToWindow()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>AttachedToWindow(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Completes the initialization of the BTextView object after it becomes attached to a window.  This function sets up the object so that it can correctly format text and display it.  Among other things, it sets the drawing mode to <B><TT><A HREF="misc.html#B_OP_COPY">B_OP_COPY</A></TT></B>.  If the BTextView is targeted by scroll bars, it adjusts them so that they're accurately set up for scrolling the text.
<P>
Because the BTextView uses pulses to animate (or "blink") the caret, the vertical line that marks the current insertion point, this function also enables pulsing in the window and fixes the pulse rate at 2 per second.
<P>
<B><TT><A HREF="#AttachedToWindow()">AttachedToWindow()</A></TT></B> is called for you when the BTextView becomes part a window's view hierarchy; you shouldn't call it yourself, though you can override it.  A function that's implemented by a derived class should begin by incorporating the BTextView version:
<P>
<PRE>&nbsp;&nbsp;&nbsp;void MyText::AttachedToWindow()
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;    BTextView::AttachedToWindow()
&nbsp;&nbsp;&nbsp;    . . .
&nbsp;&nbsp;&nbsp;}</PRE>
<P>
If it doesn't, the BTextView won't be able to properly display the text.
<P>
<B>See also:  <TT>BView::AttachedToWindow()</TT></B>, <B><TT>SetFontName()</TT></B> 
<P>
<HR>
<H3>ByteAt()   see <A HREF="#Text()">Text()</A></H3>
<P>
<HR>
<H3>
<A NAME="CanEndLine()"></A>CanEndLine()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual bool <B><TT><FONT  color=000022 size=+1>CanEndLine(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>offset</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns <B><TT>true</TT></B> if the character at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> can be the last character in a line of text, and <B><TT>false</TT></B> if not.  Sometimes this depends on whether the next character (if there is one) can begin a line.  This function is called as the BTextView figures out where to break lines, but only if word wrapping is turned on.
<P>
As implemented, <B><TT><A HREF="#CanEndLine()">CanEndLine()</A></TT></B> allows the following ASCII characters to end a line regardless of the context:
<P>
<TABLE BORDER cellpadding=4>
<TD><B><TT><A HREF="misc.html#B_SPACE">B_SPACE</A></TT></B></TD>
<TD>=</TD>
<TD>&lt;</TD>
<TD>/</TD>
<TD>&amp;</TD>
<TR>
<TD><B><TT><A HREF="misc.html#B_TAB">B_TAB</A></TT></B></TD>
<TD>+</TD>
<TD>></TD>
<TD></TD>
<TD>*</TD>
<TR>
<TD><B><TT><A HREF="misc.html#B_ENTER">B_ENTER</A></TT></B></TD>
<TD>&ndash;</TD>
<TD>^</TD>
<TD>|</TD>
<TD>'0'</TD>
</TABLE>
<P>
The default implementation also understands the line-ending conventions for Chinese and Japanese.  Because these languages are written without the spaces that typically end lines in other languages, lines can potentially break anywhere.  However, certain characters are prohibited from ending a line and others are prohibited from beginning a new line.  <B><TT><A HREF="#CanEndLine()">CanEndLine()</A></TT></B> prevents lines from ending either on a prohibited ending character or on the character before a prohibited beginning character.
<P>
Derived classes can override this function to apply different criteria for where lines end, possibly looking at the context of the <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> character.  You can also augment the current implementation so that it understands the conventions for other languages.
<P>
If you override this function to look to the left or right of the character at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>, be sure to check that you haven't stepped beyond the range of the text.  For example, this version of the function makes sure that the first hyphen of a pair doesn't break a line:
<P>
<PRE>&nbsp;&nbsp;&nbsp;bool MyTextView::CanEndLine(int32 offset)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;    if ( ByteAt[offset] == &gt;-&gt; ) {
&nbsp;&nbsp;&nbsp;        if ( TextLength() - offset > 1 ) {
&nbsp;&nbsp;&nbsp;            if ( ByteAt[offset + 1] == &gt;-&gt; )
&nbsp;&nbsp;&nbsp;                return false;
&nbsp;&nbsp;&nbsp;        }
&nbsp;&nbsp;&nbsp;    }
&nbsp;&nbsp;&nbsp;    return (<I>baseClass</I>::CanEndLine(offset));
&nbsp;&nbsp;&nbsp;}</PRE>
<P>
<B>See also:  <TT><A HREF="#SetWordWrap()">SetWordWrap()</A></TT></B> 
<P>
<HR>
<H3>Clear() see <A HREF="#Cut()">Cut()</A></H3>
<P>
<HR>
<H3>ColorSpace()   see <A HREF="#SetColorSpace()">SetColorSpace()</A></H3>
<P>
<HR>
<H3>Copy()   see <A HREF="#Cut()">Cut()</A></H3>
<P>
<HR>
<H3>CountLines()   see <A HREF="#GoToLine()">GoToLine()</A></H3>
<P>
<HR>
<H3>CurrentLine()   see <A HREF="#GoToLine()">GoToLine()</A></H3>
<P>
<HR>
<H3>
<A NAME="Cut()"></A>Cut()
, 
<A NAME="Copy()"></A>Copy()
, 
<A NAME="Paste()"></A>Paste()
, 
<A NAME="Clear()"></A>Clear()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Cut(</TT></B></FONT><A HREF="../The%20Application%20Kit/Clipboard.html#BClipboard">BClipboard</A> *<I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Copy(</TT></B></FONT><A HREF="../The%20Application%20Kit/Clipboard.html#BClipboard">BClipboard</A> *<I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Paste(</TT></B></FONT><A HREF="../The%20Application%20Kit/Clipboard.html#BClipboard">BClipboard</A> *<I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Clear(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions implement the standard cut, copy, paste, and clear commands.  <B><TT><A HREF="#Cut()">Cut()</A></TT></B> and <B><TT><A HREF="#Copy()">Copy()</A></TT></B> both copy the current selection to the specified <I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT>; <B><TT><A HREF="#Cut()">Cut()</A></TT></B> also deletes the text from the BTextView and removes it from the display.  The text is entered in the clipboard as <B><TT><A HREF="../The%20Support%20Kit/misc.html#B_MIME_TYPE">B_MIME_TYPE</A></TT></B> data under the name "text/plain".  <B><TT><A HREF="#Paste()">Paste()</A></TT></B> looks in the <I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT> for just this type of data and pastes it into the text&mdash;but only if <B><TT><A HREF="#AcceptsPaste()">AcceptsPaste()</A></TT></B> returns <B><TT>true</TT></B>.  The new text replaces the current selection, or is placed at the site of the current insertion point.
<P>
If the BTextView supports multiple character formats, <B><TT><A HREF="#Cut()">Cut()</A></TT></B> and <B><TT><A HREF="#Copy()">Copy()</A></TT></B> also place a <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> structure describing the formats of the copied text in the clipboard&mdash;as <B><TT><A HREF="../The%20Support%20Kit/misc.html#B_MIME_TYPE">B_MIME_TYPE</A></TT></B> data under the name "application/x-vnd.Be-text_run_array".  If the BTextView that takes text from the clipboard supports multiple formats, <B><TT><A HREF="#Paste()">Paste()</A></TT></B> looks for the <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> in the clipboard and sets the formats of the pasted text accordingly.
<P>
In most cases, the <I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT> argument will be identical to the global <B><TT><A HREF="../The%20Application%20Kit/misc.html#be_clipboard">be_clipboard</A></TT></B> object.
<P>
The <B><TT>Clear()</TT></B> function simply removes the currently-selected text from the BTextView without affecting any clipboard.  If there's no selection, nothing happens.
<P>
<B>See also:  <TT><A HREF="#AcceptsPaste()">AcceptsPaste()</A></TT></B>, <a href="#Shortcuts%20and%20Menu%20Items">"Shortcuts and Menu Items"</a> in the overview 
<P>
<HR>
<H3>Delete()   see <A HREF="#Insert()">Insert()</A></H3>
<P>
<HR>
<H3>DeleteText()   see <A HREF="#InsertText()">InsertText()</A></H3>
<P>
<HR>
<H3>
<A NAME="DetachedFromWindow()"></A>DetachedFromWindow()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>DetachedFromWindow(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Resets the cursor to the standard hand image (<B><TT><A HREF="../The%20Application%20Kit/misc.html#Cursor%20Constants">B_HAND_CURSOR</A></TT></B>) if it's above the BTextView when the BTextView is removed from the window.
<P>
<B>See also:  <TT>BView::DetachedFromWindow()</TT></B> 
<P>
<HR>
<H3>
<A NAME="DisallowChar()"></A>DisallowChar()
, 
<A NAME="AllowChar()"></A>AllowChar()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>DisallowChar(</TT></B></FONT>uint32 <I><FONT  color=991122 face=HELVETICA>aChar</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>AllowChar(</TT></B></FONT>uint32 <I><FONT  color=991122 face=HELVETICA>aChar</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions inform the BTextView whether the user should be allowed to enter <I><FONT  color=991122 face=HELVETICA>aChar</I></FONT> into the text.  By default, all characters are allowed.  Call <B><TT><A HREF="#DisallowChar()">DisallowChar()</A></TT></B> for each character you want to prevent the BTextView from accepting, preferably when first setting up the object.  Although declared as <B><TT>uint32</TT></B>, <I><FONT  color=991122 face=HELVETICA>aChar</I></FONT> must be a character encoded in a single byte; it can't be a 16-bit Unicode value or a multibyte UTF-8 string.
<P>
<B><TT><A HREF="#AllowChar()">AllowChar()</A></TT></B> reverses the effect of <B><TT><A HREF="#DisallowChar()">DisallowChar()</A></TT></B>. 
<P>
Alternatively, and for more control over the context in which characters are accepted or rejected, you can implement an <B><TT><A HREF="#InsertText()">InsertText()</A></TT></B> function for the BTextView.  <B><TT><A HREF="#InsertText()">InsertText()</A></TT></B> is called for all insertions, including each character the user types, all text the user drags to the <A HREF="#BTextView">BTextView</A>, and all attempts to paste from the clipboard.
<P>
<B>See also:  <TT>AcceptsChar()</TT></B> 
<P>
<HR>
<H3>DoesAutoindent()   see <A HREF="#SetAutoindent()">SetAutoindent()</A></H3>
<P>
<HR>
<H3>DoesUndo()   see <A HREF="#SetDoesUndo()">SetDoesUndo()</A></H3>
<P>
<HR>
<H3>DoesWordWrap()   see <A HREF="#SetWordWrap()">SetWordWrap()</A></H3>
<P>
<HR>
<H3>
<A NAME="Draw()"></A>Draw()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Draw(</TT></B></FONT><A HREF="Rect.html#BRect">BRect</A> <I><FONT  color=991122 face=HELVETICA>updateRect</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Draws the BTextView.
<P>
<B>See also:  <TT>BView::Draw()</TT></B> 
<P>
<HR>
<H3>
<A NAME="FindWord()"></A>FindWord()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>FindWord(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>, int32&nbsp;*<I><FONT  color=991122 face=HELVETICA>start</I></FONT>, int32&nbsp;*<I><FONT  color=991122 face=HELVETICA>finish</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Looks for a sequence of characters that qualifies as a word&mdash;that is, a sequence that the user can double-click to select&mdash;that includes the character at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>.  This function places the offset of the word's first character in the variable that <I><FONT  color=991122 face=HELVETICA>start</I></FONT> refers to and the offset following the last character in the word in the variable that <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> refers to.  If the <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> character can't be part of a word, the <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> offsets will be identical.
<P>
As implemented, this function allows the user to select a group of similar characters with a double-click.  For example, in the following line of malformed text,
<P>
<PRE>&nbsp;&nbsp;&nbsp;"You  <I>what</I>!!?"</PRE>
<P>
it would allow the user to select the words "You" and "what," the group of spaces between the words, and the group of punctuation marks at the end.  
<P>
The function also defines similar groups of Japanese characters that can be selected together.
<P>
<HR>
<H3>
<A NAME="FrameResized()"></A>FrameResized()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>FrameResized(</TT></B></FONT>float <I><FONT  color=991122 face=HELVETICA>width</I></FONT>, float <I><FONT  color=991122 face=HELVETICA>height</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Overrides the <A HREF="View.html#BView">BView</A> version of this function to reset the ranges of the BTextView's scroll bars and to update the sizes of their proportional knobs whenever the size of the BTextView changes.
<P>
<B>See also:  <TT>BView::FrameResized()</TT></B> 
<P>
<HR>
<H3>
<A NAME="GetDragParameters()"></A>GetDragParameters()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>GetDragParameters(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>drag</I></FONT>, 
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="Bitmap.html#BBitmap">BBitmap</A> **<I><FONT  color=991122 face=HELVETICA>bitmap,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I></FONT><A HREF="Point.html#BPoint">BPoint</A> *<I><FONT  color=991122 face=HELVETICA>point,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I></FONT><A HREF="../The%20Application%20Kit/Handler.html#BHandler">BHandler</A> **<I><FONT  color=991122 face=HELVETICA>handler</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>GetDragParameters()</TT></B> is called when a drag session is initiated.  The values that it retrieves (by reference in the arguments) are passed on to <B><TT>BView::DragMessage()</TT></B>. If you don't supply a bitmap (if you set <I><FONT  color=991122 face=HELVETICA>*bitmap</I></FONT> to <B><TT>NULL</TT></B>), the outline rectangle version of <B><TT>DragMessage()</TT></B> is used.
<P>
<HR>
<H3>
<A NAME="GetSelection()"></A>GetSelection()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>GetSelection(</TT></B></FONT>int32 *<I><FONT  color=991122 face=HELVETICA>start</I></FONT>, int32 *<I><FONT  color=991122 face=HELVETICA>finish</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Provides the current selection by writing the offset before the first selected character into the variable referred to by <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and the offset after the last selected character into the variable referred to by <I><FONT  color=991122 face=HELVETICA>finish</I></FONT>.  If no characters are selected, both offsets will record the position of the current insertion point.
<P>
If the text isn't selectable, both offsets will be 0.
<P>
<B>See also:  <TT><A HREF="#Select()">Select()</A></TT></B> 
<P>
<HR>
<H3>GetText()   see <A HREF="#Text()">Text()</A></H3>
<P>
<HR>
<H3>
<A NAME="GetTextRegion()"></A>GetTextRegion()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>GetTextRegion(</TT></B></FONT>int32&nbsp;<I><FONT  color=991122 face=HELVETICA>start</I></FONT>, int32&nbsp;<I><FONT  color=991122 face=HELVETICA>finish</I></FONT>, <A HREF="Region.html#BRegion">BRegion</A>&nbsp;*<I><FONT  color=991122 face=HELVETICA>region</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Calculates the region where the run of characters beginning at the <I><FONT  color=991122 face=HELVETICA>start</I></FONT> offset and ending at the <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> offset would be displayed within the BTextView's coordinate system, and modifies the <A HREF="Region.html#BRegion">BRegion</A> object passed as the third argument, <I><FONT  color=991122 face=HELVETICA>region</I></FONT>, so that it represents that region.
<P>
<B>See also:  <TT><A HREF="#TextHeight()">TextHeight()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="GoToLine()"></A>GoToLine()
, 
<A NAME="CountLines()"></A>CountLines()
, 
<A NAME="CurrentLine()"></A>CurrentLine()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>GoToLine(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>index</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>CurrentLine(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>


<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>CountLines(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
<B><TT><A HREF="#GoToLine()">GoToLine()</A></TT></B> moves the insertion point to the beginning of the line at <I><FONT  color=991122 face=HELVETICA>index</I></FONT>.  The first line has an index of 0, the second line an index of 1, and so on.  If the <I><FONT  color=991122 face=HELVETICA>index</I></FONT> is out-of-range, the insertion point is moved to the beginning of the line with the nearest in-range index&mdash;that is, to either the first or the last line.
<P>
<B><TT><A HREF="#CurrentLine()">CurrentLine()</A></TT></B> returns the index of the line where the first character of the selection&mdash;or the character following the insertion point&mdash;is currently located.
<P>
<B><TT><A HREF="#CountLines()">CountLines()</A></TT></B> returns how many lines of text the BTextView currently contains.
<P>
Like other functions that change the selection, <B><TT><A HREF="#GoToLine()">GoToLine()</A></TT></B> doesn't automatically scroll the display to make the new selection visible.  Call <B><TT><A HREF="#ScrollToSelection()">ScrollToSelection()</A></TT></B> to be sure that the user can see the start of the selection.
<P>
<B>See also:  <TT><A HREF="#ScrollToSelection()">ScrollToSelection()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="HideTyping()"></A>HideTyping()
, 
<A NAME="IsTypingHidden()"></A>IsTypingHidden()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>HideTyping(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>flag</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>IsTypingHidden(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
The first of these functions sets whether the user can see the text in the BTextView; the second returns whether or not the text is currently visible.  When <I><FONT  color=991122 face=HELVETICA>flag</I></FONT>'s state is <B><TT>true</TT></B>, text contained by the BTextView isn't visible.
<P>
<HR>
<H3>
<A NAME="Highlight()"></A>Highlight()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
inline void <B><TT><FONT  color=000022 size=+1>Highlight(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>start</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>finish</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Highlights (or unhighlights) the characters between the <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> offsets.  This is the function that the BTextView calls to highlight and unhighlight the current selection.  You don't need to call it yourself for this purpose.  It's in the public API just in case you may need to highlight a range of text in some other circumstance.
<P>
If the text is not currently highlighted, this function highlights it.  But if the text is already highlighted, it unhighlights it.  If you highlight some text, be sure to unhighlight it before the next editorial change; the BTextView will not do it for you.
<P>
<B>See also:  <TT><A HREF="#Select()">Select()</A></TT></B>, <B><TT>TextRegion()</TT></B> 
<P>
<HR>
<H3>
<A NAME="Insert()"></A>Insert()
, 
<A NAME="Delete()"></A>Delete()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>Insert(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>text</I></FONT>, const&nbsp;text_run_array&nbsp;*<I><FONT  color=991122 face=HELVETICA>runs</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>Insert(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>text</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>length</I></FONT>, const&nbsp;text_run_array&nbsp;*<I><FONT  color=991122 face=HELVETICA>runs</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>Insert(</TT></B></FONT>int32&nbsp;<I><FONT  color=991122 face=HELVETICA>offset</I></FONT>, const char *<I><FONT  color=991122 face=HELVETICA>text</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>length</I></FONT>, const&nbsp;text_run_array&nbsp;*<I><FONT  color=991122 face=HELVETICA>runs</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>Delete(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>Delete(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>start</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>finish</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT><A HREF="#Insert()">Insert()</A></TT></B> adds <I><FONT  color=991122 face=HELVETICA>length</I></FONT> bytes of <I><FONT  color=991122 face=HELVETICA>text</I></FONT> to the BTextView&mdash;or if a <I><FONT  color=991122 face=HELVETICA>length</I></FONT> isn't specified, all the characters of the <I><FONT  color=991122 face=HELVETICA>text</I></FONT> string up to the null character that terminates it.  The text is inserted at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>&mdash;or at the beginning of the current selection if an <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> isn't specified.  The current selection is not deleted and the insertion is not selected.
<P>
The inserted characters are displayed in the fonts and colors specified in the accompanying <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> array, provided the BTextView allows multiple character formats.   If multiple formats aren't allowed, the <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> array is ignored.  If multiple formats are allowed but a <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> array isn't provided, the insertion is displayed in the font and color in force at the point of insertion.  This generally means the font and color of the first character of the selection, or of the character immediately preceding the <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> character.
<P>
Offsets in the <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> array should describe the text being inserted; in other words, the first offset should be 0.  See <B><TT><A HREF="#SetRunArray()">SetRunArray()</A></TT></B> for a description of the <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> structure.
<P>
<B><TT><A HREF="#Insert()">Insert()</A></TT></B> doesn't assume responsibility for the <I><FONT  color=991122 face=HELVETICA>text</I></FONT> data or the <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> array.  It copies the information it needs.
<P>
<B><TT><A HREF="#Delete()">Delete()</A></TT></B> removes the characters bounded by the <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> offsets from the display and deletes them from the BTextView's text, without copying them to the clipboard.  If the <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> offsets are the same, nothing is deleted.  If offsets are not provided, <B><TT><A HREF="#Delete()">Delete()</A></TT></B> deletes the current selection.
<P>
<B>See also:  <TT><A HREF="#SetText()">SetText()</A></TT></B>, <B><TT><A HREF="#Cut()">Cut()</A></TT></B>, <B><TT><A HREF="#SetRunArray()">SetRunArray()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="InsertText()"></A>InsertText()
, 
<A NAME="DeleteText()"></A>DeleteText()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>InsertText(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>text</I></FONT>, 
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32&nbsp;<I><FONT  color=991122 face=HELVETICA>length</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32&nbsp;<I><FONT  color=991122 face=HELVETICA>offset</I></FONT>, 
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const text_run_array&nbsp;*<I><FONT  color=991122 face=HELVETICA>runs</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>DeleteText(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>start</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>finish</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These protected functions are the vehicles through which the BTextView performs every insertion and deletion of text (with one exception).  You can augment them in a subclass to take note of pending changes to the text, and to modify or prevent the change.
<P>
Don't call <B><TT><A HREF="#Insert()">Insert()</A></TT></B>, <B><TT><A HREF="#Delete()">Delete()</A></TT></B> or any other high-level text-manipulating function in your implementation.
<P>
<B><TT><A HREF="#InsertText()">InsertText()</A></TT></B> adds <I><FONT  color=991122 face=HELVETICA>length</I></FONT> bytes of <I><FONT  color=991122 face=HELVETICA>text</I></FONT> to the <A HREF="#BTextView">BTextView</A>, inserting it at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> within the text buffer.  The font and color of the inserted characters may be described by an accompanying <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> array.  If the BTextView doesn't support multiple character formats, the <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> array is ignored.  If multiple formats are supported but the <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> array is <B><TT>NULL</TT></B>, the text is displayed in the font and color of the character preceding <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> (or of the first character, if <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> is 0.)
<P>
The offsets in the <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> data structure are relative to the inserted text; that is, the first offset in the array is&nbsp;0, not <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>.
<P>
<B><TT><A HREF="#InsertText()">InsertText()</A></TT></B> is called for every insertion, except one.  The exception occurs when <B><TT><A HREF="#SetText()">SetText()</A></TT></B> takes text from a file; in this case the text goes directly from the file to the BTextView; it's not stored in a temporary buffer while <B><TT><A HREF="#InsertText()">InsertText()</A></TT></B> is called.
<P>
<B><TT><A HREF="#DeleteText()">DeleteText()</A></TT></B> removes the text bounded by the <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> offsets.  It fails if the offsets don't differ, or if the <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> offset isn't greater than the <I><FONT  color=991122 face=HELVETICA>start</I></FONT> offset.  This function is called for every deletion.
<P>
<B>See also:  <TT><A HREF="#Insert()">Insert()</A></TT></B>, <B><TT><A HREF="#Delete()">Delete()</A></TT></B> 
<P>
<HR>
<H3>IsEditable()   see <A HREF="#MakeEditable()">MakeEditable()</A></H3>
<P>
<HR>
<H3>IsSelectable()   see <A HREF="#MakeSelectable()">MakeSelectable()</A></H3>
<P>
<HR>
<H3>
<A NAME="KeyDown()"></A>KeyDown()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>KeyDown(</TT></B></FONT>const&nbsp;char&nbsp;*<I><FONT  color=991122 face=HELVETICA>bytes</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>numBytes</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Enters text at the current selection in response to the user's typing.  This function is called from the window's message loop for every report of a key-down event&mdash;typically once for every character the user types.  However, it does nothing unless the BTextView is the focus view and the text it contains is editable.
<P>
If the character encoded in the <I><FONT  color=991122 face=HELVETICA>bytes</I></FONT> string is an editing instruction, <B><TT><A HREF="#KeyDown()">KeyDown()</A></TT></B> takes the appropriate action:
<P>
<UL>
<LI>If the character is from one of the arrow keys (<B><TT><A HREF="misc.html#B_UP_ARROW">B_UP_ARROW</A></TT></B>, <B><TT><A HREF="misc.html#B_LEFT_ARROW">B_LEFT_ARROW</A></TT></B>, <B><TT><A HREF="misc.html#B_DOWN_ARROW">B_DOWN_ARROW</A></TT></B>, or <B><TT><A HREF="misc.html#B_RIGHT_ARROW">B_RIGHT_ARROW</A></TT></B>), it extends the selection or moves the insertion point in the appropriate direction, depending on the modifiers
<P>
<LI>If the character is <B><TT><A HREF="misc.html#B_BACKSPACE">B_BACKSPACE</A></TT></B> or <B><TT><A HREF="misc.html#B_DELETE">B_DELETE</A></TT></B>, it deletes the current selection&mdash;or the character preceding or following the current insertion point.
<P>
<LI>If the character comes from one of the paging keys (<B><TT><A HREF="misc.html#B_HOME">B_HOME</A></TT></B>, <B><TT><A HREF="misc.html#B_END">B_END</A></TT></B>, <B><TT><A HREF="misc.html#B_PAGE_UP">B_PAGE_UP</A></TT></B>, or <B><TT><A HREF="misc.html#B_PAGE_DOWN">B_PAGE_DOWN</A></TT></B>), it scrolls the display.
<P>
</UL>
<P>
Otherwise, it checks whether the character was registered as unacceptable (by <B><TT><A HREF="#DisallowChar()">DisallowChar()</A></TT></B>).  If not disallowed, it calls the <B><TT><A HREF="#InsertText()">InsertText()</A></TT></B> hook function to enter the character into the text and display it.  Derived classes can preview about-to-be-inserted characters by overriding <B><TT><A HREF="#InsertText()">InsertText()</A></TT></B>.
<P>
<B>See also:  <TT>BView::KeyDown()</TT></B>, <B><TT><A HREF="#InsertText()">InsertText()</A></TT></B>, <B><TT><A HREF="#DisallowChar()">DisallowChar()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="LineAt()"></A>LineAt()
, 
<A NAME="PointAt()"></A>PointAt()
, 
<A NAME="OffsetAt()"></A>OffsetAt()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>LineAt(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>offset</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>LIneAt(</TT></B></FONT><A HREF="Point.html#BPoint">BPoint</A> <I><FONT  color=991122 face=HELVETICA>point</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>


<TR><TD>
<A HREF="Point.html#BPoint">BPoint</A> <B><TT><FONT  color=000022 size=+1>PointAt(</TT></B></FONT>int32&nbsp;<I><FONT  color=991122 face=HELVETICA>offset</I></FONT>, float&nbsp;*<I><FONT  color=991122 face=HELVETICA>height</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>


<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>OffsetAt(</TT></B></FONT><A HREF="Point.html#BPoint">BPoint</A> <I><FONT  color=991122 face=HELVETICA>point</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>OffsetAt(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>index</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
These functions translate between coordinate values, text offsets, and line indices.  <B><TT><A HREF="#LineAt()">LineAt()</A></TT></B> returns the index of the line containing the character at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> in the text, or the line located at the specified <I><FONT  color=991122 face=HELVETICA>point</I></FONT> in the BTextView's coordinate system.  Line indices begin at&nbsp;0.
<P>
<B><TT><A HREF="#PointAt()">PointAt()</A></TT></B> returns the coordinate location of the character at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>.  The point is the left top corner of a rectangle enclosing the character and is stated in the BTextView's coordinate system.  The <I>x</I>-coordinate of the point is the position on the baseline where the character is (or would be) drawn; its <I>y</I>-coordinate is the top of the line where the <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> character is located.  If a <I><FONT  color=991122 face=HELVETICA>height</I></FONT> argument is provided, <B><TT><A HREF="#PointAt()">PointAt()</A></TT></B> returns the height of the line by reference.
<P>
<B><TT><A HREF="#OffsetAt()">OffsetAt()</A></TT></B> returns the offset to the character that begins the <I><FONT  color=991122 face=HELVETICA>index</I></FONT> line, or to the character displayed at <I><FONT  color=991122 face=HELVETICA>point</I></FONT>.
<P>
<HR>
<H3>
<A NAME="LineHeight()"></A>LineHeight()
, 
<A NAME="TextHeight()"></A>TextHeight()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
float <B><TT><FONT  color=000022 size=+1>LineHeight(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>index</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>


<TR><TD>
float <B><TT><FONT  color=000022 size=+1>TextHeight(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>firstIndex</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>lastIndex</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
<B><TT><A HREF="#LineHeight()">LineHeight()</A></TT></B> returns the height of the line of text at <I><FONT  color=991122 face=HELVETICA>index</I></FONT>, or the first line if an index isn't specified.  Line indices begin at 0.  The height is stated in coordinate units and depends on the font.  It's the sum of how far characters can ascend above and descend below the baseline, plus the amount of leading that separates lines.  If more than one font is used on the line, the ascent is taken from the tallest font and the descent and leading from the deepest.
<P>
<B><TT><A HREF="#TextHeight()">TextHeight()</A></TT></B> returns the height of the set of lines from <I><FONT  color=991122 face=HELVETICA>firstIndex</I></FONT> through <I><FONT  color=991122 face=HELVETICA>lastIndex</I></FONT>.
<P>
Both functions reset out-of-range indices to be in-range&mdash;that is, to the index of the first or last line.
<P>
<B>See also:  <TT><A HREF="Font.html#GetHeight()">BFont::GetHeight()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="LineWidth()"></A>LineWidth()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
float <B><TT><FONT  color=000022 size=+1>LineWidth(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>index</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Returns the width of the line at <I><FONT  color=991122 face=HELVETICA>index</I></FONT>&mdash;or, if no index is given, the width of the first line.  The value returned is the sum of the widths (in coordinate units) of all the characters in the line, from the first through the last, including tabs and spaces.  Line indices begin at 0.
<P>
If the <I><FONT  color=991122 face=HELVETICA>index</I></FONT> passed is out-of-range, it's reinterpreted to be the nearest in-range index&mdash;that is, as the index to the first or the last line.
<P>
<B>See also:  <TT><A HREF="Font.html#StringWidth()">BFont::StringWidth()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="MakeEditable()"></A>MakeEditable()
, 
<A NAME="IsEditable()"></A>IsEditable()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>MakeEditable(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> = <FONT  face=HELVETICA>true</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>IsEditable(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
The first of these functions sets whether the user can edit the text displayed by the BTextView; the second returns whether or not the text is currently editable.  Text is editable by default.
<P>
When text is editable but not selectable, the user can enter and delete text at the insertion point, but can't select text to make changes to more than one character at a time.
<P>
<B>See also:  <TT><A HREF="#MakeSelectable()">MakeSelectable()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="MakeFocus()"></A>MakeFocus()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>MakeFocus(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> = <FONT  face=HELVETICA>true</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Overrides the <A HREF="View.html#BView">BView</A> version of <B><TT><A HREF="#MakeFocus()">MakeFocus()</A></TT></B> to highlight the current selection when the BTextView becomes the focus view (when <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> is <B><TT>true</TT></B>) and to unhighlight it when the BTextView no longer is the focus view (when <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> is <B><TT>false</TT></B>).  However, the current selection is highlighted only if the BTextView's window is the current active window.
<P>
This function is called for you whenever the user's actions make the BTextView become the focus view, or force it to give up that status.
<P>
<B>See also:  <TT>BView::MakeFocus()</TT></B>, <B><TT><A HREF="#MouseDown()">MouseDown()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="MakeResizable()"></A>MakeResizable()
, 
<A NAME="IsResizable()"></A>IsResizable()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>MakeResizable(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>resizable</I></FONT>, <A HREF="View.html#BView">BView</A>&nbsp;*<I><FONT  color=991122 face=HELVETICA>containerView</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>IsResizable(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
<B><TT><A HREF="#MakeResizable()">MakeResizable()</A></TT></B> gives the BTextView the ability to automatically resize itself to fit its contents if the <I><FONT  color=991122 face=HELVETICA>resizable</I></FONT> flag is <B><TT>true</TT></B>, and takes away that ability if the flag is <B><TT>false</TT></B>.  <B><TT><A HREF="#IsResizable()">IsResizable()</A></TT></B> returns whether the BTextView is currently resizable.
<P>
The frame rectangle and text rectangle of a resizable BTextView automatically grow and shrink to exactly enclose all the characters entered by the user.  The object should display just a single line of text (the resizing is horizontal); if the <I><FONT  color=991122 face=HELVETICA>resizable</I></FONT> flag is <B><TT>true</TT></B>, <B><TT><A HREF="#MakeResizable()">MakeResizable()</A></TT></B> turns off line wrapping.  The text can be aligned to the left, right, or center of the text rectangle.
<P>
The <I><FONT  color=991122 face=HELVETICA>containerView</I></FONT> is a view that draws a border around the text (like a <A HREF="ScrollView.html#BScrollView">BScrollView</A> object) and is the parent of the BTextView; it's the view that's resized to fit the text.  The BTextView's resizing mode should be such that  it will be resized in tandem with the container (for example, <B><TT><A HREF="misc.html#B_FOLLOW_LEFT_RIGHT">B_FOLLOW_LEFT_RIGHT</A></TT></B> or <B><TT>B_FOLLOW_ALL_SIDES</TT></B>).  However, if the <I><FONT  color=991122 face=HELVETICA>containerView</I></FONT> is <B><TT>NULL</TT></B>, as it is by default, the BTextView itself is resized to fit the text.
<P>
If the <I><FONT  color=991122 face=HELVETICA>resizable</I></FONT> flag is <B><TT>false</TT></B>, the <I><FONT  color=991122 face=HELVETICA>containerView</I></FONT> argument is ignored.
<P>
This resizing mechanism is an alternative to the automatic resizing behavior provided in the <A HREF="View.html#BView">BView</A> class.  It triggers resizing on the user's entry of text, not on a change in the parent view's size.  The two schemes are incompatible; the container view (or the <A HREF="#BTextView">BTextView</A>, if there is no container) should not automatically resize itself when its parent is resized.
<P>
<B>See also:  <TT><A HREF="#SetAlignment()">SetAlignment()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="MakeSelectable()"></A>MakeSelectable()
, 
<A NAME="IsSelectable()"></A>IsSelectable()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>MakeSelectable(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> = <FONT  face=HELVETICA>true</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>IsSelectable(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
The first of these functions sets whether it's possible for the user to select text displayed by the BTextView; the second returns whether or not the text is currently selectable.  Text is selectable by default.
<P>
When text is selectable but not editable, the user can select one or more characters to copy to the clipboard, but can't position the insertion point (an empty selection), enter characters from the keyboard, or paste new text into the view.
<P>
<B>See also:  <TT><A HREF="#MakeEditable()">MakeEditable()</A></TT></B> 
<P>
<HR>
<H3>MaxBytes()   see <A HREF="#SetMaxBytes()">SetMaxBytes()</A></H3>
<P>
<HR>
<H3>
<A NAME="MessageReceived()"></A>MessageReceived()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>MessageReceived(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>message</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Augments the <A HREF="View.html#BView">BView</A> version of <B><TT>
<A NAME="MessageReceived()"></A>MessageReceived()
</TT></B> to handle scripting requests, dropped data, and four editing messages&mdash;<B><TT><A HREF="../The%20Application%20Kit/misc.html#B_CUT">B_CUT</A></TT></B>, <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_COPY">B_COPY</A></TT></B>, <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_PASTE">B_PASTE</A></TT></B>, and <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_SELECT_ALL">B_SELECT_ALL</A></TT></B>.
<P>
If the <I><FONT  color=991122 face=HELVETICA>message</I></FONT> was dragged and dropped on the BTextView and it contains <B><TT><A HREF="../The%20Support%20Kit/misc.html#B_MIME_TYPE">B_MIME_TYPE</A></TT></B> data under the name "text/plain", this function inserts the new text at the point where it was dropped&mdash;but only if <B><TT><A HREF="#AcceptsDrop()">AcceptsDrop()</A></TT></B> returns <B><TT>true</TT></B> for the <I><FONT  color=991122 face=HELVETICA>message</I></FONT>.
<P>
This function handles <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_CUT">B_CUT</A></TT></B>, <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_COPY">B_COPY</A></TT></B>, <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_PASTE">B_PASTE</A></TT></B>, and <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_SELECT_ALL">B_SELECT_ALL</A></TT></B> messages by calling the <B><TT><A HREF="#Cut()">Cut()</A></TT></B>, <B><TT><A HREF="#Copy()">Copy()</A></TT></B>, <B><TT><A HREF="#Paste()">Paste()</A></TT></B>, and <B><TT><A HREF="#SelectAll()">SelectAll()</A></TT></B> functions.  A BTextView will get these messages, even if the application doesn't send them, when it's the focus view and the user uses the Command-<I>x</I>, Command-<I>c</I>, Command-<I>v</I>, and Command-<I>a</I> shortcuts.  See <a href="#Shortcuts%20and%20Menu%20Items">"Shortcuts and Menu Items"</a> in the class overview for information on how to set up compatible Cut, Copy, Paste, and Select All menu items.
<P>
To inherit this functionality, <B><TT><A HREF="#MessageReceived()">MessageReceived()</A></TT></B> functions implemented by derived classes should be sure to call the BTextView version.
<P>
<B>See also:  <TT>BView::MessageReceived()</TT></B>, <B><TT><A HREF="#AcceptsPaste()">AcceptsPaste()</A></TT></B>, <B><TT><A HREF="../The%20Application%20Kit/Invoker.html#SetMessage()">BInvoker::SetMessage()</A></TT></B>, <B><TT><A HREF="../The%20Application%20Kit/Invoker.html#SetTarget()">BInvoker::SetTarget()</A></TT></B>, <B><TT><A HREF="#InsertText()">InsertText()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="MouseDown()"></A>MouseDown()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>MouseDown(</TT></B></FONT><A HREF="Point.html#BPoint">BPoint</A> <I><FONT  color=991122 face=HELVETICA>point</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Selects text, drags text, and positions the insertion point in response to the user's mouse actions.  If the BTextView isn't already the focus view for its window, this function calls <B><TT><A HREF="#MakeFocus()">MakeFocus()</A></TT></B> to make it the focus view.
<P>
<B><TT><A HREF="#MouseDown()">MouseDown()</A></TT></B> is called for each mouse-down event that occurs inside the BTextView's frame rectangle.
<P>
<B>See also:  <TT>BView::MouseDown()</TT></B>, <B><TT><A HREF="#MakeFocus()">MakeFocus()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="MouseMoved()"></A>MouseMoved()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>MouseMoved(</TT></B></FONT><A HREF="Point.html#BPoint">BPoint</A> <I><FONT  color=991122 face=HELVETICA>point</I></FONT>, uint32 <I><FONT  color=991122 face=HELVETICA>transit</I></FONT>, <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>message</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Responds to <B><TT><A HREF="misc.html#B_MOUSE_MOVED">B_MOUSE_MOVED</A></TT></B> messages by changing the cursor to the standard I-beam image for editing text whenever the cursor enters the view and by resetting it to the standard hand image when the cursor exits the view.  The cursor is changed to an I-beam for text that is selectable or editable, but only if the BTextView is the current focus view in the active window.  However, when the cursor moves over the current selection, this function changes it from the I-beam back to the standard hand image.  This is done to indicate that it's possible to drag and drop the current selection.
<P>
If a <I><FONT  color=991122 face=HELVETICA>message</I></FONT> is being dragged to the <A HREF="#BTextView">BTextView</A>, this function tests it see whether it contains textual data and tracks it to its destination.
<P>
<B>See also:  <TT>BView::MouseMoved()</TT></B>, <B><TT><A HREF="#AcceptsDrop()">AcceptsDrop()</A></TT></B> 
<P>
<HR>
<H3>OffsetAt()   see <A HREF="#LineAt()">LineAt()</A></H3>
<P>
<HR>
<H3>PointAt()   see <A HREF="#LineAt()">LineAt()</A></H3>
<P>
<HR>
<H3>Paste()   see <A HREF="#Cut()">Cut()</A></H3>
<P>
<HR>
<H3>
<A NAME="Pulse()"></A>Pulse()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Pulse(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Turns the caret marking the current insertion point on and off when the BTextView is the focus view in the active window.  <B><TT><A HREF="#Pulse()">Pulse()</A></TT></B> is called by the system at regular intervals.
<P>
This function is first declared in the <A HREF="View.html#BView">BView</A> class.
<P>
<B>See also:  <TT>BView::Pulse()</TT></B> 
<P>
<HR>
<H3>
<A NAME="ResolveSpecifier()"></A>ResolveSpecifier()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual <A HREF="../The%20Application%20Kit/Handler.html#BHandler">BHandler</A> *<B><TT><FONT  color=000022 size=+1>ResolveSpecifier(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>message</I></FONT>, int32&nbsp;<I><FONT  color=991122 face=HELVETICA>index</I></FONT>, <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A>&nbsp;*<I><FONT  color=991122 face=HELVETICA>specifier</I></FONT>, int32&nbsp;<I><FONT  color=991122 face=HELVETICA>command</I></FONT>, const&nbsp;char&nbsp;*<I><FONT  color=991122 face=HELVETICA>property</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Resolves specifiers for the "Text", "text_run_array", and "selection" properties.  See <a href="#Scripting%20Support">"Scripting Support"</a> in the class overview and "Scripting" in <B>The Application Kit</B> chapter for more information.
<P>
<B>See also:  <TT><A HREF="../The%20Application%20Kit/Handler.html#ResolveSpecifier()">BHandler::ResolveSpecifier()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="ScrollToOffset()"></A>ScrollToOffset()
, 
<A NAME="ScrollToSelection()"></A>ScrollToSelection()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>ScrollToOffset(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>offset</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>ScrollToSelection(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions scroll the text so that the character at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>&mdash;or the character that begins the current selection&mdash;is within the visible region of the view.  If the BTextView is equipped with scroll bars, the <A HREF="ScrollBar.html#BScrollBar">BScrollBar</A> objects are informed so they can update themselves.
<P>
<B>See also:  <TT>BView::ScrollTo()</TT></B> 
<P>
<HR>
<H3>
<A NAME="Select()"></A>Select()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Select(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>start</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>finish</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Selects the characters from <I><FONT  color=991122 face=HELVETICA>start</I></FONT> up to <I><FONT  color=991122 face=HELVETICA>finish</I></FONT>, where <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> are offsets into the BTextView's text.  If <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> are the same, the selection will be empty (an insertion point).  See <a href="#Offsets">"Offsets"</a> in the class overview for a discussion of the constraints on the offset arguments.
<P>
Normally, the selection is changed by the user.  This function provides a way to change it programmatically.
<P>
If the BTextView is the current focus view in the active window, <B><TT><A HREF="#Select()">Select()</A></TT></B> highlights the new selection (or displays a blinking caret at the insertion point).  However, it doesn't automatically scroll the contents of the BTextView to make the new selection visible.  Call <B><TT><A HREF="#ScrollToSelection()">ScrollToSelection()</A></TT></B> to be sure that the user can see the start of the selection.
<P>
<B>See also:  <TT><A HREF="#Text()">Text()</A></TT></B>, <B><TT><A HREF="#GetSelection()">GetSelection()</A></TT></B>, <B><TT><A HREF="#ScrollToSelection()">ScrollToSelection()</A></TT></B>, <B><TT><A HREF="#GoToLine()">GoToLine()</A></TT></B>, <B><TT><A HREF="#MouseDown()">MouseDown()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="SelectAll()"></A>SelectAll()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SelectAll(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Selects the entire text of the <A HREF="#BTextView">BTextView</A>, and highlights it if the BTextView is the current focus view in the active window.
<P>
<B>See also:  <TT><A HREF="#Select()">Select()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="SetAlignment()"></A>SetAlignment()
, 
<A NAME="Alignment()"></A>Alignment()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetAlignment(</TT></B></FONT>alignment <I><FONT  color=991122 face=HELVETICA>where</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
alignment <B><TT><FONT  color=000022 size=+1>Alignment(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
These functions set the way text is aligned within the text rectangle and return the current alignment.  Three settings are possible:
<P>
<TABLE BORDER cellpadding=4>
<TD><B><TT>
<A NAME="B_ALIGN_LEFT"></A>B_ALIGN_LEFT
</TT></B></TD>
<TD>Each line is aligned at the left boundary of the text rectangle.</TD>
<TR>
<TD><B><TT>
<A NAME="B_ALIGN_RIGHT"></A>B_ALIGN_RIGHT
</TT></B></TD>
<TD>Each line is aligned at the right boundary of the text rectangle.</TD>
<TR>
<TD><B><TT>
<A NAME="B_ALIGN_CENTER"></A>B_ALIGN_CENTER
</TT></B></TD>
<TD>Each line is centered between the left and right boundaries of the text rectangle.</TD>
</TABLE>
<P>
The default is <B><TT><A HREF="#B_ALIGN_LEFT">B_ALIGN_LEFT</A></TT></B>.
<P>
<HR>
<H3>
<A NAME="SetAutoindent()"></A>SetAutoindent()
, 
<A NAME="DoesAutoindent()"></A>DoesAutoindent()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetAutoindent(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>flag</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>DoesAutoindent(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
These functions set and return whether a new line of text is automatically indented the same as the preceding line.  When set to <B><TT>true</TT></B> and the user types Return at the end of a line that begins with tabs or spaces, the new line will automatically indent past those tabs and spaces to the position of the first visible character.
<P>
The default value is <B><TT>false</TT></B>.
<P>
<HR>
<H3>
<A NAME="SetColorSpace()"></A>SetColorSpace()
, 
<A NAME="ColorSpace()"></A>ColorSpace()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetColorSpace(</TT></B></FONT>color_space <I><FONT  color=991122 face=HELVETICA>space</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
color_space <B><TT><FONT  color=000022 size=+1>ColorSpace(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const 
<P>

</TABLE></TABLE>

<P>
These functions set and return the color space of the offscreen bitmap that buffers the drawing the BTextView does.  The default color space is <B><TT><A HREF="misc.html#B_CMAP8">B_CMAP8</A></TT></B>.
<P>
<B>See also:  </B>the <A HREF="Bitmap.html#BBitmap">BBitmap</A> class
<P>
<HR>
<H3>
<A NAME="SetFontAndColor()"></A>SetFontAndColor()
, 
<A NAME="GetFontAndColor()"></A>GetFontAndColor()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetFontAndColor(</TT></B></FONT>int32&nbsp;<I><FONT  color=991122 face=HELVETICA>start</I></FONT>, int32&nbsp;<I><FONT  color=991122 face=HELVETICA>finish</I></FONT>, 
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;<A HREF="Font.html#BFont">BFont</A>&nbsp;*<I><FONT  color=991122 face=HELVETICA>font</I></FONT>, uint32&nbsp;<I><FONT  color=991122 face=HELVETICA>properties</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>B_FONT_ALL</FONT>, rgb_color&nbsp;*<I><FONT  color=991122 face=HELVETICA>color</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetFontAndColor(</TT></B></FONT>const&nbsp;<A HREF="Font.html#BFont">BFont</A>&nbsp;*<I><FONT  color=991122 face=HELVETICA>font</I></FONT>, uint32&nbsp;<I><FONT  color=991122 face=HELVETICA>properties</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>B_FONT_ALL</FONT>, rgb_color&nbsp;*<I><FONT  color=991122 face=HELVETICA>color</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>GetFontAndColor(</TT></B></FONT>int32&nbsp;<I><FONT  color=991122 face=HELVETICA>offset</I></FONT>, <A HREF="Font.html#BFont">BFont</A>&nbsp;*<I><FONT  color=991122 face=HELVETICA>font</I></FONT>, rgb_color&nbsp;*<I><FONT  color=991122 face=HELVETICA>color</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>&nbsp;const
<P>

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>GetFontAndColor(</TT></B></FONT><A HREF="Font.html#BFont">BFont</A>&nbsp;*<I><FONT  color=991122 face=HELVETICA>font</I></FONT>, uint32&nbsp;*<I><FONT  color=991122 face=HELVETICA>sameProperties</I></FONT>, 
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rgb_color&nbsp;*<I><FONT  color=991122 face=HELVETICA>color</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT>, bool&nbsp;*<I><FONT  color=991122 face=HELVETICA>sameColor</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>&nbsp;const
<P>

</TABLE></TABLE>

<P>
These functions set and get the font and color used to display the text.  If the BTextView supports multiple character formats, <B><TT><A HREF="#SetFontAndColor()">SetFontAndColor()</A></TT></B> sets the font and color of the characters bounded by the <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> offsets.  If no offsets are given, it sets the font and color of the current selection.  However, if multiple character formats are not supported, <B><TT><A HREF="#SetFontAndColor()">SetFontAndColor()</A></TT></B> ignores the offsets and formats the entire text.
<P>
<B><TT><A HREF="#SetFontAndColor()">SetFontAndColor()</A></TT></B> works like BView's <B><TT><A HREF="Slider.html#SetFont()">SetFont()</A></TT></B> function.  It sets the font to the attributes of the <I><FONT  color=991122 face=HELVETICA>font</I></FONT> <A HREF="Font.html#BFont">BFont</A> object that are enumerated by the <I><FONT  color=991122 face=HELVETICA>properties</I></FONT> mask.  The mask is formed by combining the following constants:
<P>
<TABLE BORDER cellpadding=4>
<TD><B><TT>B_FONT_FAMILY_AND_STYLE</TT></B> </TD>
<TR>
<TD><B><TT><A HREF="misc.html#B_FONT_SIZE">B_FONT_SIZE</A></TT></B> </TD>
<TR>
<TD><B><TT><A HREF="misc.html#B_FONT_SHEAR">B_FONT_SHEAR</A></TT></B> </TD>
<TR>
<TD><B><TT><A HREF="misc.html#B_FONT_ROTATION">B_FONT_ROTATION</A></TT></B> </TD>
<TR>
<TD><B><TT><A HREF="misc.html#B_FONT_SPACING">B_FONT_SPACING</A></TT></B> </TD>
<TR>
<TD><B><TT><A HREF="misc.html#B_FONT_ENCODING">B_FONT_ENCODING</A></TT></B> </TD>
<TR>
<TD><B><TT><A HREF="misc.html#B_FONT_FACE">B_FONT_FACE</A></TT></B> </TD>
<TR>
<TD><B><TT><A HREF="misc.html#B_FONT_FLAGS">B_FONT_FLAGS</A></TT></B> </TD>
</TABLE>
<P>
In addition, <B><TT><A HREF="misc.html#B_FONT_ALL">B_FONT_ALL</A></TT></B> is a shorthand for all properties of the specified <I><FONT  color=991122 face=HELVETICA>font</I></FONT>.  However, the BTextView modifies the font to ensure that:
<P>
<UL>
<LI>Characters are not rotated.
<P>
<LI>Antialiasing is not disabled.
<P>
<LI>The spacing mode is <B><TT>B_BITMAP_SPACING</TT></B>.
<P>
<LI>The character encoding is UTF-8 (<B><TT><A HREF="misc.html#B_UNICODE_UTF8">B_UNICODE_UTF8</A></TT></B>).
<P>
</UL>
<P>
If the <I><FONT  color=991122 face=HELVETICA>font</I></FONT> argument is <B><TT>NULL</TT></B>, the font is not set and the <I><FONT  color=991122 face=HELVETICA>properties</I></FONT> mask is ignored.
<P>
The color of the characters is set by a pointer to an <B><TT><A HREF="misc.html#rgb_color">rgb_color</A></TT></B> structure.  If the pointer is <B><TT>NULL</TT></B>, as it is by default, the color is not set.
<P>
<B><TT><A HREF="#GetFontAndColor()">GetFontAndColor()</A></TT></B> gets the font and color used to display the character at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>.  It modifies the <I><FONT  color=991122 face=HELVETICA>font</I></FONT> <A HREF="Font.html#BFont">BFont</A> object and the <I><FONT  color=991122 face=HELVETICA>color</I></FONT> <B><TT><A HREF="misc.html#rgb_color">rgb_color</A></TT></B> structure so that they describe the font and color of the character.
<P>
If an <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> isn't specified, <B><TT><A HREF="#GetFontAndColor()">GetFontAndColor()</A></TT></B> looks at the current selection.  It provides a font and color description of the first character of the selection&mdash;or the character at the insertion point if the selection is empty.  It also modifies that variable that the <I><FONT  color=991122 face=HELVETICA>sameProperties</I></FONT> argument refers to so that it lists all the font properties that are uniform for all characters in the selection.  Similarly, it indicates, in the variable that <I><FONT  color=991122 face=HELVETICA>sameColor</I></FONT> refers to, whether all the characters in the selection are displayed in the same color.
<P>
<B>See also:  <TT>BView::SetFont()</TT></B> 
<P>
<HR>
<H3>
<A NAME="SetMaxBytes()"></A>SetMaxBytes()
, 
<A NAME="MaxBytes()"></A>MaxBytes()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetMaxBytes(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>max</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>MaxBytes(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
These functions set and return the maximum number of bytes that the BTextView can accept.  The default is the maximum number of bytes that can be designated by a signed 32-bit integer, a number sufficiently large to accommodate all uses of a BTextView.  Use this function only if you need to restrict the number of characters that the user can enter in a text field.
<P>
Note that these functions count bytes, not characters.
<P>
<HR>
<H3>
<A NAME="SetRunArray()"></A>SetRunArray()
, 
<A NAME="RunArray()"></A>RunArray()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetRunArray(</TT></B></FONT>int32&nbsp;<I><FONT  color=991122 face=HELVETICA>start</I></FONT>, int32&nbsp;<I><FONT  color=991122 face=HELVETICA>finish</I></FONT>, const&nbsp;text_run_array&nbsp;*<I><FONT  color=991122 face=HELVETICA>runs</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
text_run_array *<B><TT><FONT  color=000022 size=+1>RunArray(</TT></B></FONT>int32&nbsp;<I><FONT  color=991122 face=HELVETICA>start</I></FONT>, int32&nbsp;<I><FONT  color=991122 face=HELVETICA>finish</I></FONT>, int32&nbsp;*<I><FONT  color=991122 face=HELVETICA>length</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>) 
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions set and return the font and color formats of all the characters bounded by the <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> offsets.  The formats are described by a <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> structure, which has the following fields:
<P>
int32 <B><TT>count
<br>
</TT></B>The number of <B><TT>text_run</TT></B> structures in the array.
<P>
text_run <B><TT>runs</TT></B>[1]
<br>
A structure describing the font and color formats in effect at a particular offset in the BTextView's text.
<P>
The <B><TT><A HREF="misc.html#text_run">text_run</A></TT></B> structure describes a run of characters that share the same font and color formats.  It has three fields:
<P>
int32 <B><TT><A HREF="../Drivers/kernelAPI.html#partition_info">offset</A>
<br>
</TT></B>An offset to the first byte of a character in the text buffer.  The text run begins with this character; it continues until another run begins.
<P>
<A HREF="Font.html#BFont">BFont</A> <B><TT><A HREF="functions.html#font">font</A>
<br>
</TT></B>The font that's used to display the run of characters beginning at the specified offset.
<P>
rgb_color <B><TT>color
<br>
</TT></B>The color that's used to display the run of characters beginning at the specified offset. 
<P>
The first offset of the first <B><TT><A HREF="misc.html#text_run">text_run</A></TT></B> in the array passed to <B><TT><A HREF="#SetRunArray()">SetRunArray()</A></TT></B> should be&nbsp;0; the array returned by <B><TT><A HREF="#RunArray()">RunArray()</A></TT></B> also begins at offset&nbsp;0.
<P>
If the BTextView doesn't support multiple character formats, <B><TT><A HREF="#SetRunArray()">SetRunArray()</A></TT></B> ignores the <I><FONT  color=991122 face=HELVETICA>start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>finish</I></FONT> offsets and sets the entire text to the font and color of the first <B><TT><A HREF="misc.html#text_run">text_run</A></TT></B> in the array.  Similarly, <B><TT><A HREF="#RunArray()">RunArray()</A></TT></B> returns a <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> with one <B><TT><A HREF="misc.html#text_run">text_run</A></TT></B> describing the entire text.
<P>
<B><TT><A HREF="#RunArray()">RunArray()</A></TT></B> returns a pointer to memory that it allocated (using <B><TT><A HREF="../Drivers/area_malloc.html#malloc()">malloc()</A></TT></B>).  It puts the number of bytes that it allocated in the variable that the <I><FONT  color=991122 face=HELVETICA>length</I></FONT> argument points to.   Although <B><TT><A HREF="#RunArray()">RunArray()</A></TT></B> allocated the memory, the caller is responsible for freeing it when the returned <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> is no longer needed.
<P>
<B><TT><A HREF="#SetRunArray()">SetRunArray()</A></TT></B> doesn't assume responsibility for the <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> data it's passed; it's up to the caller to free it.
<P>
<B>See also:  <TT><A HREF="#SetFontAndColor()">SetFontAndColor()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="SetStylable()"></A>SetStylable()
, 
<A NAME="IsStylable()"></A>IsStylable()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetStylable(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>stylable</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>IsStylable(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
<B><TT><A HREF="#SetStylable()">SetStylable()</A></TT></B> sets whether the BTextView permits multiple character formats.  If the <I><FONT  color=991122 face=HELVETICA>stylable</I></FONT> flag is <B><TT>true</TT></B>, the functions that set the font and color of the text can apply to particular characters in the text buffer.  If the flag is <B><TT>false</TT></B>, those functions apply only to the entire text.  When <B><TT><A HREF="#SetStylable()">SetStylable()</A></TT></B> is called to turn off support for multiple formats, all the text is reformatted in the font and color of the first character.
<P>
<B><TT><A HREF="#IsStylable()">IsStylable()</A></TT></B> returns whether multiple formats are permitted.  By default, they're not.
<P>
<B>See also:  <TT><A HREF="#SetFontAndColor()">SetFontAndColor()</A></TT></B>, <B><TT><A HREF="#SetRunArray()">SetRunArray()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="SetTabWidth()"></A>SetTabWidth()
, 
<A NAME="TabWidth()"></A>TabWidth()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetTabWidth(</TT></B></FONT>float <I><FONT  color=991122 face=HELVETICA>width</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
float <B><TT><FONT  color=000022 size=+1>TabWidth(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
These functions set the distance between tab stops to <I><FONT  color=991122 face=HELVETICA>width</I></FONT> coordinate units and return the current tab width.  Tabs cannot be removed nor can they be individually set; all tabs have a uniform width.  The default tab width is 28.0 coordinate units.
<P>
<HR>
<H3>
<A NAME="SetText()"></A>SetText()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetText(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>text</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>length</I></FONT>, const&nbsp;text_run_array&nbsp;*<I><FONT  color=991122 face=HELVETICA>runs</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetText(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>text</I></FONT>, const&nbsp;text_run_array&nbsp;*<I><FONT  color=991122 face=HELVETICA>runs</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetText(</TT></B></FONT><A HREF="../The%20Storage%20Kit/File.html#BFile">BFile</A> *<I><FONT  color=991122 face=HELVETICA>file</I></FONT>, int32&nbsp;<I><FONT  color=991122 face=HELVETICA>offset</I></FONT>, int32&nbsp;<I><FONT  color=991122 face=HELVETICA>length</I></FONT>, 
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;text_run_array&nbsp;*<I><FONT  color=991122 face=HELVETICA>runs</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Removes any text currently in the BTextView and copies new text from a <I><FONT  color=991122 face=HELVETICA>text</I></FONT> buffer or from a <I><FONT  color=991122 face=HELVETICA>file</I></FONT> to replace it.  This function copies <I><FONT  color=991122 face=HELVETICA>length</I></FONT> bytes of text from the buffer&mdash;or all the bytes in the buffer, up to the null character, if a <I><FONT  color=991122 face=HELVETICA>length</I></FONT> isn't specified.  Or it copies <I><FONT  color=991122 face=HELVETICA>length</I></FONT> bytes from the <I><FONT  color=991122 face=HELVETICA>file</I></FONT> beginning at the <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> byte.  If the <I><FONT  color=991122 face=HELVETICA>text</I></FONT> or <I><FONT  color=991122 face=HELVETICA>file</I></FONT> is <B><TT>NULL</TT></B> or <I><FONT  color=991122 face=HELVETICA>length</I></FONT> is 0, it empties the BTextView without replacing the text.
<P>
If a <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> <B><TT><A HREF="misc.html#text_run_array">text_run_array</A></TT></B> is provided, it will be used to set the font and color formats of the new text&mdash;provided that the BTextView permits multiple character formats.  If not, the <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> array is ignored.
<P>
The BTextView doesn't assume ownership of the <I><FONT  color=991122 face=HELVETICA>text</I></FONT> buffer, the <I><FONT  color=991122 face=HELVETICA>file</I></FONT>, or the <I><FONT  color=991122 face=HELVETICA>runs</I></FONT> array; you can delete them when <B><TT><A HREF="#SetText()">SetText()</A></TT></B> returns.
<P>
Text taken from a file is inserted directly into the text, bypassing the <B><TT><A HREF="#InsertText()">InsertText()</A></TT></B> function.  In other words, you won't receive an <B><TT><A HREF="#InsertText()">InsertText()</A></TT></B> notification for text taken from a file.
<P>
This function is typically used to set the text initially displayed in the view.  If the BTextView is already attached to a window, it's updated to show its new contents.
<P>
<B>See also:  <TT><A HREF="#Text()">Text()</A></TT></B>, <B><TT><A HREF="#TextLength()">TextLength()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="SetTextRect()"></A>SetTextRect()
, 
<A NAME="TextRect()"></A>TextRect()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetTextRect(</TT></B></FONT><A HREF="Rect.html#BRect">BRect</A> <I><FONT  color=991122 face=HELVETICA>rect</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
<A HREF="Rect.html#BRect">BRect</A> <B><TT><FONT  color=000022 size=+1>TextRect(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const 
<P>

</TABLE></TABLE>

<P>
<B><TT><A HREF="#SetTextRect()">SetTextRect()</A></TT></B> makes <I><FONT  color=991122 face=HELVETICA>rect</I></FONT> the BTextView's text rectangle&mdash;the rectangle that locates where text is placed within the view.  This replaces the text rectangle originally set in the BTextView constructor.  The layout of the text is recalculated to fit the new rectangle, and the text is redisplayed.
<P>
<B><TT><A HREF="#TextRect()">TextRect()</A></TT></B> returns the current text rectangle.
<P>
<B>See also:  </B>the BTextView constructor
<P>
<HR>
<H3>
<A NAME="SetWordWrap()"></A>SetWordWrap()
, 
<A NAME="DoesWordWrap()"></A>DoesWordWrap()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetWordWrap(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>flag</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>DoesWordWrap(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
These functions set and return whether the BTextView wraps lines on word boundaries, thus pushing entire words that don't fit at the end of a line to the next line.  When word wrapping is turned on, the BTextView calls <B><TT><A HREF="#CanEndLine()">CanEndLine()</A></TT></B> to determine exactly where a line can break.  If word wrapping is off, lines break only on a newline character (where the user types Return).
<P>
By default, word wrapping is turned on (<B><TT><A HREF="#DoesWordWrap()">DoesWordWrap()</A></TT></B> returns <B><TT>true</TT></B>).  
<P>
<B>See also:  <TT><A HREF="#SetTextRect()">SetTextRect()</A></TT></B>, <B><TT><A HREF="#CanEndLine()">CanEndLine()</A></TT></B> 
<P>
<HR>
<H3>TabWidth()   see <A HREF="#SetTabWidth()">SetTabWidth()</A></H3>
<P>
<HR>
<H3>
<A NAME="Text()"></A>Text()
, 
<A NAME="GetText()"></A>GetText()
, 
<A NAME="ByteAt()"></A>ByteAt()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
const char *<B><TT><FONT  color=000022 size=+1>Text(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>&nbsp;const
<P>


<TR><TD>
void <B><TT><FONT  color=000022 size=+1>GetText(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>length</I></FONT>, char *<I><FONT  color=991122 face=HELVETICA>buffer</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>


<TR><TD>
uchar <B><TT><FONT  color=000022 size=+1>ByteAt(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>offset</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
These functions reveal the text contained in the BTextView.
<P>
<B><TT><A HREF="#Text()">Text()</A></TT></B> returns a pointer to the text, which may be a pointer to an empty string if the BTextView is empty.  The returned pointer can be used to read the text, but not to alter it (use <B><TT><A HREF="#SetText()">SetText()</A></TT></B>, <B><TT><A HREF="#Insert()">Insert()</A></TT></B>, <B><TT><A HREF="#Delete()">Delete()</A></TT></B>, and other BTextView functions to do that).
<P>
<B><TT><A HREF="#GetText()">GetText()</A></TT></B> copies up to <I><FONT  color=991122 face=HELVETICA>length</I></FONT> bytes of the text into <I><FONT  color=991122 face=HELVETICA>buffer</I></FONT>, beginning with the byte at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>, and adds a null terminator ('0').  Fewer than <I><FONT  color=991122 face=HELVETICA>length</I></FONT> bytes are copied if there aren't that many between the specified <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> and the end of the text.   This function doesn't make any attempt to ensure that only full character specifications are copied; it's up to the caller to make sure that a character begins at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> and that the last byte copied isn't in the middle of a multibyte character.  The results won't be reliable if the <I><FONT  color=991122 face=HELVETICA>offset</I></FONT> is out-of-range.
<P>
<B><TT><A HREF="#ByteAt()">ByteAt()</A></TT></B> returns the byte located at <I><FONT  color=991122 face=HELVETICA>offset</I></FONT>.  The offset doesn't have to be to the first byte of a character.
<P>
The pointer that <B><TT><A HREF="#Text()">Text()</A></TT></B> returns is to the BTextView's internal representation of the text.  When it returns, the text string is guaranteed to be null-terminated and without gaps.  However, the BTextView may have had to manipulate the text to get it in that condition.  Therefore, there may be a performance price to pay if <B><TT><A HREF="#Text()">Text()</A></TT></B> is called frequently.  If you're going to copy the text, it's more efficient to have <B><TT><A HREF="#GetText()">GetText()</A></TT></B> do it for you.  If you're going to index into the text, it may be more efficient to call <B><TT><A HREF="#ByteAt()">ByteAt()</A></TT></B>.
<P>
The pointer that <B><TT><A HREF="#Text()">Text()</A></TT></B> returns may no longer be valid after the user or the program next changes the text.  Even if valid, the string may no longer be null-terminated and gaps may appear.
<P>
<B>See also:  <TT><A HREF="#TextLength()">TextLength()</A></TT></B> 
<P>
<HR>
<H3>TextHeight()   see <A HREF="#LineHeight()">LineHeight()</A></H3>
<P>
<HR>
<H3>
<A NAME="TextLength()"></A>TextLength()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>TextLength(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Returns the number of bytes of text data the BTextView currently contains&mdash;the number of bytes in the string that <B><TT><A HREF="#Text()">Text()</A></TT></B> returns (not counting the null terminator).
<P>
<B>See also:  <TT><A HREF="#Text()">Text()</A></TT></B>, <B><TT><A HREF="#SetMaxBytes()">SetMaxBytes()</A></TT></B> 
<P>
<HR>
<H3>TextRect()   see <A HREF="#SetTextRect()">SetTextRect()</A></H3>
<P>
<HR>
<H3>
<A NAME="SetDoesUndo()"></A>SetDoesUndo()
, 
<A NAME="DoesUndo()"></A>DoesUndo()
, 
<A NAME="UndoState()"></A>UndoState()
, 
<A NAME="Undo()"></A>Undo()
, 
<A NAME="undo_state"></A>undo_state
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetDoesUndo(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>sayIt</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>DoesUndo(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>


<TR><TD>
undo_state <B><TT><FONT  color=000022 size=+1>UndoState(</TT></B></FONT>bool *<I><FONT  color=991122 face=HELVETICA>isRedo</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>


<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Undo(</TT></B></FONT><A HREF="../The%20Application%20Kit/Clipboard.html#BClipboard">BClipboard</A> *<I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
enum <B><TT><FONT  color=000022 size=+1>undo_state {}
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions and enum comprise BTextView's undo world.  The operations that BTextView can undo are described in the <B><TT>undo_state</TT></B> table, below.  The default undo mechanism is one operation deep:  Udoing undoes the previous (undo-able) operation; a second (immediate) undo redoes the operation.   
<P>
You call <B><TT>SetDoesUndo()</TT></B> to enable or disable the undo machinery for this object.  By default, undo is enabled.  The ability to undo is also controlled by the object's editability (<B><TT><A HREF="#MakeEditable()">MakeEditable()</A></TT></B>), but this is a tautology, since in order to have something to undo you have to have been able to edit the object in the first place.
<P>
<B><TT>DoesUndo()</TT></B> tells you whether the object is "undoable" as set by <B><TT>SetDoesUndo()</TT></B>. It doesn't take editability into consideration.
<P>
UndoState() tells you what the previous action was (as represented by the constants listed below).  This is the action that will be undone if the object is told to undo.  The <I><FONT  color=991122 face=HELVETICA>isRedo</I></FONT> value that's returned by reference is set to <B><TT>true</TT></B> if the previous action occurred because of an undo.
<P>
<TABLE BORDER cellpadding=4>
<TH>Constant</TH>
<TH>Meaning</TH>
<TR>
<TD><B><TT>B_UNDO_UNAVAILABLE</TT></B></TD>
<TD>Nothing to undo</TD>
<TR>
<TD><B><TT>B_UNDO_TYPING</TT></B></TD>
<TD>Text was inserted or deleted</TD>
<TR>
<TD><B><TT>B_UNDO_CUT</TT></B></TD>
<TD>Selection was cut</TD>
<TR>
<TD><B><TT>B_UNDO_PASTE</TT></B></TD>
<TD>Text was pasted</TD>
<TR>
<TD><B><TT>B_UNDO_CLEAR</TT></B></TD>
<TD>Selection was cleared</TD>
<TR>
<TD><B><TT>B_UNDO_DROP</TT></B></TD>
<TD>Message was dropped</TD>
</TABLE>
<P>
The <B><TT>Undo()</TT></B> hook function is called when the BTextView receives a <B><TT>B_UNDO</TT></B> message.  (By default, <B><TT>B_UNDO</TT></B> is bound to the window's Command+z shortcut; Undo menu items need to set up the binding explicitly.)  The <I><FONT  color=991122 face=HELVETICA>clipboard</I></FONT> argument is a pointer to the <B><TT><A HREF="../The%20Application%20Kit/misc.html#be_clipboard">be_clipboard</A></TT></B>; if you're using a custom clipboard in your BTextView subclass, you should pass along your clipboard when you invoke the inherited version of <B><TT>Undo()</TT></B>.
<P>
Don't try to do too much in a subclass implementation of Undo().  In particular, you probably won't get too far if you're trying to "broaden" the undo tree.  
<P>
<HR>
<H3>Undo()   see <A HREF="#SetDoesUndo()">SetDoesUndo()</A></H3>
<P>
<HR>
<H3>UndoState()   see <A HREF="#SetDoesUndo()">SetDoesUndo()</A></H3>
<P>
<HR>
<H3>
<A NAME="WindowActivated()"></A>WindowActivated()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>WindowActivated(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>flag</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Highlights the current selection when the BTextView's window becomes the active window (when <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> is <B><TT>true</TT></B>)&mdash;provided that the BTextView is the current focus view&mdash;and removes the highlighting when the window ceases to be the active window (when <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> is <B><TT>false</TT></B>).
<P>
If the current selection is empty (if it's an insertion point), it's highlighted by turning the caret on and off (blinking it).
<P>
The Interface Kit calls this function for you whenever the BTextView's window becomes the active window or it loses that status.
<P>
<B>See also:  <TT>BView::WindowActivated()</TT></B>, <B><TT><A HREF="#MakeFocus()">MakeFocus()</A></TT></B> 
<P>
<HR>
<H2>
<A NAME="Scripting%20Support"></A><FONT SIZE=6>S</FONT>cripting <FONT SIZE=6>S</FONT>upport
</H2>
<P>
The BTextView class implements an unnamed suite consisting of the following messages: 
<P>
<HR>
<H3>
<A NAME="The%20Selection%20Property"></A>The Selection Property
</H3>
<P>
<TABLE BORDER cellpadding=4>
<TH>Message</TH>
<TH>Specifiers</TH>
<TH>Meaning</TH>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_GET_PROPERTY">B_GET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DIRECT_SPECIFIER">B_DIRECT_SPECIFIER</A></TT></B></TD>
<TD>Returns the current selection.</TD>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_SET_PROPERTY">B_SET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DIRECT_SPECIFIER">B_DIRECT_SPECIFIER</A></TT></B></TD>
<TD>Sets the current selection.</TD>
</TABLE>
<P>
Using two int32 offsets to the beginning and end of the selection in either the "result" or "data" arrays, these messages convey the current selection of the object in a manner identical to <B><TT><A HREF="#GetSelection()">GetSelection()</A></TT></B> and <B><TT><A HREF="#Select()">Select()</A></TT></B>.
<P>
<HR>
<H3>
<A NAME="The%20Text%20Property"></A>The Text Property
</H3>
<P>
<TABLE BORDER cellpadding=4>
<TH>Message</TH>
<TH>Specifiers</TH>
<TH>Meaning</TH>
<TR>
<TD><B><TT>B_COUNT_PROPERTY</TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DIRECT_SPECIFIER">B_DIRECT_SPECIFIER</A></TT></B></TD>
<TD>Returns the length of the text in bytes.</TD>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_GET_PROPERTY">B_GET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_RANGE_SPECIFIER">B_RANGE_SPECIFIER</A>,
<br>
B_REVERSE_RANGE_SPECIFIER</TT></B></TD>
<TD>Returns the text in the specified range in the BTextView.</TD>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_SET_PROPERTY">B_SET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_RANGE_SPECIFIER">B_RANGE_SPECIFIER</A>,
<br>
B_REVERSE_RANGE_SPECIFIER</TT></B></TD>
<TD>Removes or inserts text into the specified range in the BTextView.</TD>
</TABLE>
<P>
The "Text" get and set messages correspond to the methods <B><TT><A HREF="#GetText()">GetText()</A></TT></B> and <B><TT><A HREF="#SetText()">SetText()</A></TT></B>, using a C string to store the data.  If the <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_SET_PROPERTY">B_SET_PROPERTY</A></TT></B> message lacks a "data" member, the selection is deleted; otherwise, "range" bytes are inserted at offset "index."  The values specifying the range are given in byte  rather than character offsets.  The range counts towards the end of the text, even for <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_REVERSE_RANGE_SPECIFIER">B_REVERSE_RANGE_SPECIFIER</A></TT></B>.
<P>
<HR>
<H3>
<A NAME="The%20text_run_array%20Property"></A>The text_run_array Property
</H3>
<P>
<TABLE BORDER cellpadding=4>
<TH>Message</TH>
<TH>Specifiers</TH>
<TH>Meaning</TH>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_GET_PROPERTY">B_GET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_RANGE_SPECIFIER">B_RANGE_SPECIFIER</A>,
<br>
B_REVERSE_RANGE_SPECIFIER</TT></B></TD>
<TD>Returns the style information for the text in the specified range in the BTextView.</TD>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_SET_PROPERTY">B_SET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_RANGE_SPECIFIER">B_RANGE_SPECIFIER</A>,
<br>
B_REVERSE_RANGE_SPECIFIER</TT></B></TD>
<TD>Sets the style information for the text in the specified range in the BTextView.</TD>
</TABLE>
<P>
These messages correspond to the methods <B><TT><A HREF="#RunArray()">RunArray()</A></TT></B> and <B><TT><A HREF="#SetRunArray()">SetRunArray()</A></TT></B>, storing the result as a <B><TT><A HREF="../The%20Support%20Kit/misc.html#B_RAW_TYPE">B_RAW_TYPE</A></TT></B>.  As with the "Text" property, the values specifying the range are given in byte  rather than character offsets.  The range counts towards the end of the text, even for <B><TT><A HREF="../The%20Application%20Kit/misc.html#B_REVERSE_RANGE_SPECIFIER">B_REVERSE_RANGE_SPECIFIER</A></TT></B>.
<P>
<HR>
<H2>
<A NAME="Archived%20Fields"></A><FONT SIZE=6>A</FONT>rchived <FONT SIZE=6>F</FONT>ields
</H2>
<P>
The <B><TT><A HREF="#Archive()">Archive()</A></TT></B> function adds the following fields to its <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> argument:
<P>
<TABLE BORDER cellpadding=4>
<TH><B>Field</B></TH>
<TH><B>Type code</B></TH>
<TH><B>Meaning</TH>
<TR>
<TD></B>"_text"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_STRING_TYPE">B_STRING_TYPE</A></TT></B></TD>
<TD>The BTextView's text.</TD>
<TR>
<TD>"_align"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD>The text <B><TT><A HREF="misc.html#alignment">alignment</A></TT></B>.</TD>
<TR>
<TD>"_tab"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_FLOAT_TYPE">B_FLOAT_TYPE</A></TT></B></TD>
<TD>The tab width.</TD>
<TR>
<TD>"_col_sp"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD>Color space.</TD>
<TR>
<TD>"_trect"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_RECT_TYPE">B_RECT_TYPE</A></TT></B></TD>
<TD>The text rectangle.</TD>
<TR>
<TD>"_max" </TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD>The maximum size (<I>a la</I><B><TT> <A HREF="#SetMaxBytes()">SetMaxBytes()</A></TT></B>).</TD>
<TR>
<TD>"_sel" (array)</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD>index 0: selection start;  index 1: selection end</TD>
<TR>
<TD>"_dis_ch" (array)</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_RAW_TYPE">B_RAW_TYPE</A></TT></B></TD>
<TD>Disallowed characters.</TD>
<TR>
<TD>"_runs"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_RAW_TYPE">B_RAW_TYPE</A></TT></B></TD>
<TD>Flattened run array.</TD>
<TR>
<TD>"_stylable"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD><B><TT>true</TT></B> == is stylable.</TD>
<TR>
<TD>"_auto_in" </TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD><B><TT>true</TT></B> == autoindent on</TD>
<TR>
<TD>"_wrap"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD><B><TT>true</TT></B> == word wrapping on</TD>
<TR>
<TD>"_nsel"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD><B><TT>true</TT></B> == not selectable</TD>
<TR>
<TD>"_nedit"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD><B><TT>true</TT></B> == not editable</TD>
</TABLE>
<P>
Some of these fields may not be present if the setting they represent isn't used, or is the default value.  For example, if word wrapping is off, the "_wrap" field won't be found in the archive.
<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Interface Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Interface%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Interface Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

