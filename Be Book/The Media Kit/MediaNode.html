<HTML><HEAD><TITLE>The Media Kit: BMediaNode</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Media Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Media%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Media Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="BMediaNode"></A>BMediaNode
</H1>
<P>
Derived from:  none
<P>
Declared in:  <A HREF="/boot/develop/headers/be/media/MediaNode.h">be/media/MediaNode.h</A>
<P>
Library:  libmedia.so
<P>
Allocation:  Constructor only
<P>
<H6><A HREF="MediaNode.summary.html"><i>Summary</i></A></H6>
<P>
The BMediaNode class is the superclass of all participant nodes in the Media Kit.  However, you'll never derive directly from BMediaNode; instead, you'll derive from one of the system interface classes which in turn are derived from BMediaNode.  Look at the documentation for those other classes (such as <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A> and BBufferConsumer) for details on how they're used, or see &nbsp;<a href="Intro.html#Creating%20New%20Node%20Classes%20on%20page16">"Creating New Node Classes" on page16</a> for discussion on how this is done.
<P>
Because of the quirks of virtual inheritance (required by the use of multiple inheritance), your node's constructor will have to call the BMediaNode constructor.  &nbsp;<a href="Intro.html#See%20About%20Multiple%20Virtual%20Inheritance%20on%20page21.">See "About Multiple Virtual Inheritance" on page21.</a>
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Applications shouldn't call a node's member functions directly; instead, you call the <A HREF="MediaRoster.html#BMediaRoster">BMediaRoster</A> with a reference to the node and let the request come to the node through the control port.  The only exception is if the node is subclassed directly within the application, in which case <B><TT><A HREF="#Acquire()">Acquire()</A></TT></B>, <B><TT><A HREF="#ID()">ID()</A></TT></B>, <B><TT><A HREF="#Node()">Node()</A></TT></B>, and <B><TT><A HREF="#Release()">Release()</A></TT></B> can be called directly once the node is registered&mdash;if you do this, be sure you don't call them after the node is destroyed.
<P>
</UL>
<P>
Calling a node's member functions directly from outside the node itself can result in the chain of functions involved in coordinating nodes to be called out of order.  Worse, deadlock can result.  So just don't do it, even if you think you've found a safe way to pull it off.
<P>
<HR>
<H2>
<A NAME="Creating%20Your%20Own%20Node"></A><FONT SIZE=6>C</FONT>reating <FONT SIZE=6>Y</FONT>our <FONT SIZE=6>O</FONT>wn <FONT SIZE=6>N</FONT>ode
</H2>
<P>
<HR>
<H3>
<A NAME="Realtime%20Allocators%20and%20Thread%20Locking"></A>Realtime Allocators and Thread Locking
</H3>
<P>
Media nodes are highly timing-sensitive creatures.  The slightest delay in performing their work can cause drastic problems in media playback or recording quality.  Virtual memory, normally of great benefit to users, can work against them when doing media work.  A poorly-timed virtual memory hit can cause breaks in media performances.
<P>
The realtime memory allocation and locking functions provide a means for nodes to lock down their memory to prevent it from being cached to disk by the virtual memory system.  This avoids situations in which the node has to pause while it or its memory is fetched back from the swap file.
<P>
The user can use the Media preference application to configure what types of nodes should use locked memory.  Nodes should typically use the realtime memory allocation functions instead of <B><TT><A HREF="../Drivers/area_malloc.html#malloc()">malloc()</A></TT></B> and <B><TT><A HREF="../Drivers/area_malloc.html#free()">free()</A></TT></B>.  <B><TT><A HREF="RealtimeAlloc.html#rtm_alloc()">rtm_alloc()</A></TT></B> will automatically handle locking the memory if the <B><TT>B_MEDIA_REALTIME_ALLOCATOR</TT></B> flag is set, so your node doesn't have to worry about it.
<P>
In addition, if the realtime flag corresponding to the type of node you're writing is set, your node should also call <B><TT>media_init_realtime_thread()</TT></B> to lock down the stacks of its threads.  Properly-written nodes can always call <B><TT>media_init_realtime_thread()</TT></B>, without checking the realtime flags, because this function will return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_MEDIA_REALTIME_DISABLED">B_MEDIA_REALTIME_DISABLED</A></TT></B> if the corresponding flag isn't set.  You can simply ignore the error and move on.
<P>
For example:
<P>
<PRE>&nbsp;&nbsp;&nbsp;int32 *myThreadData = rtm_alloc(4096);
&nbsp;&nbsp;&nbsp;myThread = spawn_thread(myThreadFunction, "Node Thread", B_NORMAL_PRIORITY,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;myThreadData);
&nbsp;&nbsp;&nbsp;status_t err = media_realtime_init_thread(myThread, 32768,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B_MEDIA_REALTIME_VIDEO);
&nbsp;&nbsp;&nbsp;if (err != B_OK &amp;&amp; err != B_MEDIA_REALTIME_DISABLED) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Can't lock down the thread.n");
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;...</PRE>
<P>
If your node requires realtime performance from an add-on or shared library, you can use the <B><TT>media_init_realtime_image()</TT></B> function to lock down that image in memory.  Note, however, that any uses of <B><TT><A HREF="../Drivers/area_malloc.html#malloc()">malloc()</A></TT></B> by that image won't allocate locked memory; you can't control that.  Still, locking down the image itself can help performance even further.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Standard BeOS system libraries are Be's responsibility.  If it's appropriate for them to be locked, they're locked for you.  Don't lock them yourself.  Both libmedia.so and libroot.so have <B><TT>media_init_realtime_image()</TT></B> called on them.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="Negotiating%20a%20Connection"></A>Negotiating a Connection
</H3>
<P>
Establishing a connection between two nodes is a multi-step process.  The nodes need to agree upon a data format they both support before the connection can even be established.
<P>
<H4>
<A NAME="Special%20Considerations"></A>Special Considerations
</H4>
<P>
If the node you're writing could be connected by the system mixer (using the Audio preference application, for example) as the default output, the node needs to be as flexible as possible in terms of the formats it accepts on its free inputs in the <B><TT><A HREF="BufferConsumer.html#GetNextInput()">GetNextInput()</A></TT></B> function.  The format your node returns from <B><TT><A HREF="BufferConsumer.html#GetNextInput()">GetNextInput()</A></TT></B> will be used as the starting poing in the negotiation process; the more wildcards you support, the better.
<P>
An application that wants to establish a connection between some other node and your node will determine the format from the inputs into your node and the outputs from the other node, then call <B><TT><A HREF="MediaRoster.html#Connect()">BMediaRoster::Connect()</A></TT></B> with that format.
<P>
If there are any wildcards in the format passed to <B><TT>BMediaRoster::Format()</TT></B>, the media roster will call <B><TT>BBufferProducer::ProposeFormat()</TT></B> in the node being connected to your output node; the producer will specialize the wildcards to construct the least-specific format that will guarantee that any remaining wildcards can be specialized by your node without becoming incompatible with the producer.
<P>
The resulting format may have some wildcards left (or, if the producer is particularly picky, there may be none at all).  The media roster will then pass this format to your consumer node's <B><TT><A HREF="BufferConsumer.html#AcceptFormat()">BBufferConsumer::AcceptFormat()</A></TT></B> function.  This function should be implemented to specialize the remaining wildcards and return this format, which should describe a specific format.  This format will be used to establish the connection.
<P>
<HR>
<H2>
<A NAME="Hook%20Functions"></A><FONT SIZE=6>H</FONT>ook <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<UL>
<LI><B><TT><A HREF="#AddOn()">AddOn()</A>
<P>
</TT></B><LI><B><TT><A HREF="#AddTimer()">AddTimer()</A>
<P>
</TT></B><LI><B><TT><A HREF="#ControlPort()">ControlPort()</A>
<P>
</TT></B><LI><B><TT><A HREF="#DeleteHook()">DeleteHook()</A>
<P>
</TT></B><LI><B><TT><A HREF="#GetNodeAttributes()">GetNodeAttributes()</A>
<P>
</TT></B><LI><B><TT><A HREF="#HandleMessage()">HandleMessage()</A>
<P>
</TT></B><LI><B><TT><A HREF="#NodeRegistered()">NodeRegistered()</A>
<P>
</TT></B><LI><B><TT><A HREF="#Preroll()">Preroll()</A>
<P>
</TT></B><LI><B><TT><A HREF="#RequestCompleted()">RequestCompleted()</A>
<P>
</TT></B><LI><B><TT><A HREF="#Seek()">Seek()</A>
<P>
</TT></B><LI><B><TT><A HREF="#SetRunMode()">SetRunMode()</A>
<P>
</TT></B><LI><B><TT><A HREF="#SetTimeSource()">SetTimeSource()</A>
<P>
</TT></B><LI><B><TT><A HREF="#Start()">Start()</A>
<P>
</TT></B><LI><B><TT><A HREF="#Stop()">Stop()</A>
<P>
</TT></B><LI><B><TT><A HREF="#TimeWarp()">TimeWarp()</A>
<P>
</TT></B></UL>
<P>
<HR>
<H2>
<A NAME="Constructor%20and%20Destructor"></A><FONT SIZE=6>C</FONT>onstructor and <FONT SIZE=6>D</FONT>estructor
</H2>
<P>
<HR>
<H3>
<A NAME="BMediaNode()"></A>BMediaNode()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
explicit <B><TT><FONT  color=000022 size=+1>BMediaNode(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>name</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
Call this from your derived node's constructor.
<P>
The node is created with a reference count of 1; the count is incremented each time the <B><TT>Acquire()</TT></B> call is issued, and decremented each time <B><TT><A HREF="#Release()">Release()</A></TT></B> is called.  When the reference count becomes zero, the node is deleted.
<P>
<HR>
<H3>
<A NAME="~BMediaNode"></A>~BMediaNode
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>~BMediaNode()</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
You may never delete a BMediaNode because you don't know for certain when the Media Server is done with it.  Instead, the Media Server maintains a reference count for the node, and when it is no longer in use, the node will be deleted automatically.
<P>
<HR>
<H2>
<A NAME="Member%20Functions"></A><FONT SIZE=6>M</FONT>ember <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="Acquire()"></A>Acquire()
, 
<A NAME="Release()"></A>Release()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
BMediaNode *<B><TT><FONT  color=000022 size=+1>Acquire(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
BMediaNode *<B><TT><FONT  color=000022 size=+1>Release(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>Acquire()</TT></B> returns a pointer to the node, after incrementing the node's reference count.
<P>
<B><TT>Release()</TT></B> releases the node by decrementing its reference count.  If the count reaches zero, the node is deleted and <B><TT>NULL</TT></B> is returned; otherwise, a pointer to the node is returned.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Although you usually can't call node member functions directly from within an application, you can call <B><TT>Acquire()</TT></B> and <B><TT>Release()</TT></B> directly if the node is subclassed within the application itself (rather than in an add-on).
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="AddNodeKind()"></A>AddNodeKind()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>AddNodeKind(</TT></B></FONT>uint64 <I><FONT  color=991122 face=HELVETICA>kind</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
Adds a kind to the set of kinds supported by the node.  This lets the system know what types of node interfaces are supported by the node's implementation.  Possible values include <B><TT><A HREF="#B_BUFFER_PRODUCER">B_BUFFER_PRODUCER</A></TT></B> (which indicates that the node implements the <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A> protocol) and <B><TT><A HREF="#B_PHYSICAL_INPUT">B_PHYSICAL_INPUT</A></TT></B> (which indicates that the node implements a physical input, such as a sound digitizing input device).  For a complete list of kind values, see &nbsp;<a href="#node_kind%20on%20page181">"node_kind" on page181</a>.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
In general, you don't need to call this function.  The base system classes call <B><TT>AddNodeKind()</TT></B> automatically to set up the node type flags; for example, a <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A> automatically calls <B><TT>AddNodeKind(B_BUFFER_PRODUCER)</TT></B>.  The only time it's necessary go call AddNodeKind() is if the node you're implementing is a physical device or a mixer, in which case you need to add the <B><TT><A HREF="#B_PHYSICAL_INPUT">B_PHYSICAL_INPUT</A></TT></B>, <B><TT><A HREF="#B_PHYSICAL_OUTPUT">B_PHYSICAL_OUTPUT</A></TT></B>, or <B><TT><A HREF="#B_SYSTEM_MIXER">B_SYSTEM_MIXER</A></TT></B> flag.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="AddOn()"></A>AddOn()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual <A HREF="MediaAddOn.html#BMediaAddOn">BMediaAddOn</A> *<B><TT><FONT  color=000022 size=+1>AddOn(</TT></B></FONT>int32 *<I><FONT  color=991122 face=HELVETICA>outInternalID</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const = 0
<P>

</TABLE></TABLE>

<P>
Implement this function to return a pointer to the <A HREF="MediaAddOn.html#BMediaAddOn">BMediaAddOn</A> that instantiated the node.  If the node lives in an application (rather than in an add-on), return <B><TT>NULL</TT></B>.  If the node is in an add-on, <I><FONT  color=991122 face=HELVETICA>outInternalID</I></FONT> should be changed to contain the internal ID number of the node within the add-on.
<P>
<HR>
<H3>
<A NAME="AddTimer()"></A>AddTimer()
, 
<A NAME="TimerExpired()"></A>TimerExpired()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>AddTimer(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>toPerformanceTime</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>TimerExpired(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>notifyPoint</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT>, status_t <I><FONT  color=991122 face=HELVETICA>error</I></FONT> = <FONT  face=HELVETICA>B_OK</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Your node should implement the <B><TT>AddTimer()</TT></B> function to remember the <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT> and time given.  When the time <I><FONT  color=991122 face=HELVETICA>toPerformanceTime</I></FONT> is reached, your node should call <B><TT>TimerExpired()</TT></B> with the corresponding <I><FONT  color=991122 face=HELVETICA>cookie</I></FONT> value, passing the recorded <I><FONT  color=991122 face=HELVETICA>toPerformanceTime</I></FONT> value as the <I><FONT  color=991122 face=HELVETICA>notifyPoint</I></FONT> argument.  This will, in turn, cause the <B><TT><A HREF="MediaRoster.html#SyncToNode()">BMediaRoster::SyncToNode()</A></TT></B> call that instigated the timer to return to the caller.
<P>
Your implementation of <B><TT>AddTimer()</TT></B> should return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> if all is well; otherwise it should return an appropriate error code.
<P>
<HR>
<H3>
<A NAME="ControlPort()"></A>ControlPort()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual port_id <B><TT><FONT  color=000022 size=+1>ControlPort(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>) </TT></B></FONT>const = 0
<P>

</TABLE></TABLE>

<P>
Returns the port_id of the port to which the node listens for requests.  Your node must implement this to return a valid Kernel Kit port.
<P>
<HR>
<H3>
<A NAME="DeleteHook()"></A>DeleteHook()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>DeleteHook(</TT></B></FONT>BMediaNode *<I><FONT  color=991122 face=HELVETICA>node</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
The <B><TT>DeleteHook()</TT></B> function is called to delete the BMediaNode object.  You may augment this if you need to perform additional work before the node is deleted, but you should always either include the line:
<P>
<PRE>&nbsp;&nbsp;&nbsp;delete this;</PRE>
<P>
or you should call through to the inherited form of the function.  Return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> if the node was deleted successfully, otherwise return an appropriate error code.
<P>
<HR>
<H3>
<A NAME="GetNodeAttributes()"></A>GetNodeAttributes()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>GetNodeAttributes(</TT></B></FONT>media_node_attribute *<I><FONT  color=991122 face=HELVETICA>outAttributes</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t <I><FONT  color=991122 face=HELVETICA>inMaxCount</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Implement this function to fill the <I><FONT  color=991122 face=HELVETICA>outAttributes</I></FONT> array (which has room for <I><FONT  color=991122 face=HELVETICA>inMaxCount</I></FONT> attributes) with your node's attributes.
<P>
Return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> if all is well, or return an appropriate error code.
<P>
<HR>
<H3>
<A NAME="HandleBadMessage()"></A>HandleBadMessage()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>HandleBadMessage(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>message</I></FONT>, const void *<I><FONT  color=991122 face=HELVETICA>data</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
If your node receives a message that neither the node, nor any interface from which the node is derived, understands the message, pass the message along to this function, which will work magic to deal with the problem one way or another.  All arguments received by the <B><TT><A HREF="#HandleMessage()">HandleMessage()</A></TT></B> function should be passed directly through to <B><TT>HandleBadMessage()</TT></B>.
<P>
<A NAME="HandleMessage()"></A>
<P>
<HR>
<H3>
<A NAME="HandleMessage()"></A>HandleMessage()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>HandleMessage(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>message</I></FONT>, const void *<I><FONT  color=991122 face=HELVETICA>data</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Given a message received on the control port, this function dispatches the message to the appropriate BMediaNode hook function.  If the message doesn't correspond to a hook function, <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B> is returned.
<P>
When you implement a media node of your own (derived from <A HREF="BufferConsumer.html#BBufferConsumer">BBufferConsumer</A>, <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A>, etc), you always need to call through to <B><TT><A HREF="#BMediaNode::HandleMessage()">BMediaNode::HandleMessage()</A></TT></B> from your node's implementation of <B><TT>HandleMessage()</TT></B>.  This is crucial, to be sure that every ancestor of your node gets to look at the message and attempt to process it.
<P>
For example, if your node inherits from both <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A> and <A HREF="BufferConsumer.html#BBufferConsumer">BBufferConsumer</A>, you should call <B><TT><A HREF="BufferProducer.html#HandleMessage()">BBufferProducer::HandleMessage()</A></TT></B> and <B><TT><A HREF="BufferConsumer.html#HandleMessage()">BBufferConsumer::HandleMessage()</A></TT></B>, then <B><TT><A HREF="#BMediaNode::HandleMessage()">BMediaNode::HandleMessage()</A></TT></B>, like this:
<P>
<PRE>&nbsp;&nbsp;&nbsp;virtual status_t MyBufferProducerConsumer::HandleMessage(int32 message,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void *data, size_t size) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (code == SOME_THING_I_DO) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoWhatever();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (BBufferConsumer::HandleMessage(message, data, size) &amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BBufferProducer::HandleMessage(message, data, size) &amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BMediaNode::HandleMessage(message, data, size)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BMediaNode::HandleBadMessage(message, data, size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}</PRE>
<P>
Note that <B><TT><A HREF="#BMediaNode::HandleBadMessage()">BMediaNode::HandleBadMessage()</A></TT></B> is called if none of the <B><TT>HandleMessage()</TT></B> implementations accept the message.
<P>
Values of <I><FONT  color=991122 face=HELVETICA>code</I></FONT> between 0x60000000 and 0x7FFFFFFF are available for use by applications.  Values below 0x60000000 are reserved for use by the Media Kit, and typically correspond to specific virtual hook functions within your node.  If you can show just cause for needing to know the <I><FONT  color=991122 face=HELVETICA>code</I></FONT> value for a particular hook, you can try emailing devsupport@be.com and see if we agree with you, in which case we may share that information.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
Don't reverse-engineer the <I><FONT  color=991122 face=HELVETICA>code</I></FONT> values; if you really need to know, ask us.  Otherwise, we won't know that a particular code shouldn't be changed.  In general, it's a bad idea to rely on specific values, although there may be cases in which it's necessary.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The message was dispatched.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  The message couldn't be dispatched, possibly because it doesn't correspond to a hook function.
<P>
</UL>
<P>
<HR>
<H3>HitSyncPoint() see <A HREF="../The%20Interface%20Kit/ViewDrawing.html#Sync()">Sync()</A></H3>
<P>
<HR>
<H3>
<A NAME="ID()"></A>ID()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
media_node_id <B><TT><FONT  color=000022 size=+1>ID</TT></B></FONT><B><TT><FONT  color=000022 size=+1>(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>) </TT></B></FONT>const
<P>

</TABLE></TABLE>

<P>
Returns the media_node_id assigned to the node by the Media Server.  The result is 0 if the node hasn't been registered yet, and negative if an error occurred while attempting to register the node.
<P>
<HR>
<H3>
<A NAME="Kinds()"></A>Kinds()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
uint64 <B><TT><FONT  color=000022 size=+1>Kinds(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Returns a bit mask indicating what interfaces the node implements.  See &nbsp;<a href="#node_kind%20on%20page181">"node_kind" on page181</a> for a list of valid interface kinds.
<P>
<HR>
<H3>
<A NAME="Name()"></A>Name()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
const char *<B><TT><FONT  color=000022 size=+1>Name(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>) </TT></B></FONT>const
<P>

</TABLE></TABLE>

<P>
Returns a human-readable string specifying the node's name.  This pointer is only valid until you <B><TT><A HREF="#Release()">Release()</A></TT></B> the node; after that, the pointer may point into empty space.
<P>
<HR>
<H3>
<A NAME="NewChangeTag()"></A>NewChangeTag()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
static int32 <B><TT><FONT  color=000022 size=+1>NewChangeTag(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
This function, intended primarily for use by <A HREF="BufferConsumer.html#BBufferConsumer">BBufferConsumer</A> nodes, creates and returns a new change tag value.
<P>
<HR>
<H3>
<A NAME="Node()"></A>Node()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
media_node <B><TT><FONT  color=000022 size=+1>Node(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>) </TT></B></FONT>const
<P>

</TABLE></TABLE>

<P>
Returns the <B><TT><A HREF="misc_api.html#media_node">media_node</A></TT></B> structure that will be used by an application when accessing this node via the media roster.
<P>
<HR>
<H3>
<A NAME="NodeRegistered()"></A>NodeRegistered()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>NodeRegistered(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
The Media Server calls this hook function after the node has been registered.
<P>
<HR>
<H3>
<A NAME="NodeStopped()"></A>NodeStopped()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>NodeStopped(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>whenPerformanceTime</I></FONT><B><TT><FONT  color=000022 size=+1>) </TT></B></FONT>const
<P>

</TABLE></TABLE>

<P>
When you've finished handling a stop request (buffers will no longer be flowing), call this function.  If anyone is listening for stop notifications from you, they'll be notified.  The <I><FONT  color=991122 face=HELVETICA>whenPerformanceTime</I></FONT> argument should be the performance time of the stop command that was handled.
<P>
Anyone listening for node stop messages will be notified; this lets applications running in offline (rendering) mode know when the node has actually completed its work.
<P>
If your node is a <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A>, downstream consumers will be notified that your node stopped (automatically, no less) through the <B><TT>BBufferConsumer::ProducerDataStatus(B_PRODUCER_STOPPED)</TT></B> call.  This lets offline rendering nodes know when each of their inputs have no more data to send for the current roll.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
This is especially important for nodes that can be run in <B><TT><A HREF="#B_OFFLINE">B_OFFLINE</A></TT></B> mode.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  No error.
<P>
<UL>
<LI>Other errors.  Unable to communicate with the Media Server, or an error occurred communicating with other nodes.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="Preroll()"></A>Preroll()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Preroll</TT></B></FONT><B><TT><FONT  color=000022 size=+1>(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This hook function may be called before your node receives a <B><TT><A HREF="#Start()">Start()</A></TT></B> message if the application using the node calls <B><TT><A HREF="MediaRoster.html#PrerollNode()">BMediaRoster::PrerollNode()</A></TT></B>.  This gives the node a chance to prepare the media so that when the media is started, the response is as fast as possible.
<P>
<HR>
<H3>Release() see <A HREF="#Acquire()">Acquire()</A></H3>
<P>
<HR>
<H3>
<A NAME="ReportError()"></A>ReportError()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>ReportError(</TT></B></FONT>node_error <I><FONT  color=991122 face=HELVETICA>whichError</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>info</I></FONT> = <FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Transmits the error code specified by <I><FONT  color=991122 face=HELVETICA>whichError</I></FONT> to anyone that's receiving notifications from this node (see <B><TT><A HREF="MediaRoster.html#StartWatching()">BMediaRoster::StartWatching()</A></TT></B> and <B><TT><A HREF="MediaRoster.html#StopWatching()">BMediaRoster::StopWatching()</A></TT></B> on &nbsp;).  If <I><FONT  color=991122 face=HELVETICA>info</I></FONT> isn't <B><TT>NULL</TT></B>, it's used as a model message for the error notification message.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The error report was sent without error.
<P>
<UL>
<LI><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> errors.  The message couldn't be sent.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="RequestCompleted()"></A>RequestCompleted()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>RequestCompleted(</TT></B></FONT>const media_request_info &amp;<I><FONT  color=991122 face=HELVETICA>info</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This function is called whenever a request issued by the node is completed.  The <I><FONT  color=991122 face=HELVETICA>info</I></FONT> structure describes the results of the request.
<P>
The <B><TT>change_tag</TT></B> field in the <I><FONT  color=991122 face=HELVETICA>info</I></FONT> structure identifies the request that has been completed; this is the same value passed into the function that initiated the request.
<P>
Return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> if you're happy, otherwise return an appropriate error code.
<P>
<HR>
<H3>
<A NAME="RunMode()"></A>RunMode()
, 
<A NAME="SetRunMode()"></A>SetRunMode()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
run_mode <B><TT><FONT  color=000022 size=+1>RunMode(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>SetRunMode</TT></B></FONT><B><TT><FONT  color=000022 size=+1>(</TT></B></FONT>run_mode <I><FONT  color=991122 face=HELVETICA>mode</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>RunMode()</TT></B> returns the node's current run_mode setting.
<P>
The <B><TT>SetRunMode()</TT></B> hook function is called when someone requests that your node's run mode be changed.
<P>
<B>See also:  </B>&nbsp;<a href="#run_mode%20on%20page182">"run_mode" on page182</a>
<P>
<HR>
<H3>
<A NAME="Seek()"></A>Seek()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Seek</TT></B></FONT><B><TT><FONT  color=000022 size=+1>(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>mediaTime</I></FONT>, bigtime_t <I><FONT  color=991122 face=HELVETICA>performanceTime</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This hook function is called when a node is asked to seek to the specified <I><FONT  color=991122 face=HELVETICA>mediaTime</I></FONT> by a call to the BMediaRoster.
<P>
The specified <I><FONT  color=991122 face=HELVETICA>performanceTime</I></FONT>, the time at which the node should begin the seek operation, may be in the future.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Your node is required to queue at least one each of start, stop, and seek requests, so that applications can establish, for example, both the start and stop time without having to monitor your node's progress.  The actual size of these three queues is up to you.  When the specified time arrives, the request should be filled.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
A <I><FONT  color=991122 face=HELVETICA>mediaTime</I></FONT> value of 0 indicates the beginning of the media data.
<P>
<HR>
<H3>SetRunMode() see <A HREF="#RunMode()">RunMode()</A></H3>
<P>
<HR>
<H3>
<A NAME="SetTimeSource()"></A>SetTimeSource()
, 
<A NAME="TimeSource()"></A>TimeSource()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>SetTimeSource(</TT></B></FONT><A HREF="TimeSource.html#BTimeSource">BTimeSource</A> *<I><FONT  color=991122 face=HELVETICA>timeSource</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
<A HREF="TimeSource.html#BTimeSource">BTimeSource</A> *<B><TT><FONT  color=000022 size=+1>TimeSource(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
The <B><TT>SetTimeSource()</TT></B> hook function is called when someone has requested that the node be slaved to a new time source.  Augment this function to make whatever adjustments you need to make to operate at the new time scale.
<P>
<B><TT>TimeSource()</TT></B> returns a pointer to the <A HREF="TimeSource.html#BTimeSource">BTimeSource</A> to which the node is currently slaved.  If no time source has been explicitly requested, the system time source is in use, and that's what gets returned.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The <A HREF="TimeSource.html#BTimeSource">BTimeSource</A> object returned by <B><TT>TimeSource()</TT></B> is only valid until the next call to <B><TT><A HREF="#HandleMessage()">HandleMessage()</A></TT></B> on that object.  Therefore, if your node runs more than one thread, you need to serialize calls to <B><TT>TimeSource()</TT></B> (as well as usage of the returned objects) with calls to <B><TT><A HREF="#HandleMessage()">HandleMessage()</A></TT></B>.  This isn't a problem if you follow the recommended policy of running a single thread that monitors the service port with <B><TT><A HREF="../The%20Kernel%20Kit/Ports.html#read_port_etc()">read_port_etc()</A></TT></B> and calls <B><TT><A HREF="#HandleMessage()">HandleMessage()</A></TT></B> only when a message is actually received.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="Start()"></A>Start()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Start</TT></B></FONT><B><TT><FONT  color=000022 size=+1>(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>performanceTime</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This hook function is called when a node is started by a call to the BMediaRoster. 
<P>
The specified <I><FONT  color=991122 face=HELVETICA>performanceTime</I></FONT>, the time at which the node should start running, may be in the future.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Your node is required to queue at least one each of start, stop, and seek requests, so that applications can establish, for example, both the start and stop time without having to monitor your node's progress.  The actual size of these three queues is up to you.  When the specified time arrives, the request should be filled.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="Stop()"></A>Stop()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Stop</TT></B></FONT><B><TT><FONT  color=000022 size=+1>(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>performanceTime</I></FONT>, bool <I><FONT  color=991122 face=HELVETICA>immediate</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This hook function is called when a node is stopped by a call to the BMediaRoster.
<P>
The specified <I><FONT  color=991122 face=HELVETICA>performanceTime</I></FONT>, the time at which the node should stop, may be in the future.
<P>
If immediate is true, your node should ignore the performanceTime value and synchronously stop performance.  When <B><TT>Stop()</TT></B> returns, you're promising not to write into any BBuffers you may have received from your downstream consumers, and you promise not to send any more buffers until <B><TT><A HREF="#Start()">Start()</A></TT></B> is called again.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/infoBullet.gif">
					<TD><FONT FACE="helvetica">
Your node is required to queue at least one each of start, stop, and seek requests, so that applications can establish, for example, both the start and stop time without having to monitor your node's progress.  The actual size of these three queues is up to you.  When the specified time arrives, the request should be filled.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
Nodes must recycle all buffers they may be holding onto when they're stopped.
<P>
<HR>
<H3>TimerExpired() see <A HREF="#AddTimer()">AddTimer()</A></H3>
<P>
<HR>
<H3>TimeSource() see <A HREF="#SetTimeSource()">SetTimeSource()</A></H3>
<P>
<HR>
<H3>
<A NAME="TimeWarp()"></A>TimeWarp()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>TimeWarp</TT></B></FONT><B><TT><FONT  color=000022 size=+1>(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>atRealTime</I></FONT>, bigtime_t <I><FONT  color=991122 face=HELVETICA>newPerformanceTime</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This hook function is called when the time source to which the node is slaved is repositioned (via a seek operation) such that there will be a sudden jump in the performance time progression as seen by the node.  The <I><FONT  color=991122 face=HELVETICA>newPerformanceTime</I></FONT> argument indicates the new performance time; the change should occur at the real time specified by the <I><FONT  color=991122 face=HELVETICA>atRealTime</I></FONT> argument.
<P>
The node should respond to this call by preparing for this change, so a serious stutter, failure, or acceleration in performance doesn't occur.  Appropriate measures should be taken to minimize the impact on the performance quality; for example, a segment of the sound could be looped or skipped smoothly.
<P>
Your implementation of <B><TT>TimeWarp()</TT></B> should call through to <B><TT><A HREF="#BMediaNode::TimeWarp()">BMediaNode::TimeWarp()</A></TT></B> as well as all other inherited forms of <B><TT>TimeWarp()</TT></B>.
<P>
<HR>
<H3>
<A NAME="WaitForMessage()"></A>WaitForMessage()
</H3>
<P>
protected:
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>WaitForMessage</TT></B></FONT><B><TT><FONT  color=000022 size=+1>(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>waitUntil</I></FONT>, uint32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = <FONT  face=HELVETICA>0</FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *<I><FONT  color=991122 face=HELVETICA>_reserved_</I></FONT> = <FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This function waits until either real time specified by <I><FONT  color=991122 face=HELVETICA>waitUntil</I></FONT> or a message is received on the control port..  The <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> are currently unused and should be 0.
<P>
When a message is received, the appropriate HandleMessage() calls are made given the class derivation of the node:
<P>
<UL>
<LI><B><TT><A HREF="#BMediaNode::HandleMessage()">BMediaNode::HandleMessage()</A></TT></B> is always called first.
<P>
<LI>If the node is derived from <A HREF="BufferProducer.html#BBufferProducer">BBufferProducer</A>, and the message hasn't been handled yet, <B><TT><A HREF="BufferProducer.html#HandleMessage()">BBufferProducer::HandleMessage()</A></TT></B> is called.
<P>
<LI>If the node is derived from <A HREF="BufferConsumer.html#BBufferConsumer">BBufferConsumer</A>, and the message hasn't been handled yet, <B><TT><A HREF="BufferConsumer.html#HandleMessage()">BBufferConsumer::HandleMessage()</A></TT></B> is called.
<P>
<LI>If the node is derived from <A HREF="FileInterface.html#BFileInterface">BFileInterface</A>, and the message hasn't been handled yet, <B><TT><A HREF="FileInterface.html#HandleMessage()">BFileInterface::HandleMessage()</A></TT></B> is called.
<P>
<LI>If the node is derived from <A HREF="Controllable.html#BControllable">BControllable</A>, and the message hasn't been handled yet, <B><TT><A HREF="Controllable.html#HandleMessage()">BControllable::HandleMessage()</A></TT></B> is called.
<P>
<LI>If the node is derived from <A HREF="TimeSource.html#BTimeSource">BTimeSource</A>, and the message hasn't been handled yet, <B><TT><A HREF="TimeSource.html#HandleMessage()">BTimeSource::HandleMessage()</A></TT></B> is called.
<P>
<LI>If the message still hasn't been handled, the most-derived interface's <B><TT><A HREF="#HandleMessage()">HandleMessage()</A></TT></B> function is called.
<P>
<LI>If the message hasn't been handled, <B><TT><A HREF="#HandleBadMessage()">HandleBadMessage()</A></TT></B> is called.
<P>
</UL>
<P>
Once this has been done, <B><TT>WaitForMessage()</TT></B> returns.  As you can see, this can be called from your control port to handle much of the work of processing received messages.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>. A message has occurred within the given time period.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_TIMED_OUT">B_TIMED_OUT</A></TT></B>.  The time waitUntil has arrived without a message being received.
<P>
</UL>
<P>
<HR>
<H2>
<A NAME="Constants"></A><FONT SIZE=6>C</FONT>onstants
</H2>
<P>
<HR>
<H3>
<A NAME="node_error"></A>node_error
</H3>
<P>
Declared in:  &lt;be/media/MediaNode.h>
<P>
<TABLE BORDER cellpadding=4>
<TH>Constant</TH>
<TH>Description</TH>
<TR>
<TD><B><TT>
<A NAME="B_NODE_FAILED_START"></A>B_NODE_FAILED_START
</TT></B></TD>
<TD>The node failed on a <B><TT><A HREF="#Start()">Start()</A></TT></B> request.</TD>
<TR>
<TD><B><TT>
<A NAME="B_NODE_FAILED_STOP"></A>B_NODE_FAILED_STOP
</TT></B></TD>
<TD>The node failed on a <B><TT><A HREF="#Stop()">Stop()</A></TT></B> request.</TD>
<TR>
<TD><B><TT>
<A NAME="B_NODE_FAILED_SEEK"></A>B_NODE_FAILED_SEEK
</TT></B></TD>
<TD>The node failed on a <B><TT><A HREF="#Seek()">Seek()</A></TT></B> request.</TD>
<TR>
<TD><B><TT>
<A NAME="B_NODE_FAILED_SET_RUN_MODE"></A>B_NODE_FAILED_SET_RUN_MODE
</TT></B></TD>
<TD>The node's run_mode couldn't be set.</TD>
<TR>
<TD><B><TT>
<A NAME="B_NODE_FAILED_TIME_WARP"></A>B_NODE_FAILED_TIME_WARP
</TT></B></TD>
<TD>The node couldn't fulfill a time warp request.</TD>
<TR>
<TD><B><TT>
<A NAME="B_NODE_FAILED_PREROLL"></A>B_NODE_FAILED_PREROLL
</TT></B></TD>
<TD>The node failed on a <B><TT><A HREF="#Preroll()">Preroll()</A></TT></B> request.</TD>
<TR>
<TD><B><TT>
<A NAME="B_NODE_FAILED_SET_TIME_SOURCE_FO"></A>B_NODE_FAILED_SET_TIME_SOURCE_FO
R</TT></B></TD>
<TD>The node's time source couldn't be changed.</TD>
<TR>
<TD><B><TT>
<A NAME="B_NODE_IN_DISTRESS"></A>B_NODE_IN_DISTRESS
</TT></B></TD>
<TD>The node is suffering in general.</TD>
</TABLE>
<P>
The node_error type defines the errors a node can transmit to BMessengers that have registered to watch the node.
<P>
<A NAME="node_kind"></A>
<P>
<HR>
<H3>
<A NAME="node_kind"></A>node_kind
</H3>
<P>
Declared in:  &lt;be/media/MediaDefs.h>
<P>
<TABLE BORDER cellpadding=4>
<TH>Constant</TH>
<TH>Description</TH>
<TR>
<TD><B><TT>
<A NAME="B_BUFFER_PRODUCER"></A>B_BUFFER_PRODUCER
</TT></B></TD>
<TD>The flavor implements <A HREF="BufferProducer.html#BBufferProducer.">BBufferProducer.</A></TD>
<TR>
<TD><B><TT>
<A NAME="B_BUFFER_CONSUMER"></A>B_BUFFER_CONSUMER
</TT></B></TD>
<TD>The flavor implements BBufferConsumer.</TD>
<TR>
<TD><B><TT>
<A NAME="B_TIME_SOURCE"></A>B_TIME_SOURCE
</TT></B></TD>
<TD>The flavor implements BTimeSource.</TD>
<TR>
<TD><B><TT>
<A NAME="B_CONTROLLABLE"></A>B_CONTROLLABLE
</TT></B></TD>
<TD>The flavor implements BControllable.</TD>
<TR>
<TD><B><TT>
<A NAME="B_FILE_INTERFACE"></A>B_FILE_INTERFACE
</TT></B></TD>
<TD>The flavor implements BFileInterface.</TD>
<TR>
<TD><B><TT>
<A NAME="B_ENTITY_INTERFACE"></A>B_ENTITY_INTERFACE
</TT></B></TD>
<TD>The flavor implements BEntityInterface (not available for R4).</TD>
<TR>
<TD><B><TT>
<A NAME="B_PHYSICAL_INPUT"></A>B_PHYSICAL_INPUT
</TT></B></TD>
<TD>The flavor represents a physical input point (such as an input jack).</TD>
<TR>
<TD><B><TT>
<A NAME="B_PHYSICAL_OUTPUT"></A>B_PHYSICAL_OUTPUT
</TT></B></TD>
<TD>The flavor represents a physical output point (such as line output).</TD>
<TR>
<TD><B><TT>
<A NAME="B_SYSTEM_MIXER"></A>B_SYSTEM_MIXER
</TT></B></TD>
<TD>The flavor represents the system mixer.</TD>
</TABLE>
<P>
Defines the type or types of node that a particular flavor supports.  Note that a flavor can implement more than one type of node, so you can combine these values using a bitwise or.
<P>
<A NAME="run_mode"></A>
<P>
<HR>
<H3>
<A NAME="run_mode"></A>run_mode
</H3>
<P>
Declared in:  &lt;be/media/MediaNode.h>
<P>
<TABLE BORDER cellpadding=4>
<TH><B>Constant</B></TH>
<TH>Description</TH>
<TR>
<TD><B><TT>
<A NAME="B_OFFLINE"></A>B_OFFLINE
</TT></B></TD>
<TD>Keep data accurate, even if the performance lags or runs too fast.  This is typically used when rendering to disk.</TD>
<TR>
<TD><B><TT>
<A NAME="B_RECORDING"></A>B_RECORDING
</TT></B></TD>
<TD>Time-stamped buffers are being received from a node capturing them from the real world; these buffers are guaranteed to have a time stamp in the past (they're always "late").</TD>
<TR>
<TD><B><TT>
<A NAME="B_DECREASE_PRECISION"></A>B_DECREASE_PRECISION
</TT></B></TD>
<TD>If the performance starts to lag, try to catch up.</TD>
<TR>
<TD><B><TT>
<A NAME="B_INCREASE_LATENCY"></A>B_INCREASE_LATENCY
</TT></B></TD>
<TD>If the performance starts to lag, increase playout delay so buffers are delivered with less time to spare before they're needed.</TD>
<TR>
<TD><B><TT>
<A NAME="B_DROP_DATA"></A>B_DROP_DATA
</TT></B></TD>
<TD>If the performance starts to lag, skip data.</TD>
</TABLE>
<P>
The run_mode type indicates how a node should cope if its performance rate deviates from the desired rate.
<P>
<H4>
<A NAME="B_OFFLINE"></A>B_OFFLINE
</H4>
<P>
When in offline mode (<B><TT><A HREF="#B_OFFLINE">B_OFFLINE</A></TT></B>), the node doesn't need to worry about processing buffers at any particular time.  Each buffer's performance time should be derived from the time stamped on the buffer, rather than from a BTimeSource.  In fact, you'll usually want to call <B><TT><A HREF="../The%20Kernel%20Kit/Threads.html#set_thread_priority()">set_thread_priority()</A></TT></B> to set your node's processing threads to a low priority while the node is in offline mode.  This lets software render media to disk in an efficient manner, letting the user continue to work while the render occurs in the background.
<P>
<H4>
<A NAME="B_RECORDING"></A>B_RECORDING
</H4>
<P>
Recording mode (<B><TT><A HREF="#B_RECORDING">B_RECORDING</A></TT></B>) should be used when data is being sampled from a physical input device.  These devices always deliver buffers whose time stamps are in the past (they're stamped with the time at which they were sampled, which is of course in the past, unless you've stolen a time machine from a professor from the 27th century, in which case you're probably running BeOS R127.1 and this book is woefully obsolete).
<P>
Using <B><TT><A HREF="#B_RECORDING">B_RECORDING</A></TT></B> mode serves to warn other nodes that the time stamps will be in the past.
<P>
<H4>
<A NAME="B_DECREASE_PRECISION"></A>B_DECREASE_PRECISION
</H4>
<P>
In <B><TT><A HREF="#B_DECREASE_PRECISION">B_DECREASE_PRECISION</A></TT></B> mode, your node should attempt to catch up if it falls behind, by playing buffers of media data faster than normal.  For audio, this might mean playing back at a higher sampling rate; for video, the frame rate might be temporarily boosted.
<P>
<H4>
<A NAME="B_INCREASE_LATENCY"></A>B_INCREASE_LATENCY
</H4>
<P>
If your node gets behind in the <B><TT><A HREF="#B_INCREASE_LATENCY">B_INCREASE_LATENCY</A></TT></B> run mode, your node should increase its internal latency measurement and send call the LateNoticeReceived() function in anyone above your node in the media stream.
<P>
Your node should then try to produce each buffer earlier before the buffer's performance time from that point on, so there's more time for the buffers to reach their destination.
<P>
This mode is intended to compensate for data streams in which throughput can vary over time.  For example, if media data is being streamed over a network, traffic fluctuations may require your node to adapt by adding more buffering (latency).
<P>
<H4>
<A NAME="B_DROP_DATA"></A>B_DROP_DATA
</H4>
<P>
When in <B><TT><A HREF="#B_DROP_DATA">B_DROP_DATA</A></TT></B> mode, your node should simply skip buffers if if falls behind.  Note that you still receive the buffers, but you should ignore any that you must in order to keep playing as many buffers as possible at the correct performance times.
<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Media Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Media%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Media Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

