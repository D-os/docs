<HTML><HEAD><TITLE>The Kernel Kit: Miscellaneous Functions and Constants</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Kernel Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Kernel%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Kernel Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="Miscellaneous%20Functions%20and%20Constants"></A>Miscellaneous Functions and Constants
</H1>
<P>
Declared in:  <A HREF="/boot/develop/headers/be/kernel/OS.h (unless otherwise noted)">be/kernel/OS.h (unless otherwise noted)</A>
<P>
<HR>
<H2>
<A NAME="Functions"></A><FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="clear_caches()"></A>clear_caches()
</H3>
<P>
Declared in:  <A HREF="/boot/develop/headers/be/kernel/image.h">be/kernel/image.h</A>
<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>clear_caches(</TT></B></FONT>void *<I><FONT  color=991122 face=HELVETICA>addr</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>len</I></FONT>, uint32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This function clears or invalidates the instruction and data caches.  You should only need this function if you're generating code on the fly, or if you're performing a timing loop and you want to start with fresh caches (to get a "worst case" estimate). 
<P>
The argument are:
<P>
<UL>
<LI><I><FONT  color=991122 face=HELVETICA>addr</I></FONT> is the starting address of a section of memory that corresponds to a section of one of the caches.  
<P>
<LI><I><FONT  color=991122 face=HELVETICA>len</I></FONT> is the length, in bytes, of the instruction or data segment that you want to clear or invalidate.
<P>
<LI><I><FONT  color=991122 face=HELVETICA>flags</I></FONT> is one or both of <B><TT>B_INVALIDATE_ICACHE</TT></B> and <B><TT>B_FLUSH_DCACHE</TT></B>.
<P>
</UL>
<P>
By invalidating a section of the instruction cache, you cause the instructions in that section to be reloaded next time they're needed.  Flushing the data cache causes the in-memory copy of the data to be written out to the cache.
<P>
<HR>
<H3>
<A NAME="debugger()"></A>debugger()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>debugger(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>string</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Throws the calling thread into the debugger.  The <I><FONT  color=991122 face=HELVETICA>string</I></FONT> argument becomes the debugger's first utterance.
<P>
<HR>
<H3>
<A NAME="disable_debugger()"></A>disable_debugger()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
int <B><TT><FONT  color=000022 size=+1>disable_debugger(</TT></B></FONT>int <I><FONT  color=991122 face=HELVETICA>state</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Instructs the kernel to send a signal for all exceptions, even those that don't normally trigger the debugger.  If the application doesn't have a handler installed for the exception, the team dies without triggering the debugger.  <I><FONT  color=991122 face=HELVETICA>state</I></FONT> should be nonzero to turn on this functionality or 0 to turn it off.
<P>
<HR>
<H3>
<A NAME="set_alarm()"></A>set_alarm()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
bigtime_t <B><TT><FONT  color=000022 size=+1>set_alarm(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>time</I></FONT>, uint32 <I><FONT  color=991122 face=HELVETICA>mode</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Tells the kernel to send the <B><TT>SIGALRM</TT></B> signal at some point in the future, as defined by the arguments:
<P>
<UL>
<LI>If <I><FONT  color=991122 face=HELVETICA>mode</I></FONT> is <B><TT>B_PERIODIC_ALARM</TT></B>, the signal is sent every <I><FONT  color=991122 face=HELVETICA>time</I></FONT> microseconds, starting as soon as <B><TT><A HREF="#set_alarm()">set_alarm()</A></TT></B> function returns. 
<P>
<LI>If <I><FONT  color=991122 face=HELVETICA>mode</I></FONT> is <B><TT>B_ONE_SHOT_ABOLUTE_ALARM</TT></B>, the signal is sent once (only) after <I><FONT  color=991122 face=HELVETICA>time</I></FONT> microseconds have elapsed measured from the time the system was booted.  If that point has already passed, the signal is sent immediately.
<P>
<LI>If <I><FONT  color=991122 face=HELVETICA>mode</I></FONT> is <B><TT>B_ONE_SHOT_RELATIVE_ALARM</TT></B>, the signal is sent once (only) after <I><FONT  color=991122 face=HELVETICA>time</I></FONT> microseconds have elapsed from the time <B><TT><A HREF="#set_alarm()">set_alarm()</A></TT></B> returns.
<P>
</UL>
<P>
When the signal is sent, the <B><TT>SIGALRM</TT></B> handler is called (you set the handler through the normal means, by calling the Posix <B><TT>signal()</TT></B> function).  The handler runs in the thread that set the alarm.  
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
From within the <B><TT>SIGALRM</TT></B> handler, you mustn't call anything that would cause the kernel scheduler to run.  Just about the only safe call you can make from your signal handler is <B><TT><A HREF="Semaphores.html#release_sem()">release_sem()</A></TT></B>.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
The most recent alarm requested cancels any previous request.  For example, in this sequence...
<P>
<PRE>&nbsp;&nbsp;&nbsp;/* Ask for an alarm ten seconds from now. */
&nbsp;&nbsp;&nbsp;set_alarm(10e6, B_ONE_SHOT_RELATIVE_ALARM); 
&nbsp;&nbsp;&nbsp;/* Ask for an alarm one second from now. */
&nbsp;&nbsp;&nbsp;set_alarm(10e5, B_ONE_SHOT_RELATIVE_ALARM); </PRE>
<P>
...only the second alarm request will be fulfilled&mdash;the first requested is cancelled when the second <B><TT><A HREF="#set_alarm()">set_alarm()</A></TT></B> call is made.   This applies to all alarm types; for example, a one-shot alarm request will cancel an active periodic alarm.
<P>
To explicitly cancel the previous alarm request without installing a new alarm, do this:
<P>
<PRE>&nbsp;&nbsp;&nbsp;set_alarm(B_INFINITE_TIMEOUT, B_PERIODIC_ALARM);</PRE>
<P>
This cancels the previous alarm request regardless of the type of alarm.
<P>
<HR>
<H3>
<A NAME="set_signal_stack()"></A>set_signal_stack()
</H3>
<P>
Declared in:  <A HREF="/boot/develop/headers/posix/signal.be.h">posix/signal.be.h</A>
<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>set_signal_stack(</TT></B></FONT>void *<I><FONT  color=991122 face=HELVETICA>ptr</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Sets the location and size of the stack that's used by the thread's signal handlers.
<P>
<HR>
<H2>
<A NAME="Constants"></A><FONT SIZE=6>C</FONT>onstants
</H2>
<P>
<HR>
<H3>
<A NAME="B_INFINITE_TIMEOUT"></A>B_INFINITE_TIMEOUT
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>B_INFINITE_TIMEOUT
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
The inifinite timeout value can be used to specify, to timeout-accepting functions, that you're willing to wait forever.
<P>
<HR>
<H3>
<A NAME="B_OS_NAME_LENGTH"></A>B_OS_NAME_LENGTH
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>B_OS_NAME_LENGTH
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
This constant gives the maximum length of the name of a thread, semaphore, port, area, or other operating system bauble.  
<P>
<HR>
<H3>
<A NAME="B_PAGE_SIZE"></A>B_PAGE_SIZE
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>B_PAGE_SIZE
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
The <B><TT>
<A NAME="B_PAGE_SIZE"></A>B_PAGE_SIZE
</TT></B> constant gives the size, in bytes, of a page of RAM.  
<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Kernel Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Kernel%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Kernel Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

