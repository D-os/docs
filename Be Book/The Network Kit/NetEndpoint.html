<HTML><HEAD><TITLE>The Network Kit: BNetEndpoint</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Network Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Network%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Network Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="BNetEndpoint"></A>BNetEndpoint
</H1>
<P>
Derived from:  <A HREF="../The%20Support%20Kit/Archivable.html#BArchivable">BArchivable</A>
<P>
Declared in:  <A HREF="/boot/develop/headers/be/net/NetEndpoint.h">be/net/NetEndpoint.h</A>
<P>
Library:  libnetapi.so
<P>
Allocation:  Constructor only
<P>
<H6><A HREF="NetEndpoint.summary.html"><i>Summary</i></A></H6>
<P>
The BNetEndpoint class represents a network endpoint, which can send and receive data, establish network connections, bind to local addresses, and listen for and accept new connections.
<P>
Rather than replacing the existing network architecture, the BNetEndpoint class provides a C++ wrapper to the standard socket functions.  All the same rules of usage apply, so be sure to review the BSD-like C socket function material.
<P>
<HR>
<H2>
<A NAME="Archiving%20BNetEndpoints"></A><FONT SIZE=6>A</FONT>rchiving <FONT SIZE=6>B</FONT><FONT SIZE=6>N</FONT>et<FONT SIZE=6>E</FONT>ndpoints
</H2>
<P>
BNetEndpoint objects are archivable.  All attributes of the BNetEndpoint are preserved when archived.  Upon reinstantiation, the object is duplicated precisely.  This has interesting ramifications&mdash;if the BNetEndpoint is connected to a remote system when it's archived, the reinstantiated archive will also be connected to that system.  You can actually archive active connections to restore them later.
<P>
Obviously, however, protocol-specific information won't be saved unless you add that data to the archive yourself.  For example, if you archive an FTP connection, then restore the connection from the archive, the working directory or any ongoing downloads won't be restored automatically.
<P>
<HR>
<H2>
<A NAME="Constructor%20and%20Destructor"></A><FONT SIZE=6>C</FONT>onstructor and <FONT SIZE=6>D</FONT>estructor
</H2>
<P>
<HR>
<H3>
<A NAME="BNetEndpoint()"></A>BNetEndpoint()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>BNetEndpoint(</TT></B></FONT>int <I><FONT  color=991122 face=HELVETICA>protocol</I></FONT> = <FONT  face=HELVETICA>SOCK_STREAM</FONT><B><TT><FONT  color=000022 size=+1>) 
<P>
</TT></B></FONT>
<TR><TD>
<B><TT><FONT  color=000022 size=+1>BNetEndpoint(</TT></B></FONT>const BNetEndpoint &amp;<B><TT><FONT  color=000022 size=+1>) 
<P>
</TT></B></FONT>
<TR><TD>
<B><TT><FONT  color=000022 size=+1>BNetEndpoint(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>archive</I></FONT><B><TT><FONT  color=000022 size=+1>) 
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Creates a BNetEndpoint representing a network connection endpoint on the local system.  After construction, you must call <B><TT><A HREF="#InitCheck()">InitCheck()</A></TT></B> to ensure that no errors occurred during setup.
<P>
The <I><FONT  color=991122 face=HELVETICA>protocol</I></FONT> argument lets you specify whether the BNetEndpoint will use a stream socket (<B><TT>SOCK_STREAM</TT></B>) or a datagram socket (<B><TT>SOCK_DGRAM</TT></B>).
<P>
By default, I/O is blocking and address reusing is off.  You can change these by calling <B><TT><A HREF="#SetNonBlocking()">SetNonBlocking()</A></TT></B> and <B><TT><A HREF="#SetReuseAddr()">SetReuseAddr()</A></TT></B>.
<P>
<HR>
<H3>
<A NAME="~BNetEndpoint"></A>~BNetEndpoint
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual <B><TT><FONT  color=000022 size=+1>~BNetEndpoint() 
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
A typical destructor.
<P>
<HR>
<H2>
<A NAME="Member%20Functions"></A><FONT SIZE=6>M</FONT>ember <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>Accept() see <A HREF="#Listen()">Listen()</A></H3>
<P>
<HR>
<H3>
<A NAME="Bind()"></A>Bind()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>Bind(</TT></B></FONT>const <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> &amp;<I><FONT  color=991122 face=HELVETICA>address</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>Bind(</TT></B></FONT>int <I><FONT  color=991122 face=HELVETICA>port</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Binds the BNetEndpoint to a specific local address.  That address can be specified by using a <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> or a simple <I><FONT  color=991122 face=HELVETICA>port</I></FONT> number.  This selects the port that will handle the local end of the connection.
<P>
If your BNetEndpoint is using a stream protocol and is going to be listening for connections, you must call <B><TT>Bind()</TT></B>.
<P>
If your stream BNetEndpoint is a client, it doesn't have to call <B><TT>Bind()</TT></B> but you can if you want to.  There aren't any significant benefits to doing so, however.
<P>
A stream accept BNetEndpoints must not be bound.
<P>
Datagram BNetEndpoints that are going to receive data must be bound; datagram BNetEndpoints that will only be sending data don't have to be.  However, if an endpoint will both send and receive, it must be bound.
<P>
If you don't specify an address or port number, or specify a port number of 0, <B><TT>Bind()</TT></B> will bind the BNetEndpoint to a random local port.  You can determine which one by calling <B><TT><A HREF="#LocalAddr()">LocalAddr()</A></TT></B>.
<P>
The only way to unbind a BNetEndpoint from an address or port is to close the endpoint.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The address was successfully bound to.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  An error occurred.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="Close()"></A>Close()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Close(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
Closes the connection, if there is one.  If there's unread data buffered up, it's disposed of.
<P>
<HR>
<H3>
<A NAME="Connect()"></A>Connect()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>Connect(</TT></B></FONT>const <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> &amp;<I><FONT  color=991122 face=HELVETICA>address</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>Connect(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>address</I></FONT>, int <I><FONT  color=991122 face=HELVETICA>port</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Opens a connection to the specified remote system.  The system's address can be specified by either using a <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> or by specifying the IP address or domain name and port number.  For example, to connect to the Megaburger, Inc. web server, your software would call:
<P>
<PRE>&nbsp;&nbsp;&nbsp;status_t err = myEndpoint->Connect("www.megaburger.com", 80);
&nbsp;&nbsp;&nbsp;if (err != B_OK) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* error occurred */
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* all is well, connection is open */
&nbsp;&nbsp;&nbsp;}</PRE>
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The connection was opened.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  An error occurred.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="Error()"></A>Error()
, 
<A NAME="ErrorStr()"></A>ErrorStr()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
int <B><TT><FONT  color=000022 size=+1>Error(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>

<TR><TD>
char *<B><TT><FONT  color=000022 size=+1>ErrorStr(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>Error()</TT></B> returns the integer error code for the last send or receive error.  If you receive a <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B> result from a send or receive function, you can find out the specific error using this function.
<P>
<B><TT>ErrorStr()</TT></B> returns a pointer to a text string describing the error; this string isn't yours, so <B>don't</B> try to <B><TT><A HREF="../Drivers/area_malloc.html#free()">free()</A></TT></B> it.
<P>
<HR>
<H3>
<A NAME="InitCheck()"></A>InitCheck()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>InitCheck(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Returns a status_t indicating whether or not the object was successfully instantiated.
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The BNetEndpoint was constructed without error.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  An error occurred during construction.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="IsDataPending()"></A>IsDataPending()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual bool <B><TT><FONT  color=000022 size=+1>IsDataPending(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>timeout</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns <B><TT>true</TT></B> if there's data waiting to be received, otherwise returns <B><TT>false</TT></B>.  If you specify a <I><FONT  color=991122 face=HELVETICA>timeout</I></FONT> other than 0, the function will block until either data is available or the timeout period elapses.
<P>
<HR>
<H3>
<A NAME="Listen()"></A>Listen()
, 
<A NAME="Accept()"></A>Accept()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>Listen(</TT></B></FONT>int <I><FONT  color=991122 face=HELVETICA>backlog</I></FONT> = 5<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual BNetEndpoint *<B><TT><FONT  color=000022 size=+1>Accept(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>timeout</I></FONT> = -1<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>Listen()</TT></B> tells the BNetEndpoint to begin listening for incoming connection attempts on its local port.  These attempts are queued; up to <I><FONT  color=991122 face=HELVETICA>backlog</I></FONT> attempts can be in the queue at any time.  If more attempts are backlogged than that, the later attempts will be rejected until there's room in the queue.
<P>
You can accept an incoming connection attempt by calling <B><TT>Accept()</TT></B>.  If there are no connection attempts queued up, this function returns <B><TT>NULL</TT></B>.  If there are connection attempts in the queue, a new BNetEndpoint object is created with the connection between your local port and the remote system opened, and that BNetEndpoint is returned to you.
<P>
The new connection is yours to do with as you please.  When you're finished with the connection, you must delete the returned BNetEndpoint.  Typically your listener thread will look something like this:
<P>
<PRE>&nbsp;&nbsp;&nbsp;long MyListener(void *data) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BNetEndpoint endpoint;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (endpoint.InitCheck() &lt; B_OK) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endpoint.Bind(portNumber);&nbsp;&nbsp;&nbsp;/* bind to the desired port */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endpoint.Listen();&nbsp;&nbsp;&nbsp;/* listen for connections */
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (keepListening) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BNetEndpoint *connect = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect = endpoint.Accept();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (connect) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle_connection(connect, data);&nbsp;&nbsp;&nbsp;/* call a function  do the work */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete connect;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endpoint.Close();
&nbsp;&nbsp;&nbsp;}</PRE>
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  Success.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  Failure.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="LocalAddr()"></A>LocalAddr()
, 
<A NAME="RemoteAddr()"></A>RemoteAddr()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
const <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> &amp;<B><TT><FONT  color=000022 size=+1>LocalAddr(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
const <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> &amp;<B><TT><FONT  color=000022 size=+1>RemoteAddr(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions return a <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> representing the local or remote system on the connection.  <B><TT>LocalAddr()</TT></B> returns the address of the local machine, and <B><TT>RemoteAddr()</TT></B> (amazingly enough) returns the address of the remote system.
<P>
If there isn't a remote connection, <B><TT>RemoteAddr()</TT></B> will return a <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> indicating an IP address of 0.0.0.0.
<P>
<HR>
<H3>
<A NAME="Receive()"></A>Receive()
, 
<A NAME="ReceiveFrom()"></A>ReceiveFrom()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual int32 <B><TT><FONT  color=000022 size=+1>Receive(</TT></B></FONT>const void *<I><FONT  color=991122 face=HELVETICA>buffer</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT>, int <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
virtual int32 <B><TT><FONT  color=000022 size=+1>Receive(</TT></B></FONT><A HREF="NetBuffer.html#BNetBuffer">BNetBuffer</A> &amp;<I><FONT  color=991122 face=HELVETICA>buffer</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT>, int <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual int32 <B><TT><FONT  color=000022 size=+1>ReceiveFrom(</TT></B></FONT>const void *<I><FONT  color=991122 face=HELVETICA>buffer</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT>, const <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> &amp;<I><FONT  color=991122 face=HELVETICA>from</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
virtual int32 <B><TT><FONT  color=000022 size=+1>ReceiveFrom(</TT></B></FONT><A HREF="NetBuffer.html#BNetBuffer">BNetBuffer</A> &amp;<I><FONT  color=991122 face=HELVETICA>buffer</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT>, const <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> &amp;<I><FONT  color=991122 face=HELVETICA>from</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>Receive()</TT></B> receives a <I><FONT  color=991122 face=HELVETICA>buffer</I></FONT> of data from the remote end of the connection.  If there's no connection established, <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B> is returned immediately.  Up to <I><FONT  color=991122 face=HELVETICA>size</I></FONT> bytes of data are received.
<P>
<B><TT><A HREF="#ReceiveFrom()">ReceiveFrom()</A></TT></B> receives the buffer from the remote system specified by the <I><FONT  color=991122 face=HELVETICA>from</I></FONT> BNetAddress.  <B><TT><A HREF="#ReceiveFrom()">ReceiveFrom()</A></TT></B> only works if the connection is using a datagram protocol.
<P>
The first form of each function function sends an arbitrary <I><FONT  color=991122 face=HELVETICA>buffer</I></FONT> of the specified <I><FONT  color=991122 face=HELVETICA>size</I></FONT>, and the second form sends the contents of a BNetBuffer.  When using a <A HREF="NetBuffer.html#BNetBuffer">BNetBuffer</A>, incoming data is appended to the end of the buffer, so you can use the same buffer in a loop to buffer incoming data in chunks until the desired number of bytes have been read.
<P>
The <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> argument, which is passed on to the <B>socket.h</B> <B><TT><A HREF="Sockets.html#recv()">recv()</A></TT></B> or <B><TT><A HREF="Sockets.html#recvfrom()">recvfrom()</A></TT></B> function, is currently unused and must be 0.
<P>
When you call these functions in blocking mode (which is the default), they block until there's data available to receive or a timeout occurs.  The timeout period is set by calling <B><TT><A HREF="#SetTimeout()">SetTimeout()</A></TT></B>.  You can turn on or off blocking by calling <B><TT><A HREF="#SetNonBlocking()">SetNonBlocking()</A></TT></B>.  If you're in nonblocking mode and there's no data waiting, these functions return 0 immediately, indicating that there's no data.
<P>
These functions return the number of bytes actually received, or -1 if an error occurred.  You can call <B><TT><A HREF="#Error()">Error()</A></TT></B> to get the specific error that occurred.
<P>
<HR>
<H3>RemoteAddr() see <A HREF="#LocalAddr()">LocalAddr()</A></H3>
<P>
<HR>
<H3>
<A NAME="Send()"></A>Send()
, 
<A NAME="SendTo()"></A>SendTo()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual int32 <B><TT><FONT  color=000022 size=+1>Send(</TT></B></FONT>const void *<I><FONT  color=991122 face=HELVETICA>buffer</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT>, int <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
virtual int32 <B><TT><FONT  color=000022 size=+1>Send(</TT></B></FONT><A HREF="NetBuffer.html#BNetBuffer">BNetBuffer</A> &amp;<I><FONT  color=991122 face=HELVETICA>buffer</I></FONT>, int <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual int32 <B><TT><FONT  color=000022 size=+1>SendTo(</TT></B></FONT>const void *<I><FONT  color=991122 face=HELVETICA>buffer</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>size</I></FONT>, const <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> &amp;<I><FONT  color=991122 face=HELVETICA>to</I></FONT>,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
virtual int32 <B><TT><FONT  color=000022 size=+1>SendTo(</TT></B></FONT><A HREF="NetBuffer.html#BNetBuffer">BNetBuffer</A> &amp;<I><FONT  color=991122 face=HELVETICA>buffer</I></FONT>, const <A HREF="NetAddress.html#BNetAddress">BNetAddress</A> &amp;<I><FONT  color=991122 face=HELVETICA>to</I></FONT>, int <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> = 0<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>Send()</TT></B> sends a <I><FONT  color=991122 face=HELVETICA>buffer</I></FONT> of data to the remote end of the connection.  If there's no connection established, <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B> is returned immediately.  In addition, if the BNetEndpoint is configured to use a datagram protocol, this function fails unless <B><TT><A HREF="#Connect()">Connect()</A></TT></B> has been called, since that function caches the destination address.
<P>
<B><TT><A HREF="#SendTo()">SendTo()</A></TT></B> sends the buffer to the remote system specified by the <I><FONT  color=991122 face=HELVETICA>to</I></FONT> BNetAddress.  <B><TT><A HREF="#SendTo()">SendTo()</A></TT></B> only works if the connection is using a datagram protocol.
<P>
The first form of each function function sends an arbitrary <I><FONT  color=991122 face=HELVETICA>buffer</I></FONT> of the specified <I><FONT  color=991122 face=HELVETICA>size</I></FONT>, and the second form sends the contents of a BNetBuffer.
<P>
The <I><FONT  color=991122 face=HELVETICA>flags</I></FONT> argument, which is passed on to the <B>socket.h</B> <B><TT><A HREF="Sockets.html#send()">send()</A></TT></B> or <B><TT><A HREF="Sockets.html#sendto()">sendto()</A></TT></B> function, is currently unused and must be 0.
<P>
These functions return the number of bytes actually sent, or -1 if an error occurred.  You can call <B><TT><A HREF="#Error()">Error()</A></TT></B> to get the specific error that occurred.
<P>
<HR>
<H3>
<A NAME="SetOption()"></A>SetOption()
, 
<A NAME="SetNonBlocking()"></A>SetNonBlocking()
, 
<A NAME="SetReuseAddr()"></A>SetReuseAddr()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
int <B><TT><FONT  color=000022 size=+1>SetOption(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>option</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>level</I></FONT>, const void *<I><FONT  color=991122 face=HELVETICA>data</I></FONT>, unsigned int <I><FONT  color=991122 face=HELVETICA>dataSize</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
int <B><TT><FONT  color=000022 size=+1>SetNonBlocking(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>enable</I></FONT> = <FONT  face=HELVETICA>true</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
int <B><TT><FONT  color=000022 size=+1>SetReuseAddr(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>enable</I></FONT> = <FONT  face=HELVETICA>true</FONT><B><TT><FONT  color=000022 size=+1>) 
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT>SetOption()</TT></B> lets you set any option for the BNetEndpoint.  This provides access to the <B><TT><A HREF="Sockets.html#setsockopt()">setsockopt()</A></TT></B> function of the underlying socket.
<P>
<B><TT>SetNonBlocking()</TT></B> controls whether I/O should block or not.  If <I><FONT  color=991122 face=HELVETICA>enable</I></FONT> is <B><TT>true</TT></B>, the connection will be nonblocking.  If <I><FONT  color=991122 face=HELVETICA>enable</I></FONT> is <B><TT>false</TT></B>, the connection will block on I/O calls until the transmission is completed.
<P>
<B><TT>SetReuseAddr()</TT></B> controls whether addresses should be reused or not.  If <I><FONT  color=991122 face=HELVETICA>enable</I></FONT> is <B><TT>true</TT></B>, addresses will be reused.  If <I><FONT  color=991122 face=HELVETICA>enable</I></FONT> is <B><TT>false</TT></B>, the connection won't reuse addresses.
<P>
These functions return 0 if successful; otherwise they return -1.
<P>
<HR>
<H3>
<A NAME="SetProtocol()"></A>SetProtocol()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SetProtocol(</TT></B></FONT>int <I><FONT  color=991122 face=HELVETICA>protocol</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>
<P>

</TABLE></TABLE>

<P>
Sets the protocol type for the connection.  Possible values for the <I><FONT  color=991122 face=HELVETICA>protocol</I></FONT> argument are <B><TT>SOCK_STREAM</TT></B> (to use the stream protocol) or <B><TT>SOCK_DGRAM</TT></B> (for datagram protocol).
<P>
<b>RETURN CODES</b>
<P>
<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The protocol was set successfully.
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.  An error occurred setting the protocol.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="SetTimeout()"></A>SetTimeout()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetTimeout(</TT></B></FONT>bigtime_t <I><FONT  color=991122 face=HELVETICA>timeout</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Sets the timeout for calls to <B><TT><A HREF="#Receive()">Receive()</A></TT></B> and <B><TT><A HREF="#ReceiveFrom()">ReceiveFrom()</A></TT></B>.  If blocking I/O is in use, and <I><FONT  color=991122 face=HELVETICA>timeout</I></FONT> microseconds pass, the function will abort with an error.  By default, there's no timeout.  You can specify that you want no timeout by specifying -1.
<P>
<HR>
<H3>
<A NAME="Socket()"></A>Socket()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
int <B><TT><FONT  color=000022 size=+1>Socket(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const<B><TT><FONT  color=000022 size=+1>
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns the actual socket used by the BNetEndpoint for data communications.
<P>
<HR>
<H2>
<A NAME="Operators"></A><FONT SIZE=6>O</FONT>perators
</H2>
<P>
<HR>
<H3>
<A NAME="="></A>=
 (assignment)</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
BNetEndpoint &amp;<B><TT><FONT  color=000022 size=+1>operator =(</TT></B></FONT>const BNetEndpoint &amp;<I><FONT  color=991122 face=HELVETICA>from</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Copies the BNetEndpoint specified by <I><FONT  color=991122 face=HELVETICA>from</I></FONT> into the left-side object, thereby duplicating that object.  If <I><FONT  color=991122 face=HELVETICA>from</I></FONT> is connected, the left-side object will duplicate and open the same connection.
<P>
<UL>
<LI>
<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Network Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Network%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Network Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

