<HTML><HEAD><TITLE>The Storage Kit: BQuery</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Storage Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Storage%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Storage Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="BQuery"></A>BQuery
</H1>
<P>
Derived from:  <A HREF="EntryList.html#BEntryList">BEntryList</A>
<P>
Declared in:  <A HREF="/boot/develop/headers/be/storage/Query.h">be/storage/Query.h</A>
<P>
Library:  libbe.so
<P>
<H6><A HREF="Query.summary.html"><i>Summary</i></A></H6>
<P>
A <I>query</I> is a means of asking the file system for a set of entries that satisfy certain criteria.   As examples, you can ask for all the entries with names that start with a certain letter, or that have nodes that are bigger than a certain size, or that were modified within the last <I>N </I>days, and so on.
<P>
The BQuery class lets you create objects that represent specific queries.  To use a BQuery you have to follow these steps:
<P>
<B>1. </B>&nbsp;&nbsp;&nbsp;<B>Initialize</B>.  The first thing you have to do is initialize the object; there are two parts to the initialization:  You have to set the volume that you want to query over (<B><TT><A HREF="#SetVolume()">SetVolume()</A></TT></B>), and set the query's "criteria formula" (<B><TT><A HREF="#SetPredicate()">SetPredicate()</A></TT></B>)
<P>
<B>2. </B>&nbsp;&nbsp;&nbsp;<B>Fetch</B>.  After the BQuery has been properly initialized, you invoke <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B>.  The function returns immediately while the query executes in the background.
<P>
<B>3. </B>&nbsp;&nbsp;&nbsp;<B>Read</B>.  As soon as <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B> returns, you can start reading the list of winning entries by making iterative calls to the entry-list functions <B><TT><A HREF="#GetNextRef()">GetNextRef()</A></TT></B>, <B><TT><A HREF="#GetNextEntry()">GetNextEntry()</A></TT></B>, and <B><TT><A HREF="#GetNextDirents()">GetNextDirents()</A></TT></B>.  If you ask for entries faster than the query can deliver them, your <B><TT>GetNext...()</TT></B> call will block until the next entry arrives.  The function returns an error when there are no more entries to retrieve.
<P>
The set of entries that the <B><TT>GetNext...()</TT></B> calls retrieve (for a given fetch) are called the query's "static" entries. This distinction will become useful when we speak of "live" queries, below.
<P>
<HR>
<H3>
<A NAME="Reusing%20your%20BQuery"></A>Reusing your BQuery
</H3>
<P>
Want to go around again?  You can, but first you have to clear the object:
<P>
<UL>
<LI>Between each "fetching session," you have to invoke <B><TT><A HREF="#Clear()">Clear()</A></TT></B> on your BQuery object. 
<P>
</UL>
<P>
Clearing erases the object's predicate, volume, target (which we'll get to later), and list of static entries&mdash;in other words, clearing gets you back to a fresh BQuery object.    
<P>
And speaking of going around again, be aware that the <B><TT><A HREF="#Rewind()">Rewind()</A></TT></B> function, which BQuery inherits from <A HREF="EntryList.html#BEntryList">BEntryList</A>, is implemented to be a no-op:  <B>You can't rewind a BQuery's list of static entries.</B>  After you've performed a fetch, you should read the entry list as quickly as possible and get on with things; you can't turn back or start over.
<P>
<B><TT>CountEntries() is also a no-op</TT></B>. This function is also defined by BEntryList.  It doesn't apply to BQueries.
<P>
<HR>
<H3>
<A NAME="Live%20Queries"></A>Live Queries
</H3>
<P>
A live query is the gift that keeps on giving.  After you tell a live query to fetch, you walk through the entry list (as described above), and then you wait for "query update" messages to be sent to your "target."  A query update message describes a single entry that has changed so that...
<P>
<UL>
<LI> it now satisfies the predicate (where it didn't use to), or...
<P>
<LI> it no longer satisfies the predicate (where it did before).
<P>
</UL>
<P>
Not every BQuery is live; you have to tell it you want it to be live.  To do this, all you have to do is set the object's target, through the <B><TT><A HREF="#SetTarget()">SetTarget()</A></TT></B> function.  The target is a <A HREF="../The%20Application%20Kit/Messenger.html#BMessenger">BMessenger</A> that identifies a BHandler/BLooper pair (as described in the <B><TT><A HREF="#SetTarget()">SetTarget()</A></TT></B> function).  Also...
<P>
<UL>
<LI><B>Live query notifications stop when you <TT><A HREF="#Clear()">Clear()</A> or destroy the BQuery object</TT></B>.
<P>
</UL>
<P>
Another important point regarding live queries is that you can start receiving updates <I>before</I> you're done looking at all the static entries (in other words, before you've reached the end of the <B><TT>GetNext...()</TT></B> loop).  It's possible that your target could receive an "entry dropped out" update before you retrieve the entry through a <B><TT>GetNext...()</TT></B> call.  If you're using live queries, you should take care in synchronizing the <B><TT>GetNext...()</TT></B> iteration with the target's message processing. 
<P>
We'll look at the format of the update message in a moment; first, let's fill in some gaps.
<P>
<A NAME="14835:%20head2:%20The%20Predicate,%20Attributes,%20and%20Indices"></A>
<P>
<HR>
<H3>
<A NAME="The%20Predicate,%20Attributes,%20and%20Indices"></A>The Predicate, Attributes, and Indices
</H3>
<P>
A BQuery's predicate is a logical expression that evaluates to true or false.  The "atoms" of the expression are comparisons in the form...
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/BULLET_GOES_HERE.gif">
					<TD><FONT FACE="helvetica">
<I>attribute op value
<P>
</I>						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
...where <I>attribute</I> is the name of an existing attribute, <I>op</I> is a constant that represents a comparison operation (==, &lt;, >, etc), and <I>value</I> is the value that you want to compare the attribute to.  
<P>
<H4>
<A NAME="Attributes"></A>Attributes
</H4>
<P>
As mentioned above, the attribute part of a query is a string name.  When you tell the query to fetch, the file system looks for all nodes that have an attribute with that name and then compare the attribute's value to the appropriate value in the predicate.  However...
<P>
<UL>
<LI><B>Every query must include at least one indexed attribute.
<P>
</B><LI><B>The index only knows about attributes that were written <I>after the index (for that attribute) was created</B></I>.
<P>
</UL>
<P>
To index an attribute, you call the <B><TT><A HREF="IndexFuncs.html#fs_create_index()">fs_create_index()</A></TT></B> function.  Unfortunately, there's currently no way to retroactively include existing attributes in a newly created index.  (Such a utility would be simple enough to write, but it would take a long time to execute since it would have to look at every file in the file system.)
<P>
<B>Only string and numeric attributes can be queried.</B>  Although an attribute can hold any type of data (it's stored as raw bytes), the query mechanism can only perform string and numeric comparisons. 
<P>
On the bright side, every file gets three attributes for free:
<P>
<UL>
<LI>"name" is the name of the entry.
<P>
<LI>"size" is the size of the data portion of the entry's node.  The size is a 64-bit integer, and doesn't include the node's attributes.
<P>
<LI>"last_modified" is the time the entry's node was last modified (data and attributes), measured in seconds since January 1, 1970.  The modification time is recorded as a 32-bit integer.
<P>
</UL>
<P>
Technically, "name", "size", and "last_modified" aren't actually attributes&mdash;you can't get them through <B><TT><A HREF="Node.html#ReadAttr()">BNode::ReadAttr()</A></TT></B>, for example.  But they're always eligible as the attribute component in a query.
<P>
<H4>
<A NAME="Values"></A>Values
</H4>
<P>
The <I>value</I> part of the "<I>attribute op value</I>" equation is any expression that can be evaluated at the time the predicate is set.  Once evaluated, the value doesn't change.  For example, you can't specify another attribute as the value component in hopes of comparing, file by file, the value of one attribute to the value of another.  The value is just data.  And data is data.
<P>
The type of the value should match the type of the attribute:  You compare string attributes to strings; numeric attributes to numbers.  You aren't prevented from comparing a string to a number (for example), but it may not give you the result you expect.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
The value of an indexed attribute can be, at most, 255 bytes.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<A NAME="29556:%20head3:%20Constructing%20a%20Predicate"></A>
<P>
<H4>
<A NAME="Constructing%20a%20Predicate"></A>Constructing a Predicate
</H4>
<P>
There are two ways to construct a predicate:
<P>
<UL>
<LI>You can set the predicate formula as a string through SetPredicate(), or
<P>
<LI>You can construct the predicate by "pushing" the components in Reverse Polish Notation (or "postfix") order through the <B><TT><A HREF="#PushAttr()">PushAttr()</A></TT></B>, <B><TT>Push<I>Value()</TT></B></I>, and <B><TT><A HREF="#PushOp()">PushOp()</A></TT></B> functions.  There are seven value-pushing functions that push specific types:  string, int32, uint32, int64, uint64, float, and double.  
<P>
</UL>
<P>
You can't combine the methods: Pushing the predicate <I>always</I> takes precedence over <B><TT><A HREF="#SetPredicate()">SetPredicate()</A></TT></B>, regardless of the order in which the methods are deployed.   
<P>
<B>SetPredicate() features:
<P>
</B><UL>
<LI>Comparison operators:  = &lt; > &lt;= >= !=
<P>
<LI>Logical operators: || &amp;&amp;
<P>
<LI>Negation operator:  !
<P>
<LI>Grouping: ()
<P>
<LI>String (value) wildcard:  * (prefix and/or postfix only)
<P>
<LI>String (value) quoting: ' '
<P>
</UL>
<P>
The following are all legitimate strings that you can pass to <B><TT><A HREF="#SetPredicate()">SetPredicate()</A></TT></B>:
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/BULLET_GOES_HERE.gif">
					<TD><FONT FACE="helvetica">
size &lt; 500
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/BULLET_GOES_HERE.gif">
					<TD><FONT FACE="helvetica">
(name = fido) || (size >= 500)
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/BULLET_GOES_HERE.gif">
					<TD><FONT FACE="helvetica">
(! ((name = *id*) || ( 'final utterance' = 'pass the salt'))) &amp;&amp; (last_modified > 1024563)
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<B>Push features:
<P>
</B><UL>
<LI> The <B><TT><A HREF="#PushOp()">PushOp()</A></TT></B> function takes operator symbols, such as <B><TT>B_EQ</TT></B> (equals), <B><TT>B_GT</TT></B> (greater than), <B><TT>B_LT</TT></B> (less than), and so on.  The complete list is given in the <B><TT><A HREF="#PushOp()">PushOp()</A></TT></B> function description.
<P>
<LI>Value strings passed as arguments to <B><TT><A HREF="#PushString()">PushString()</A></TT></B> are naturally quoted, so you don't have to single-quote to embed spaces or other odd characters.
<P>
<LI>The '*' wildcard is allowed, or you can use special "contains", "begins with", and "ends with" operators.
<P>
</UL>
<P>
In Reverse Polish Notation, the operator is postfixed.  You then push the components from left to right.  For example, this...
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/BULLET_GOES_HERE.gif">
					<TD><FONT FACE="helvetica">
size &lt; 500
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
...becomes...
<P>
&nbsp;&nbsp;&nbsp;size 500 &lt;
<P>
The push sequence is...
<P>
<PRE>&nbsp;&nbsp;&nbsp;query.PushAttr("size");
&nbsp;&nbsp;&nbsp;query.PushInt32(500);
&nbsp;&nbsp;&nbsp;query.PushOp(B_LT);</PRE>
<P>
Another example; this...
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/BULLET_GOES_HERE.gif">
					<TD><FONT FACE="helvetica">
(name = fido) || (size >= 500)
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
...becomes...
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/BULLET_GOES_HERE.gif">
					<TD><FONT FACE="helvetica">
(name fido =) (size 500 >=) ||
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
In code:
<P>
<PRE>&nbsp;&nbsp;&nbsp;query.PushAttr("name");
&nbsp;&nbsp;&nbsp;query.PushString("fido");
&nbsp;&nbsp;&nbsp;query.PushOp(B_EQ);
&nbsp;&nbsp;&nbsp;query.PushAttr("size");
&nbsp;&nbsp;&nbsp;query.PushInt32(500);
&nbsp;&nbsp;&nbsp;query.PushOp(B_GE);
&nbsp;&nbsp;&nbsp;query.PushOp(B_OR);</PRE>
<P>
There are no grouping operators in this notation; they're not needed&mdash;grouping is implied by the order in which the components are pushed.
<P>
When you're performing a numeric comparison, the <B><TT>Push...()</TT></B> function that you choose doesn't have to exactly match the natural type of the attribute, but you can't mix integers and floating point.  For example, even though "size" is a 64 bit value, you can compare it to an int32...
<P>
<PRE>&nbsp;&nbsp;&nbsp;query.PushAttr("size");
&nbsp;&nbsp;&nbsp;query.PushInt32(2000);
&nbsp;&nbsp;&nbsp;query.PushOp(B_GE);</PRE>
<P>
But you can't (or shouldn't) compare it to a float...
<P>
<PRE>&nbsp;&nbsp;&nbsp;query.PushAttr("size");
&nbsp;&nbsp;&nbsp;query.PushInt32(2000);
&nbsp;&nbsp;&nbsp;query.PushOp(B_GE);</PRE>
<P>
<HR>
<H3>
<A NAME="Query%20Update%20Messages"></A>Query Update Messages
</H3>
<P>
The BMessages that are delivered by a live query have a <B><TT>what</TT></B> field of <B><TT><A HREF="../Messages/GeneralMessages.html#B_QUERY_UPDATE">B_QUERY_UPDATE</A></TT></B>.  The rest of the message depends on what happened:
<P>
<UL>
<LI>If the update is telling you that an entry has passed the predicate, the message's "opcode" field will be <B><TT><A HREF="Directory.html#B_ENTRY_CREATED">B_ENTRY_CREATED</A></TT></B>.
<P>
<LI>If the update is telling you that an entry has been eliminated from the query, the "opcode" field will be <B><TT><A HREF="Directory.html#B_ENTRY_REMOVED">B_ENTRY_REMOVED</A></TT></B>.
<P>
</UL>
<P>
Note that the format of the messages that a live query generates are the same as the similarly-opcode'd Node Monitor messages.  The only difference is the <B><TT>what</TT></B> field (the what for Node Monitor messages is <B><TT><A HREF="../Messages/GeneralMessages.html#B_NODE_MONITOR">B_NODE_MONITOR</A></TT></B>).
<P>
<H4>
<A NAME="Entry%20Created"></A>Entry Created
</H4>
<P>
The <B><TT><A HREF="Directory.html#B_ENTRY_CREATED">B_ENTRY_CREATED</A></TT></B> opcode means an entry has changed so that it now passes the query's predicate.  The message's fields are:
<P>
<TABLE BORDER cellpadding=4>
<TH><B>Field</B></TH>
<TH><B>Type code</B></TH>
<TH><B>Description</TH>
<TR>
<TD></B>"opcode"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD><B><TT>B_ENTRY_CREATED</TD>
<TR>
<TD></TT></B>"name" </TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_STRING_TYPE">B_STRING_TYPE</A></TT></B></TD>
<TD>The name of the new entry.</TD>
<TR>
<TD>"directory"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT64_TYPE">B_INT64_TYPE</A></TT></B></TD>
<TD>The <B><TT>ino_t</TT></B> (node) number for the directory in which the entry was created.</TD>
<TR>
<TD>"device"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD>The <B><TT>dev_t</TT></B> number of the device on which the new entry resides.</TD>
<TR>
<TD>"node"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT64_TYPE">B_INT64_TYPE</A></TT></B></TD>
<TD>The <B><TT>ino_t</TT></B> number of the new entry itself.  (More accurately, it identifies the node that corresponds to the entry.)</TD>
</TABLE>
<P>
If you want to cache a reference to the entry, notice that you can create an <B><TT><A HREF="misc.html#entry_ref">entry_ref</A></TT></B> and a <B><TT><A HREF="misc.html#node_ref">node_ref</A></TT></B> with the data in the message's fields:
<P>
<PRE>&nbsp;&nbsp;&nbsp;/* Create an entry_ref */
&nbsp;&nbsp;&nbsp;entry_ref ref;
&nbsp;&nbsp;&nbsp;const char *name;
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;msg->FindInt32("device", &amp;ref.device);
&nbsp;&nbsp;&nbsp;msg->FindInt64("directory", &amp;ref.directory);
&nbsp;&nbsp;&nbsp;msg->FindString("name", &amp;name);
&nbsp;&nbsp;&nbsp;ref.set_name(name);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;/* Create a node_ref */
&nbsp;&nbsp;&nbsp;node_ref nref;
&nbsp;&nbsp;&nbsp;status_t err;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;msg->FindInt32("device", &amp;nref.device);
&nbsp;&nbsp;&nbsp;msg->FindInt64("node", &amp;nref.node);</PRE>
<P>
The <B><TT><A HREF="misc.html#node_ref">node_ref</A></TT></B> is handy because you may want to start monitoring the node (through a call to the Node Monitor).  We'll get back to this point when discussing <B><TT><A HREF="Directory.html#B_ENTRY_REMOVED">B_ENTRY_REMOVED</A></TT></B> messages.
<P>
<H4>
<A NAME="Entry%20Removed"></A>Entry Removed
</H4>
<P>
The <B><TT><A HREF="Directory.html#B_ENTRY_REMOVED">B_ENTRY_REMOVED</A></TT></B> opcode means an entry used to pass the predicate, but something has changed (in the entry or the entry's node) so that now it doesn't.
<P>
<TABLE BORDER cellpadding=4>
<TH><B>Field</B></TH>
<TH><B>Type code</B></TH>
<TH><B>Description</TH>
<TR>
<TD></B>"opcode"</TD>
<TD><B><TT>B_INT32_TYPE</TT></B></TD>
<TD><B><TT>B_ENTRY_REMOVED</TD>
<TR>
<TD></TT></B>"directory"</TD>
<TD><B><TT>B_INT64_TYPE</TT></B></TD>
<TD>The <B><TT>ino_t</TT></B> (node) number of the directory from which the entry was removed.</TD>
<TR>
<TD>"device"</TD>
<TD><B><TT>B_INT32_TYPE</TT></B></TD>
<TD>The <B><TT>dev_t</TT></B> number of the device that the removed node used to live on.</TD>
<TR>
<TD>"node"</TD>
<TD><B><TT>B_INT64_TYPE</TT></B></TD>
<TD>The <B><TT>ino_t</TT></B> number of the node that was removed.</TD>
</TABLE>
<P>
<B>Notice that the B_ENTRY_REMOVED message doesn't tell you the name of the entry. </B>This is an unfortunate oversight that will be corrected.  In the meantime, if you need to match the node in this message to an entry from a previous <B><TT><A HREF="Directory.html#B_ENTRY_CREATED">B_ENTRY_CREATED</A></TT></B> (or that you got from a <B><TT>GetNext...()</TT></B> invocation), you have to keep track of the entry/node yourself.  However, the location of the entry that "contains" the node may have changed since the time that the entry passed the predicate.  Follow this outline:
<P>
<B>1. </B>&nbsp;&nbsp;&nbsp;You set up a live query ask for entries that have nodes larger than 500 bytes.
<P>
<B>2. </B>&nbsp;&nbsp;&nbsp;The query mechanism tells you (either in the static set or through a <B><TT><A HREF="Directory.html#B_ENTRY_CREATED">B_ENTRY_CREATED</A></TT></B> message) that "/boot/home/fido/data" satisfies the predicate.
<P>
<B>3. </B>&nbsp;&nbsp;&nbsp;You create an <B><TT><A HREF="misc.html#entry_ref">entry_ref</A></TT></B> and a <B><TT><A HREF="misc.html#node_ref">node_ref</A></TT></B> to the entry, and cache them away somewhere.
<P>
<B>4. </B>&nbsp;&nbsp;&nbsp;<I>The user then renames or moves the entry.  </I>The query mechanism doesn't tell you about this change&mdash;it only cares about the size of the node, not its name
<P>
<B>5. </B>&nbsp;&nbsp;&nbsp;You get a <B><TT><A HREF="Directory.html#B_ENTRY_REMOVED">B_ENTRY_REMOVED</A></TT></B> message.  You create a <B><TT><A HREF="misc.html#node_ref">node_ref</A></TT></B> from the message and match it to your cache&mdash;and get an out-of-date <B><TT><A HREF="misc.html#entry_ref">entry_ref</A></TT></B>.
<P>
To get around the lack of a "name" field, you should monitor the nodes that you receive  in your initial <B><TT>GetNext...()</TT></B> calls and <B><TT><A HREF="Directory.html#B_ENTRY_CREATED">B_ENTRY_CREATED</A></TT></B> messages. 
<P>
<HR>
<H2>
<A NAME="Constructor%20and%20Destructor"></A><FONT SIZE=6>C</FONT>onstructor and <FONT SIZE=6>D</FONT>estructor
</H2>
<P>
<HR>
<H3>
<A NAME="BQuery()"></A>BQuery()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>BQuery(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Creates a new BQuery object.  To use the object, you have to set its predicate and volume, and then tell it to <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B>.  If you want to fetch again, you have to call <B><TT><A HREF="#Clear()">Clear()</A></TT></B> first (and re-set the predicate and volume.)
<P>
<HR>
<H3>
<A NAME="~BQuery()"></A>~BQuery()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual <B><TT><FONT  color=000022 size=+1>~BQuery()
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Destroys the BQuery.  If the query is live, the query is shot dead.  You stop receiving live query updates when you delete the BQuery object.
<P>
<HR>
<H2>
<A NAME="Member%20Functions"></A><FONT SIZE=6>M</FONT>ember <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="Clear()"></A>Clear()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>Clear(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Erases the BQuery's predicate, sets the volume and target to <B><TT>NULL</TT></B>, and turns off live query updates (if the query is live).  You call <B><TT><A HREF="#Clear()">Clear()</A></TT></B> if you want to <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B> more than once:  You have to <B><TT><A HREF="#Clear()">Clear()</A></TT></B> before each <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B> (except the first).
<P>
<b>RETURN CODES</b>
<P>
<B><TT>Clear()</TT></B> always return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.
<P>
<HR>
<H3>
<A NAME="CountEntries()"></A>CountEntries()
, 
<A NAME="Rewind()"></A>Rewind()
</H3>
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
Don't use these functions.  They're no-ops for the BQuery class.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="Fetch()"></A>Fetch()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t<B><TT><FONT  color=000022 size=+1> Fetch(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Tells the BQuery to go fetch the entries that satisfy the predicate.  After you've fetched, you can retrieve the set of "static" entries through calls to <B><TT><A HREF="#GetNextEntry()">GetNextEntry()</A></TT></B>, <B><TT><A HREF="#GetNextRef()">GetNextRef()</A></TT></B>, or <B><TT><A HREF="#GetNextDirents()">GetNextDirents()</A></TT></B>.
<P>
If you've set the BQuery's target, then this query is live.  The live query update messages start rolling in when you tell the object to <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B>.  They stop when you <B><TT><A HREF="#Clear()">Clear()</A> </TT></B>or destroy the object.
<P>
The fetch fails if the object's predicate or volume isn't set, or if you've already fetched but haven't <B><TT><A HREF="#Clear()">Clear()</A></TT></B>'d since then.
<P>
<b>RETURN CODES</b>
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The fetch is running.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_NO_INIT">B_NO_INIT</A></TT></B>.  The volume or predicate isn't set.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_VALUE">B_BAD_VALUE</A></TT></B>.  The predicate is improper.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_NOT_ALLOWED">B_NOT_ALLOWED</A></TT></B>.  You've already fetched; <B><TT><A HREF="#Clear()">Clear()</A></TT></B> the object and start again.
<P>
</UL>
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
Every query must include at least one indexed attribute.  If your predicate includes no indexed attributes, <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B> will not balk&mdash;it returns <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B> (given that it doesn't otherwise fail).  However, no entries will have been retrieved, and your subsequent <B><TT>GetNext...()</TT></B> call will fail (<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_VALUE">B_BAD_VALUE</A></TT></B>).
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H3>
<A NAME="GetNextEntry()"></A>GetNextEntry()
, 
<A NAME="GetNextRef()"></A>GetNextRef()
, 
<A NAME="GetNextDirents()"></A>GetNextDirents()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>GetNextEntry(</TT></B></FONT><A HREF="Entry.html#BEntry">BEntry</A> *<I><FONT  color=991122 face=HELVETICA>entry</I></FONT>, bool <I><FONT  color=991122 face=HELVETICA>traverse = false</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>GetNextRef(</TT></B></FONT>entry_ref *<I><FONT  color=991122 face=HELVETICA>ref</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
virtual int32 <B><TT><FONT  color=000022 size=+1>GetNextDirents(</TT></B></FONT>dirent *<I><FONT  color=991122 face=HELVETICA>buf</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>bufsize</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>count = INT_MAX</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions return the next entry in the "static" entry list; the list is created when you tell your (well-formed) BQuery to <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B>.  You can retrieve the entry as a <A HREF="Entry.html#BEntry">BEntry</A>, <B><TT><A HREF="misc.html#entry_ref">entry_ref</A></TT></B>, or <B><TT>dirent</TT></B> structure.   The static entry list is the set of entries that initially satisfy the predicate; entries found by the live query mechanism are not included in this list.   
<P>
When you reach the end of the entry list, the <B><TT>Get...()</TT></B> function returns an indicative value:
<P>
<UL>
<LI><B><TT>GetNextRef()</TT></B> and <B><TT>GetNextEntry()</TT></B> return <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ENTRY_NOT_FOUND">B_ENTRY_NOT_FOUND</A></TT></B>.
<P>
<LI><B><TT>GetNextDirents() </TT></B>returns 0. 
<P>
</UL>
<P>
You can only cycle over the list once; the <B><TT><A HREF="#Rewind()">Rewind()</A></TT></B> function is not defined for BQuery.  See the <A HREF="EntryList.html#BEntryList">BEntryList</A> class for more information on these functions.
<P>
<b>RETURN CODES</b>
<P>
<B><TT>GetNextDirents()</TT></B> returns the number of <B><TT>dirent</TT></B>s it retrieved (currently, it can only retrieve one at a time.  The other two functions return these codes:
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The entry was retrieved.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ENTRY_NOT_FOUND">B_ENTRY_NOT_FOUND</A></TT></B>.  You're at the end of the list.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_VALUE">B_BAD_VALUE</A></TT></B>.  The predicate includes unindexed attributes.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_FILE_ERROR">B_FILE_ERROR</A></TT></B>.  The BQuery hasn't fetched.
<P>
</UL>
<P>
<HR>
<H3>GetPredicate()   see  <A HREF="#SetPredicate()">SetPredicate()</A></H3>
<P>
<HR>
<H3>IsLive()   see  <A HREF="#SetTarget()">SetTarget()</A></H3>
<P>
<HR>
<H3>PredicateLength()   see  <A HREF="#SetPredicate()">SetPredicate()</A></H3>
<P>
<HR>
<H3>
<A NAME="PushAttr()"></A>PushAttr()
, 
<A NAME="PushOp()"></A>PushOp()
, 
<A NAME="PushUInt32()"></A>PushUInt32()
, 
<A NAME="PushInt32()"></A>PushInt32()
, 
<A NAME="PushUInt64()"></A>PushUInt64()
, 
<A NAME="PushInt64()"></A>PushInt64()
, 
<A NAME="PushFloat()"></A>PushFloat()
, 
<A NAME="PushDouble()"></A>PushDouble()
, 
<A NAME="PushString()"></A>PushString()
, 
<A NAME="query_op"></A>query_op
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>PushAttr(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>attr_name</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>PushOp(</TT></B></FONT>query_op <I><FONT  color=991122 face=HELVETICA>operator</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>PushUInt32(</TT></B></FONT>uint32 <I><FONT  color=991122 face=HELVETICA>value</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>PushInt32(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>value</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>PushUInt64(</TT></B></FONT>uint64 <I><FONT  color=991122 face=HELVETICA>value</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>PushInt64(</TT></B></FONT>int64 <I><FONT  color=991122 face=HELVETICA>value</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>PushFloat(</TT></B></FONT>float <I><FONT  color=991122 face=HELVETICA>value</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>PushDouble(</TT></B></FONT>double <I><FONT  color=991122 face=HELVETICA>value</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
void <B><TT><FONT  color=000022 size=+1>PushString(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>string</I></FONT>, bool <I><FONT  color=991122 face=HELVETICA>case_insensitive = false</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
You use these functions to construct the BQuery's predicate.  They create a predicate expression by pushing  attribute names, operators, and values in Reverse Polish Notation (post-fix) order.
<P>
<UL>
<LI><B><TT>PushAttr()</TT></B> pushes an attribute name.
<P>
<LI><B><TT>PushOp()</TT></B> pushes one of the <B><TT>query_op</TT></B> operators listed below.
<P>
<LI>The rest of the functions push values of the designated types. 
<P>
</UL>
<P>
For details on how the push method works, see "<a href="#Constructing%20a%20Predicate">Constructing a Predicate</a>."
<P>
The predicate that you construct through these functions can be returned as a string through the <B><TT><A HREF="#GetPredicate()">GetPredicate()</A></TT></B> function.
<P>
The <B><TT>query_op</TT></B> constants are:
<P>
<TABLE BORDER cellpadding=4>
<TH>Constant</TH>
<TH>Operation</TH>
<TR>
<TD><B><TT>B_EQ</TT></B></TD>
<TD>=</TD>
<TR>
<TD><B><TT>B_NE</TT></B></TD>
<TD>!=</TD>
<TR>
<TD><B><TT>B_GT</TT></B></TD>
<TD>></TD>
<TR>
<TD><B><TT>B_LT</TT></B></TD>
<TD>&lt;</TD>
<TR>
<TD><B><TT>B_GE</TT></B></TD>
<TD>>=</TD>
<TR>
<TD><B><TT>B_LE</TT></B></TD>
<TD>&lt;=</TD>
<TR>
<TD><B><TT>B_CONTAINS</TT></B></TD>
<TD>string contains value ("*<I>value</I>*")</TD>
<TR>
<TD><B><TT>B_BEGINS_WITH</TT></B></TD>
<TD>string begins with value ("<I>value*</I>")</TD>
<TR>
<TD><B><TT>B_ENDS_WITH</TT></B></TD>
<TD>string ends with value ("*<I>value</I>")</TD>
<TR>
<TD><B><TT>B_AND</TT></B></TD>
<TD>&amp;&amp;</TD>
<TR>
<TD><B><TT>B_OR</TT></B></TD>
<TD>||</TD>
<TR>
<TD><B><TT>B_NOT</TT></B></TD>
<TD>!</TD>
</TABLE>
<P>
<HR>
<H3>Rewind()   see  <A HREF="#CountEntries()">CountEntries()</A></H3>
<P>
<HR>
<H3>
<A NAME="SetTarget()"></A>SetTarget()
, 
<A NAME="IsLive()"></A>IsLive()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SetTarget(</TT></B></FONT><A HREF="../The%20Application%20Kit/Messenger.html#BMessenger">BMessenger</A> <I><FONT  color=991122 face=HELVETICA>target</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>IsLive(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Sets the BQuery's target.  The target identifies the BLooper/BHandler pair (<I>a la</I> the <A HREF="../The%20Application%20Kit/Invoker.html#BInvoker">BInvoker</A> target protocol) that will receive subsequent live query update messages.  Calling this function declares the query to be live.
<P>
If <I><FONT  color=991122 face=HELVETICA>target</I></FONT> is <B><TT>NULL</TT></B>, the BQuery is told to be "not live".  However, you can only turn off liveness (in this way) before you <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B>.  In other words, if you set the target, and then call <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B> and <I>then</I> call <B><TT>SetTarget(<FONT  face=HELVETICA>NULL)</TT></B></FONT>, the BQuery will think that it (itself) is not live, but it really is.
<P>
<B><TT><A HREF="#IsLive()">IsLive()</A></TT></B> tells you if the BQuery is live.  The "liveness" needn't be actuated yet&mdash;live queries don't start operating until you tell the BQuery to <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B>.  The live query is killed when you delete or <B><TT><A HREF="#Clear()">Clear()</A></TT></B> the BQuery object.
<P>
<b>RETURN CODES</b>
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The target was set (including set to <B><TT>NULL</TT></B>).
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_VALUE">B_BAD_VALUE</A></TT></B>.  target doesn't identify a proper looper/handler pair.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_NOT_ALLOWED">B_NOT_ALLOWED</A></TT></B>.  You've already <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B>'d; you need to <B><TT><A HREF="#Clear()">Clear()</A></TT></B>.  
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="SetPredicate()"></A>SetPredicate()
, 
<A NAME="GetPredicate()"></A>GetPredicate()
, 
<A NAME="PredicateLength()"></A>PredicateLength()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SetPredicate(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>expr</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
status_t<B><TT><FONT  color=000022 size=+1> GetPredicate(</TT></B></FONT>char *<I><FONT  color=991122 face=HELVETICA>buf</I></FONT>, size_t <I><FONT  color=991122 face=HELVETICA>length</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
size_t <B><TT><FONT  color=000022 size=+1>PredicateLength(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT><A HREF="#SetPredicate()">SetPredicate()</A></TT></B> sets the BQuery's predicate as a string.  Predicate strings can be simple, single comparison expressions:
<P>
<PRE>&nbsp;&nbsp;&nbsp;"name = fido"</PRE>
<P>
Or they can be more complex:
<P>
<PRE>&nbsp;&nbsp;&nbsp;"((name = fid*) || (size > 500)) &amp;&amp; (last_modified &lt; 243567)"</PRE>
<P>
For the complete rules on setting the predicate as a string, see "<a href="#Constructing%20a%20Predicate">Constructing a Predicate</a>."
<P>
You can also set the predicate through the <B><TT>Push...() </TT></B>functions.  You can't combine the methods: Pushing the predicate <I>always</I> takes precedence over <B><TT><A HREF="#SetPredicate()">SetPredicate()</A></TT></B>, regardless of the order in which the methods are deployed.   
<P>
<B><TT>GetPredicate() </TT></B>copies the predicate into <I><FONT  color=991122 face=HELVETICA>buf</I></FONT>; <I><FONT  color=991122 face=HELVETICA>length</I></FONT> gives the length of <I><FONT  color=991122 face=HELVETICA>buf,</I></FONT> in bytes.  If you want to find out how much storage you need to allocate to accommodate the predicate, call <B><TT>PredicateLength()</TT></B> first.
<P>
If you set the predicate through the<B><TT> Push...()</TT></B> functions, <B><TT><A HREF="#GetPredicate()">GetPredicate()</A></TT></B> converts the pushed construction into a string, and returns a copy of the string to you.
<P>
<B><TT>PredicateLength()</TT></B> returns the length of the predicate string, regardless of how it's created.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
<B>GetPredicate() and PredicateLength() both clear the push stack.</B>  This is important, because it means that you can't build up a portion of your predicate, then call <B><TT>GetPredicate()</TT></B>, build a little more, look again, build some more, etc.  When you call <B><TT>GetPredicate()</TT></B>, you're done.  Your next step should be a <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B>.
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<b>RETURN CODES</b>
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The predicate was successfully set or gotten.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_NO_INIT">B_NO_INIT</A></TT></B>.  (<B><TT>Get</TT></B>)  The predicate isn't set.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_BAD_VALUE">B_BAD_VALUE</A></TT></B>.  (<B><TT>Get</TT></B>) <I><FONT  color=991122 face=HELVETICA>length</I></FONT> is shorter than the predicate's length.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_NOT_ALLOWED">B_NOT_ALLOWED</A></TT></B>.  (<B><TT>Set</TT></B>)  You've already <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B>'d; you have to <B><TT><A HREF="#Clear()">Clear()</A></TT></B>.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_NO_MEMORY">B_NO_MEMORY</A></TT></B>.  (<B><TT>Set</TT></B>) Not enough memory to store the predicate string.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="SetVolume()"></A>SetVolume()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
status_t <B><TT><FONT  color=000022 size=+1>SetVolume(</TT></B></FONT>const <A HREF="Volume.html#BVolume">BVolume</A> *<I><FONT  color=991122 face=HELVETICA>volume</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
A query can only look in one volume at a time.  This is where you set the volume that you want to look at.  
<P>
<b>RETURN CODES</b>
<P>
<UL>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.  The volume was set.
<P>
<LI><B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_NOT_ALLOWED">B_NOT_ALLOWED</A></TT></B>.  You've already fetched, you need to <B><TT><A HREF="#Clear()">Clear()</A></TT></B> before you can reset the volume. 
<P>
</UL>
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
Currently, <B><TT><A HREF="#SetVolume()">SetVolume()</A></TT></B> doesn't complain if <I><FONT  color=991122 face=HELVETICA>volume</I></FONT> is invalid.  However, the subsequent <B><TT><A HREF="#Fetch()">Fetch()</A></TT></B> will fail (<B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_NO_INIT">B_NO_INIT</A></TT></B>).
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Storage Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Storage%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Storage Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

