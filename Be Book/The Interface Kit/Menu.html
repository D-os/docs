<HTML><HEAD><TITLE>The Interface Kit: BMenu</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Interface Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Interface%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Interface Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="BMenu"></A>BMenu
</H1>
<P>
Derived from:  public <A HREF="View.html#BView">BView</A>
<P>
Declared in:  <A HREF="/boot/develop/headers/be/interface/Menu.h">be/interface/Menu.h</A>
<P>
Library:  libbe.so
<P>
<H6><A HREF="Menu.summary.html"><i>Summary</i></A></H6>
<P>
A BMenu object displays a pull-down or pop-up list of menu items.  A menu can contain simple menu items (BMenuItem objects), or other menus (other BMenus).  To add an item to a menu, call <B><TT><A HREF="#AddItem()">AddItem()</A></TT></B>.  
<P>
<HR>
<H3>
<A NAME="Menu%20Hierarchy"></A>Menu Hierarchy
</H3>
<P>
Menus are hierarchically arranged; an item in one menu can control another menu.  The controlled menu is a <I>submenu</I>; the menu that contains the item that controls it is its <I>supermenu</I>.  A submenu remains hidden until the user operates the item that controls it; it becomes hidden again when the user is finished with it.
<P>
The menu at the root of the hierarchy is displayed in a window as a list&mdash;perhaps a list of just one item.  Since it, unlike other menus, doesn't have a controlling item, it must remain visible.  A root menu is therefore a special kind of menu in that it behaves more like an ordinary view than do other menus, which stay hidden.   Root menus should belong to the <A HREF="MenuBar.html#BMenuBar">BMenuBar</A> class, which is derived from BMenu.  The typical root menu is a menu bar displayed across the top of a window.
<P>
<HR>
<H3>
<A NAME="Menu%20Items"></A>Menu Items
</H3>
<P>
Each item in a menu is a kind of <A HREF="MenuItem.html#BMenuItem">BMenuItem</A> object.  An item can be marked (displayed with a check mark to its left), assigned a keyboard shortcut, enabled and disabled, and given a "trigger" character that the user can type to invoke the item when its menu is open on-screen.
<P>
Every item has a particular job to do.  If an item controls a submenu, its job is to show the submenu on-screen and hide it again.  All other items give instructions to the application.  When invoked by the user, they deliver a <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> to a target BHandler.  What the item does depends on the content of the <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> and the BHandler's response to it.
<P>
<HR>
<H2>
<A NAME="Hook%20Functions"></A><FONT SIZE=6>H</FONT>ook <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<B><TT><A HREF="#ScreenLocation()">ScreenLocation()</A></TT></B>&nbsp;&nbsp;&nbsp;Can be implemented to have the menu appear on-screen at some location other than the default.
<P>
<HR>
<H2>
<A NAME="Constructor%20and%20Destructor"></A><FONT SIZE=6>C</FONT>onstructor and <FONT SIZE=6>D</FONT>estructor
</H2>
<P>
<HR>
<H3>
<A NAME="BMenu()"></A>BMenu()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<B><TT><FONT  color=000022 size=+1>BMenu(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>name</I></FONT>, menu_layout&nbsp;<I><FONT  color=991122 face=HELVETICA>layout</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>B_ITEMS_IN_COLUMN</FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
<B><TT><FONT  color=000022 size=+1>BMenu(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>name</I></FONT>, float <I><FONT  color=991122 face=HELVETICA>width</I></FONT>, float <I><FONT  color=991122 face=HELVETICA>height</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
<B><TT><FONT  color=000022 size=+1>BMenu(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>archive</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
<B><TT><FONT  color=000022 size=+1>BMenu(</TT></B></FONT><A HREF="Rect.html#BRect">BRect</A> <I><FONT  color=991122 face=HELVETICA>frame</I></FONT>, const char *<I><FONT  color=991122 face=HELVETICA>name</I></FONT>, uint32 <I><FONT  color=991122 face=HELVETICA>resizingMode</I></FONT>, uint32 <I><FONT  color=991122 face=HELVETICA>flags</I></FONT>, menu_layout <I><FONT  color=991122 face=HELVETICA>layout</I></FONT>, bool <I><FONT  color=991122 face=HELVETICA>resizeToFit</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Initializes the BMenu object.  The <I><FONT  color=991122 face=HELVETICA>name</I></FONT> of the object becomes the initial label of the supermenu item that controls the menu and brings it to the screen.  (It's also the name that can be passed to BView's <B><TT><A HREF="Bitmap.html#FindView()">FindView()</A></TT></B> function.)
<P>
A new BMenu object doesn't contain any items; you need to call <B><TT><A HREF="#AddItem()">AddItem()</A></TT></B> to set up its contents.
<P>
A menu can arrange its items in any of three ways:
<P>
<B><TT><A NAME="B_ITEMS_IN_COLUMN"></A>B_ITEMS_IN_COLUMN
<br>
</TT></B>The items are stacked vertically in a column, one on top of the other, as in a typical menu.
<P>
<B><TT><A NAME="B_ITEMS_IN_ROW"></A>B_ITEMS_IN_ROW
<br>
</TT></B>The items are laid out horizontally in a row, from end to end, as in a typical menu bar.
<P>
<B><TT><A NAME="B_ITEMS_IN_MATRIX"></A>B_ITEMS_IN_MATRIX
<br>
</TT></B>The items are arranged in a custom fashion, such as a matrix.
<P>
Either <B><TT><A HREF="#B_ITEMS_IN_ROW">B_ITEMS_IN_ROW</A></TT></B> or the default <B><TT><A HREF="#B_ITEMS_IN_COLUMN">B_ITEMS_IN_COLUMN</A></TT></B> can be passed as the <I><FONT  color=991122 face=HELVETICA>layout</I></FONT> argument to the public constructor.  (A column is the default for ordinary menus; a row is the default for BMenuBars.)  This version of the constructor isn't designed for <B><TT><A HREF="#B_ITEMS_IN_MATRIX">B_ITEMS_IN_MATRIX</A></TT></B> layouts.
<P>
A BMenu object can arrange items that are laid out in a column or a row entirely on its own.  The menu will be resized to exactly fit the items that are added to it.
<P>
However, when items are laid out in a custom matrix, the menu needs more help.  First, the constructor must be informed of the exact <I><FONT  color=991122 face=HELVETICA>width</I></FONT> and <I><FONT  color=991122 face=HELVETICA>height</I></FONT> of the menu rectangle.  The version of the constructor that takes these two parameters is designed just for matrix menus&mdash;it sets the layout to <B><TT><A HREF="#B_ITEMS_IN_MATRIX">B_ITEMS_IN_MATRIX</A></TT></B>.  Then, when items are added to the menu, the BMenu object expects to be informed of their precise positions within the specified area.  The menu is <I>not</I> resized to fit the items that are added.  Finally, when items in the matrix change, you must take care of any required adjustments in the layout yourself.
<P>
The protected version of the constructor is supplied for derived classes that don't simply devise different sorts of menu items or arrange them in a different way, but invent a different kind of menu.  If the <I><FONT  color=991122 face=HELVETICA>resizeToFit</I></FONT> flag is <B><TT>true</TT></B>, it's expected that the <I><FONT  color=991122 face=HELVETICA>layout</I></FONT> will be <B><TT><A HREF="#B_ITEMS_IN_COLUMN">B_ITEMS_IN_COLUMN</A></TT></B> or <B><TT><A HREF="#B_ITEMS_IN_ROW">B_ITEMS_IN_ROW</A></TT></B>.  The menu will resize itself to fit the items that are added to it.  If the layout is <B><TT><A HREF="#B_ITEMS_IN_MATRIX">B_ITEMS_IN_MATRIX</A></TT></B>, the <I><FONT  color=991122 face=HELVETICA>resizeToFit</I></FONT> flag should be <B><TT>false</TT></B>.
<P>
<HR>
<H3>
<A NAME="~BMenu()"></A>~BMenu()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual <B><TT><FONT  color=000022 size=+1>~BMenu()
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Deletes all the items that were added to the menu and frees all memory allocated by the BMenu object.  Deleting the items serves also to delete any submenus those items control and, thus, the whole branch of the menu hierarchy.
<P>
<HR>
<H2>
<A NAME="Static%20Functions"></A><FONT SIZE=6>S</FONT>tatic <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="Instantiate()"></A>Instantiate()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
static <A HREF="../The%20Support%20Kit/Archivable.html#BArchivable">BArchivable</A> *<B><TT><FONT  color=000022 size=+1>Instantiate(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>archive</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> 
<P>

</TABLE></TABLE>

<P>
Returns a new BMenu object, allocated by <B><TT>new</TT></B> and created with the version of the constructor that takes a <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> <I><FONT  color=991122 face=HELVETICA>archive</I></FONT>.  However, if the <I><FONT  color=991122 face=HELVETICA>archive</I></FONT> message doesn't contain data for a BMenu object, <B><TT><A HREF="#Instantiate()">Instantiate()</A></TT></B> returns <B><TT>NULL</TT></B>.
<P>
<B>See also:  <TT><A HREF="../The%20Support%20Kit/Archivable.html#Instantiate()">BArchivable::Instantiate()</A></TT></B>, <B><TT><A HREF="../The%20Support%20Kit/Functions.html#instantiate_object()">instantiate_object()</A></TT></B>, <B><TT><A HREF="#Archive()">Archive()</A></TT></B>  
<P>
<HR>
<H2>
<A NAME="Member%20Functions"></A><FONT SIZE=6>M</FONT>ember <FONT SIZE=6>F</FONT>unctions
</H2>
<P>
<HR>
<H3>
<A NAME="AddItem()"></A>AddItem()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>AddItem(</TT></B></FONT><A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<I><FONT  color=991122 face=HELVETICA>item</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>AddItem(</TT></B></FONT><A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<I><FONT  color=991122 face=HELVETICA>item</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>index</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>AddItem(</TT></B></FONT><A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<I><FONT  color=991122 face=HELVETICA>item</I></FONT>, <A HREF="Rect.html#BRect">BRect</A> <I><FONT  color=991122 face=HELVETICA>frame</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>AddItem(</TT></B></FONT>BMenu *<I><FONT  color=991122 face=HELVETICA>submenu</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>AddItem(</TT></B></FONT>BMenu *<I><FONT  color=991122 face=HELVETICA>submenu</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>index</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>AddItem(</TT></B></FONT>BMenu *<I><FONT  color=991122 face=HELVETICA>submenu</I></FONT>, <A HREF="Rect.html#BRect">BRect</A> <I><FONT  color=991122 face=HELVETICA>frame</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Adds an item to the menu list at <I><FONT  color=991122 face=HELVETICA>index</I></FONT>&mdash;or, if no <I><FONT  color=991122 face=HELVETICA>index</I></FONT> is mentioned, to the end of the list.  If items are arranged in a matrix rather than a list, it's necessary to specify the item's <I><FONT  color=991122 face=HELVETICA>frame</I></FONT> rectangle&mdash;the exact position where it should be located in the menu view.  Assume a coordinate system for the menu that has the origin, (0.0,&nbsp;0.0), at the left top corner of the view rectangle.  The rectangle will have the width and height that were specified when the menu was constructed.
<P>
The versions of this function that take an <I><FONT  color=991122 face=HELVETICA>index</I></FONT> (even an implicit one) can be used only if the menu arranges items in a column or row (<B><TT><A HREF="#B_ITEMS_IN_COLUMN">B_ITEMS_IN_COLUMN</A></TT></B> or <B><TT><A HREF="#B_ITEMS_IN_ROW">B_ITEMS_IN_ROW</A></TT></B>); it's an error to use them for items arranged in a matrix.  Conversely, the versions of this function that take a <I><FONT  color=991122 face=HELVETICA>frame</I></FONT> rectangle can be used only if the menu arranges items in a matrix (<B><TT><A HREF="#B_ITEMS_IN_MATRIX">B_ITEMS_IN_MATRIX</A></TT></B>); it's an error to use them for items arranged in a list.
<P>
If a <I><FONT  color=991122 face=HELVETICA>submenu</I></FONT> is specified rather than an <I><FONT  color=991122 face=HELVETICA>item</I></FONT>, <B><TT><A HREF="#AddItem()">AddItem()</A></TT></B> constructs a controlling <A HREF="MenuItem.html#BMenuItem">BMenuItem</A> for the submenu and adds the item to the menu.
<P>
If it's unable to add the item to the menu&mdash;for example, if the <I><FONT  color=991122 face=HELVETICA>index</I></FONT> is out-of-range or the wrong version of the function has been called&mdash;<B><TT><A HREF="#AddItem()">AddItem()</A></TT></B> returns <B><TT>false</TT></B>.  If successful, it returns <B><TT>true</TT></B>.
<P>
<B>See also:  </B>the BMenu constructor, the <A HREF="MenuItem.html#BMenuItem">BMenuItem</A> class, <B><TT><A HREF="#RemoveItem()">RemoveItem()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="AddSeparatorItem()"></A>AddSeparatorItem()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>AddSeparatorItem(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Creates an instance of the BSeparatorItem class and adds it to the end of the menu list, returning <B><TT>true</TT></B> if successful and <B><TT>false</TT></B> if not (a very unlikely possibility).  This function is a shorthand for:
<P>
<PRE>&nbsp;&nbsp;&nbsp;BSeparatorItem *separator = new BSeparatorItem;
&nbsp;&nbsp;&nbsp;AddItem(separator);</PRE>
<P>
A separator serves only to separate other items in the list.  It counts as an item and has an indexed position in the list, but it doesn't do anything.  It's drawn as a horizontal line across the menu.  Therefore, it's appropriately added only to menus where the items are laid out in a column.
<P>
<B>See also:  <TT><A HREF="#AddItem()">AddItem()</A></TT></B>, the BSeparatorItem class
<P>
<HR>
<H3>
<A NAME="Archive()"></A>Archive()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>Archive(</TT></B></FONT><A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> *<I><FONT  color=991122 face=HELVETICA>archive</I></FONT>, bool&nbsp;<I><FONT  color=991122 face=HELVETICA>deep</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>true</FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT>&nbsp;const
<P>

</TABLE></TABLE>

<P>
Calls the inherited version of <B><TT><A HREF="#Archive()">Archive()</A></TT></B>, then archives the BMenu by recording its layout and all current settings in the <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> <I><FONT  color=991122 face=HELVETICA>archive</I></FONT>.  If the <I><FONT  color=991122 face=HELVETICA>deep</I></FONT> flag is <B><TT>true</TT></B>, all of the menu items are also archived.
<P>
<B>See also:  <TT><A HREF="../The%20Support%20Kit/Archivable.html#Archive()">BArchivable::Archive()</A></TT></B>, <B><TT><A HREF="#Instantiate()">Instantiate()</A></TT></B> static function 
<P>
<HR>
<H3>AreTriggersEnabled()   see <A HREF="#SetTriggersEnabled()">SetTriggersEnabled()</A></H3>
<P>
<HR>
<H3>
<A NAME="AttachedToWindow()"></A>AttachedToWindow()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>AttachedToWindow(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Finishes initializing the BMenu object by laying out its items and resizing the BMenu view to fit.  This function is called for you each time the BMenu is assigned to a window.  For a submenu, that means each time the menu is shown on-screen.
<P>
<B>See also:  <TT>BView::AttachedToWindow()</TT></B> 
<P>
<HR>
<H3>
<A NAME="CountItems()"></A>CountItems()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>CountItems(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Returns the total number of items in the menu, including separator items.
<P>
<HR>
<H3>
<A NAME="Draw()"></A>Draw()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Draw(</TT></B></FONT><A HREF="Rect.html#BRect">BRect</A> <I><FONT  color=991122 face=HELVETICA>updateRect</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Draws the menu.  This function is called for you whenever the menu is placed on-screen or is updated while on-screen.  It's not a function you need to call yourself.
<P>
<B>See also:  <TT>BView::Draw()</TT></B> 
<P>
<HR>
<H3>
<A NAME="FindItem()"></A>FindItem()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<B><TT><FONT  color=000022 size=+1>FindItem(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>label</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

<TR><TD>
<A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<B><TT><FONT  color=000022 size=+1>FindItem(</TT></B></FONT>uint32 <I><FONT  color=991122 face=HELVETICA>command</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Returns the item with the specified <I><FONT  color=991122 face=HELVETICA>label</I></FONT>&mdash;or the one that sends a message with the specified <I><FONT  color=991122 face=HELVETICA>command</I></FONT>.  If there's more than one item in the menu hierarchy with that particular <I><FONT  color=991122 face=HELVETICA>label</I></FONT> or associated with that particular <I><FONT  color=991122 face=HELVETICA>command</I></FONT>, this function returns the first one it finds.  It recursively searches the menu by working down the list of items in order.  If an item controls a submenu, it searches the submenu before returning to check any remaining items in the menu.
<P>
If none of the items in the menu hierarchy meet the stated criterion, <B><TT><A HREF="#FindItem()">FindItem()</A></TT></B> returns <B><TT>NULL</TT></B>.
<P>
<HR>
<H3>
<A NAME="FindMarked()"></A>FindMarked()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<B><TT><FONT  color=000022 size=+1>FindMarked(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns the first marked item in the menu list (the one with the lowest index), or <B><TT>NULL</TT></B> if no item is marked.
<P>
<B>See also:  <TT><A HREF="#SetRadioMode()">SetRadioMode()</A></TT></B>, <B><TT><A HREF="MenuItem.html#SetMarked()">BMenuItem::SetMarked()</A></TT></B> 
<P>
<HR>
<H3>GetMaxContentWidth()   see <A HREF="#SetMaxContentWidth()">SetMaxContentWidth()</A></H3>
<P>
<HR>
<H3>
<A NAME="Hide()"></A>Hide()
, 
<A NAME="Show()"></A>Show()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>Hide(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>Show(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>selectFirst</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>Show(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions hide the menu (remove the BMenu view from the window it's in and remove the window from the screen) and show it (attach the BMenu to a window and place the window on-screen).  If the <I><FONT  color=991122 face=HELVETICA>selectFirst</I></FONT> flag passed to <B><TT><A HREF="#Show()">Show()</A></TT></B> is <B><TT>true</TT></B>, the first item in the menu will be selected when it's shown.  If <I><FONT  color=991122 face=HELVETICA>selectFirst</I></FONT> is <B><TT>false</TT></B>, the menu is shown without a selected item.
<P>
The version of <B><TT><A HREF="#Show()">Show()</A></TT></B> that doesn't take an argument simply calls the version that does and passes it a <I><FONT  color=991122 face=HELVETICA>selectFirst</I></FONT> value of <B><TT>false</TT></B>.
<P>
These functions are not ones that you'd ordinarily call, even when implementing a derived class.  You'd need them only if you're implementing a nonstandard menu of some kind and want to control when the menu appears on-screen.
<P>
<B>See also:  <TT>BView::Show()</TT></B>, <B><TT><A HREF="#Track()">Track()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="IndexOf()"></A>IndexOf()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>IndexOf(</TT></B></FONT><A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<I><FONT  color=991122 face=HELVETICA>item</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

<TR><TD>
int32 <B><TT><FONT  color=000022 size=+1>IndexOf(</TT></B></FONT>BMenu *<I><FONT  color=991122 face=HELVETICA>submenu</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Returns the index of the specified menu <I><FONT  color=991122 face=HELVETICA>item</I></FONT>&mdash;or the item that controls the specified <I><FONT  color=991122 face=HELVETICA>submenu</I></FONT>.  Indices record the position of the item in the menu list.  They begin at 0 for the item at the top of a column or at the left of a row and include separator items.
<P>
If the menu doesn't contain the specified <I><FONT  color=991122 face=HELVETICA>item</I></FONT>, or the item that controls <I><FONT  color=991122 face=HELVETICA>submenu</I></FONT>, the return value will be <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_ERROR">B_ERROR</A></TT></B>.
<P>
<B>See also:  <TT><A HREF="#AddItem()">AddItem()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="InvalidateLayout()"></A>InvalidateLayout()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>InvalidateLayout(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Forces the BMenu to recalculate the layout of all menu items and, consequently, its own size.  It can do this only if the items are arranged in a row or a column.  If the items are arranged in a matrix, it's up to you to keep their layout up-to-date.
<P>
All BMenu and <A HREF="MenuItem.html#BMenuItem">BMenuItem</A> functions that change an item in a way that might affect the overall menu automatically invalidate the menu's layout so it will be recalculated.  For example, changing the label of an item might cause the menu to become wider (if it needs more room to accommodate the longer label) or narrower (if it no longer needs as much room as before).  
<P>
Therefore, you don't need to call <B><TT><A HREF="#InvalidateLayout()">InvalidateLayout()</A></TT></B> after using a kit function to change a menu or menu item; it's called for you.  You'd call it only when making some other change to a menu.
<P>
<B>See also:  </B>the BMenu constructor
<P>
<HR>
<H3>IsEnabled()   see <A HREF="#SetEnabled()">SetEnabled()</A></H3>
<P>
<HR>
<H3>IsLabelFromMarked()   see <A HREF="#SetLabelFromMarked()">SetLabelFromMarked()</A></H3>
<P>
<HR>
<H3>IsRadioMode()   see <A HREF="#SetRadioMode()">SetRadioMode()</A></H3>
<P>
<HR>
<H3>
<A NAME="ItemAt()"></A>ItemAt()
, 
<A NAME="SubmenuAt()"></A>SubmenuAt()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<B><TT><FONT  color=000022 size=+1>ItemAt(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>index</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>


<TR><TD>
BMenu *<B><TT><FONT  color=000022 size=+1>SubmenuAt(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>index</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
These functions return the item at <I><FONT  color=991122 face=HELVETICA>index</I></FONT>&mdash;or the submenu controlled by the item at <I><FONT  color=991122 face=HELVETICA>index</I></FONT>.  If there's no item at the index, they return <B><TT>NULL</TT></B>.  <B><TT><A HREF="#SubmenuAt()">SubmenuAt()</A></TT></B> is a shorthand for:
<P>
<PRE>&nbsp;&nbsp;&nbsp;ItemAt(index)->Submenu()</PRE>
<P>
It returns <B><TT>NULL</TT></B> if the item at <I><FONT  color=991122 face=HELVETICA>index</I></FONT> doesn't control a submenu.
<P>
<B>See also:  <TT><A HREF="#AddItem()">AddItem()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="KeyDown()"></A>KeyDown()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>KeyDown(</TT></B></FONT>const char *<I><FONT  color=991122 face=HELVETICA>bytes</I></FONT>, int32 <I><FONT  color=991122 face=HELVETICA>numBytes</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Handles keyboard navigation through the menu.  This function is called to respond to messages reporting key-down events.  It should not be called from application code.
<P>
<B>See also:  <TT>BView::KeyDown()</TT></B> 
<P>
<HR>
<H3>
<A NAME="Layout()"></A>Layout()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
menu_layout <B><TT><FONT  color=000022 size=+1>Layout(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
Returns <B><TT><A HREF="#B_ITEMS_IN_COLUMN">B_ITEMS_IN_COLUMN</A></TT></B> if the items in the menu are stacked in a column from top to bottom, <B><TT><A HREF="#B_ITEMS_IN_ROW">B_ITEMS_IN_ROW</A></TT></B> if they're stretched out in a row from left to right, or <B><TT><A HREF="#B_ITEMS_IN_MATRIX">B_ITEMS_IN_MATRIX</A></TT></B> if they're arranged in some custom fashion.  By default BMenu items are arranged in a column and <A HREF="MenuBar.html#BMenuBar">BMenuBar</A> items in a row.
<P>
The layout is established by the constructor.
<P>
<B>See also:  </B>the BMenu and <A HREF="MenuBar.html#BMenuBar">BMenuBar</A> constructors
<P>
<HR>
<H3>MaxContentWidth()   see <A HREF="#SetMaxContentWidth()">SetMaxContentWidth()</A></H3>
<P>
<HR>
<H3>
<A NAME="RemoveItem()"></A>RemoveItem()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<B><TT><FONT  color=000022 size=+1>RemoveItem(</TT></B></FONT>int32 <I><FONT  color=991122 face=HELVETICA>index</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>RemoveItem(</TT></B></FONT><A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<I><FONT  color=991122 face=HELVETICA>item</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>RemoveItem(</TT></B></FONT>BMenu *<I><FONT  color=991122 face=HELVETICA>submenu</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Removes the item at <I><FONT  color=991122 face=HELVETICA>index</I></FONT>, or the specified <I><FONT  color=991122 face=HELVETICA>item</I></FONT>, or the item that controls the specified <I><FONT  color=991122 face=HELVETICA>submenu</I></FONT>.  Removing the item doesn't free it.
<P>
<UL>
<LI>If passed an <I><FONT  color=991122 face=HELVETICA>index</I></FONT>, this function returns a pointer to the item so you can free it.  It returns a <B><TT>NULL</TT></B> pointer if the item couldn't be removed (for example, if the <I><FONT  color=991122 face=HELVETICA>index</I></FONT> is out-of-range).
<P>
<LI>If passed an <I><FONT  color=991122 face=HELVETICA>item</I></FONT>, it returns <B><TT>true</TT></B> if the item was in the list and could be removed, and <B><TT>false</TT></B> if not.
<P>
<LI>If passed a <I><FONT  color=991122 face=HELVETICA>submenu</I></FONT>, it returns <B><TT>true</TT></B> if the submenu is controlled by an item in the menu and that item could be removed, and <B><TT>false</TT></B> otherwise.
<P>
</UL>
<P>
When an item is removed from a menu, it loses its target; the cached value is set to <B><TT>NULL</TT></B>.  If the item controls a submenu, it remains attached to the submenu even after being removed.
<P>
<B>See also:  <TT><A HREF="#AddItem()">AddItem()</A></TT></B> 
<P>
<HR>
<H3>ResizeToPreferred()   see <A HREF="RadioButton.html#GetPreferredSize()">GetPreferredSize()</A></H3>
<P>
<HR>
<H3>
<A NAME="ScreenLocation()"></A>ScreenLocation()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual <A HREF="Point.html#BPoint">BPoint</A> <B><TT><FONT  color=000022 size=+1>ScreenLocation(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Returns the point where the left top corner of the menu should appear when the menu is shown on-screen.  The point is specified in the screen coordinate system.
<P>
This function is called each time a hidden menu (a submenu of another menu) is brought to the screen.  It can be overridden in a derived class to change where the menu appears.  For example, the <A HREF="PopUpMenu.html#BPopUpMenu">BPopUpMenu</A> class overrides it so that a pop-up menu pops up over the controlling item.
<P>
<B>See also:  </B>the <A HREF="PopUpMenu.html#BPopUpMenu">BPopUpMenu</A> class
<P>
<HR>
<H3>
<A NAME="SetEnabled()"></A>SetEnabled()
, 
<A NAME="IsEnabled()"></A>IsEnabled()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>SetEnabled(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>enabled</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>IsEnabled(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
<B><TT><A HREF="#SetEnabled()">SetEnabled()</A></TT></B> enables the BMenu if the <I><FONT  color=991122 face=HELVETICA>enabled</I></FONT> flag is <B><TT>true</TT></B>, and disables it if <I><FONT  color=991122 face=HELVETICA>enabled</I></FONT> is <B><TT>false</TT></B>.  If the menu is a submenu, this enables or disables its controlling item, just as if <B><TT><A HREF="#SetEnabled()">SetEnabled()</A></TT></B> were called for that item.  The controlling item is updated so that it displays its new state, if it happens to be visible on-screen.
<P>
Disabling a menu disables its entire branch of the menu hierarchy.  All items in the menu, including those that control other menus, are disabled.
<P>
<B><TT><A HREF="#IsEnabled()">IsEnabled()</A></TT></B> returns <B><TT>true</TT></B> if the <A HREF="#BMenu">BMenu</A>, and every BMenu above it in the menu hierarchy, is enabled.  It returns <B><TT>false</TT></B> if the <A HREF="#BMenu">BMenu</A>, or any BMenu above it in the menu hierarchy, is disabled.
<P>
<B>See also:  <TT><A HREF="MenuItem.html#SetEnabled()">BMenuItem::SetEnabled()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="SetItemMargins()"></A>SetItemMargins()
, 
<A NAME="GetItemMargins()"></A>GetItemMargins()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetItemMargins(</TT></B></FONT>float <I><FONT  color=991122 face=HELVETICA>left</I></FONT>, float <I><FONT  color=991122 face=HELVETICA>top</I></FONT>, float <I><FONT  color=991122 face=HELVETICA>right</I></FONT>, float <I><FONT  color=991122 face=HELVETICA>bottom</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>GetItemMargins(</TT></B></FONT>float *<I><FONT  color=991122 face=HELVETICA>left</I></FONT>, float *<I><FONT  color=991122 face=HELVETICA>top</I></FONT>, float *<I><FONT  color=991122 face=HELVETICA>right</I></FONT>, float *<I><FONT  color=991122 face=HELVETICA>bottom</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
These functions set and get the margins around each item in the BMenu.  For the purposes of this function, you should assume that all items are enclosed in a rectangle of the same size, one big enough for the largest item.  Keyboard shortcuts are displayed in the right margin and check marks in the left.
<P>
<B>See also:  <TT><A HREF="#SetMaxContentWidth()">SetMaxContentWidth()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="SetLabelFromMarked()"></A>SetLabelFromMarked()
, 
<A NAME="IsLabelFromMarked()"></A>IsLabelFromMarked()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
void <B><TT><FONT  color=000022 size=+1>SetLabelFromMarked(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>flag</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>IsLabelFromMarked(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT><A HREF="#SetLabelFromMarked()">SetLabelFromMarked()</A></TT></B> determines whether the label of the item that controls the menu (the label of the superitem) should be taken from the currently marked item within the menu.  If <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> is <B><TT>true</TT></B>, the menu is placed in radio mode and the superitem's label is reset each time the user selects a different item.  If <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> is <B><TT>false</TT></B>, the setting for radio mode doesn't change and the label of the superitem isn't automatically reset.
<P>
<B><TT><A HREF="#IsLabelFromMarked()">IsLabelFromMarked()</A></TT></B> returns whether the superitem's label is taken from the marked item (but not necessarily whether the BMenu is in radio mode).
<P>
<B>See also:  <TT><A HREF="#SetRadioMode()">SetRadioMode()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="SetMaxContentWidth()"></A>SetMaxContentWidth()
, 
<A NAME="MaxContentWidth()"></A>MaxContentWidth()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>SetMaxContentWidth(</TT></B></FONT>float <I><FONT  color=991122 face=HELVETICA>width</I></FONT><B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> 
<P>


<TR><TD>
float <B><TT><FONT  color=000022 size=+1>MaxContentWidth(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
These functions set and return the maximum width of an item's content area.  The content area is where the item label is drawn; it excludes the margin on the left where a check mark might be placed and the margin on the right where a shortcut character or a submenu symbol might appear.  The content area is the same size for all items in the menu.
<P>
Normally, a menu will be wide enough to accommodate its longest item.  However, items wider than the maximum set by <B><TT><A HREF="#SetMaxContentWidth()">SetMaxContentWidth()</A></TT></B> are truncated to fit.
<P>
<B>See also:  <TT><A HREF="#SetItemMargins()">SetItemMargins()</A></TT></B>, <B><TT><A HREF="MenuItem.html#TruncateLabel()">BMenuItem::TruncateLabel()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="SetRadioMode()"></A>SetRadioMode()
, 
<A NAME="IsRadioMode()"></A>IsRadioMode()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>SetRadioMode(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>flag</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>IsRadioMode(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
<B><TT><A HREF="#SetRadioMode()">SetRadioMode()</A></TT></B> puts the BMenu in radio mode if <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> is <B><TT>true</TT></B> and takes it out of radio mode if <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> is <B><TT>false</TT></B>.  In radio mode, only one item in the menu can be marked at a time.  If the user selects an item, a check mark is placed in front of it automatically (you don't need to call BMenuItem's <B><TT><A HREF="MenuItem.html#SetMarked()">SetMarked()</A></TT></B> function; it's called for you).  If another item was marked at the time, its mark is removed.  Selecting a currently marked item retains the mark.
<P>
<B><TT><A HREF="#IsRadioMode()">IsRadioMode()</A></TT></B> returns whether the BMenu is currently in radio mode.  The default radio mode is <B><TT>false</TT></B> for ordinary BMenus, but <B><TT>true</TT></B> for BPopUpMenus.
<P>
<B><TT><A HREF="#SetRadioMode()">SetRadioMode()</A></TT></B> doesn't change any of the items in the menu.  If you want an initial item to be marked when the menu is put into radio mode, you must mark it yourself.
<P>
When <B><TT><A HREF="#SetRadioMode()">SetRadioMode()</A></TT></B> turns radio mode off, it calls <B><TT><A HREF="#SetLabelFromMarked()">SetLabelFromMarked()</A></TT></B> and passes it an argument of <B><TT>false</TT></B>&mdash;turning off the feature that changes the label of the menu's superitem each time the marked item changes.  Similarly, when <B><TT><A HREF="#SetLabelFromMarked()">SetLabelFromMarked()</A></TT></B> turns on this feature, it calls <B><TT><A HREF="#SetRadioMode()">SetRadioMode()</A></TT></B> and passes it an argument of <B><TT>true</TT></B>&mdash;turning radio mode on.
<P>
<B>See also:  <TT><A HREF="MenuItem.html#SetMarked()">BMenuItem::SetMarked()</A></TT></B>, <B><TT><A HREF="#SetLabelFromMarked()">SetLabelFromMarked()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="SetTargetForItems()"></A>SetTargetForItems()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>SetTargetForItems(</TT></B></FONT><A HREF="../The%20Application%20Kit/Handler.html#BHandler">BHandler</A> *<I><FONT  color=991122 face=HELVETICA>handler</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
<TR><TD>
virtual status_t <B><TT><FONT  color=000022 size=+1>SetTargetForItems(</TT></B></FONT><A HREF="../The%20Application%20Kit/Messenger.html#BMessenger">BMessenger</A> <I><FONT  color=991122 face=HELVETICA>messenger</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Assigns <I><FONT  color=991122 face=HELVETICA>handler</I></FONT> or <I><FONT  color=991122 face=HELVETICA>messenger</I></FONT> as the target for all the items in the menu.  The proposed target is subject to the restrictions imposed by the <B><TT><A HREF="ScrollBar.html#SetTarget()">SetTarget()</A></TT></B> function that <A HREF="MenuItem.html#BMenuItem">BMenuItem</A> inherits from <A HREF="../The%20Application%20Kit/Invoker.html#BInvoker">BInvoker</A> in the Application Kit.  See that function for further information.
<P>
If it's unable to set the target of any item, <B><TT><A HREF="#SetTargetForItems()">SetTargetForItems()</A></TT></B> aborts and returns the error it encountered.  If successful in setting the target of all items, it returns <B><TT><A HREF="../The%20Support%20Kit/ErrorCodes.html#B_OK">B_OK</A></TT></B>.
<P>
This function doesn't work recursively (it doesn't descend into submenus), and it only acts on items that are currently in the BMenu (it doesn't affect items that are added later).
<P>
<HR>
<H3>
<A NAME="SetTriggersEnabled()"></A>SetTriggersEnabled()
, 
<A NAME="AreTriggersEnabled()"></A>AreTriggersEnabled()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
virtual void <B><TT><FONT  color=000022 size=+1>SetTriggersEnabled(</TT></B></FONT>bool <I><FONT  color=991122 face=HELVETICA>flag</I></FONT><B><TT><FONT  color=000022 size=+1>)
<P>
</TT></B></FONT>

<TR><TD>
bool <B><TT><FONT  color=000022 size=+1>AreTriggersEnabled(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
<B><TT><A HREF="#SetTriggersEnabled()">SetTriggersEnabled()</A></TT></B> enables the triggers for all items in the menu if <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> is <B><TT>true</TT></B> and disables them if <I><FONT  color=991122 face=HELVETICA>flag</I></FONT> is <B><TT>false</TT></B>.  <B><TT><A HREF="#AreTriggersEnabled()">AreTriggersEnabled()</A></TT></B> returns whether the triggers are currently enabled or disabled.  They're enabled by default.
<P>
Triggers are displayed to the user only if they're enabled, and only when keyboard actions can operate the menu.
<P>
Triggers are appropriate for some menus, but not for others.  <B><TT><A HREF="#SetTriggersEnabled()">SetTriggersEnabled()</A></TT></B> is typically called to initialize the BMenu when it's constructed, not to enable and disable triggers as the application is running.  If triggers are ever enabled for a menu, they should always be enabled; if they're ever disabled, they should always be disabled.
<P>
<B>See also:  <TT><A HREF="MenuItem.html#SetTrigger()">BMenuItem::SetTrigger()</A></TT></B> 
<P>
<HR>
<H3>Show()   see <A HREF="#Hide()">Hide()</A></H3>
<P>
<HR>
<H3>SubmenuAt()   see <A HREF="#ItemAt()">ItemAt()</A></H3>
<P>
<HR>
<H3>
<A NAME="Superitem()"></A>Superitem()
, 
<A NAME="Supermenu()"></A>Supermenu()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<B><TT><FONT  color=000022 size=+1>Superitem(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>


<TR><TD>
BMenu *<B><TT><FONT  color=000022 size=+1>Supermenu(</TT></B></FONT>void<B><TT><FONT  color=000022 size=+1>)</TT></B></FONT> const
<P>

</TABLE></TABLE>

<P>
These functions return the supermenu item that controls the BMenu and the supermenu where that item is located.  The supermenu could be a <A HREF="MenuBar.html#BMenuBar">BMenuBar</A> object.  If the BMenu hasn't been made the submenu of another menu, both functions return <B><TT>NULL</TT></B>.
<P>
<B>See also:  <TT><A HREF="#AddItem()">AddItem()</A></TT></B> 
<P>
<HR>
<H3>
<A NAME="Track()"></A>Track()
</H3>
<P>

<Table>
<TR> 
<TD>&nbsp;&nbsp;
<TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TR> 
<TD>&nbsp;&nbsp;
<TD><p><Table cellpadding =3 bgcolor =eeeeee> 

<TR><TD>
<A HREF="MenuItem.html#BMenuItem">BMenuItem</A> *<B><TT><FONT  color=000022 size=+1>Track(</TT></B></FONT>bool&nbsp;<I><FONT  color=991122 face=HELVETICA>openAnyway</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>false</FONT>, <A HREF="Rect.html#BRect">BRect</A>&nbsp;*<I><FONT  color=991122 face=HELVETICA>clickToOpenRect</I></FONT>&nbsp;=&nbsp;<FONT  face=HELVETICA>NULL</FONT><B><TT><FONT  color=000022 size=+1>) 
<P>
</TT></B></FONT>
</TABLE></TABLE>

<P>
Initiates tracking of the cursor within the menu.  This function passes tracking control to submenus (and submenus of submenus) depending on where the user moves the mouse.  If the user ends tracking by invoking an item, <B><TT><A HREF="#Track()">Track()</A></TT></B> returns the item.  If the user didn't invoke any item, it returns <B><TT>NULL</TT></B>.  The item doesn't have to be located in the BMenu; it could, for example, belong to a submenu of the BMenu.
<P>
If the <I><FONT  color=991122 face=HELVETICA>openAnyway</I></FONT> flag is <B><TT>true</TT></B>, <B><TT><A HREF="#Track()">Track()</A></TT></B> opens the menu and leaves it open even though a mouse button isn't held down.  This enables menu navigation from the keyboard.  If a <I><FONT  color=991122 face=HELVETICA>clickToOpenRect</I></FONT> is specified and the user has set the click-to-open preference, <B><TT><A HREF="#Track()">Track()</A></TT></B> will leave the menu open if the user releases the mouse button while the cursor is inside the rectangle.  The rectangle should be stated in the screen coordinate system.
<P>
<B><TT><A HREF="#Track()">Track()</A></TT></B> is called by the BMenu to initiate tracking in the menu hierarchy.  You would need to call it yourself only if you're implementing a different kind of menu that starts to track the cursor under nonstandard circumstances.
<P>
<HR>
<H2>
<A NAME="Scripting%20Support"></A><FONT SIZE=6>S</FONT>cripting <FONT SIZE=6>S</FONT>upport
</H2>
<P>
The BMenu class implements the suite called "suite/vnd.Be-menu" consisting of the following messages: 
<P>
<HR>
<H3>
<A NAME="The%20Enabled%20Property"></A>The Enabled Property
</H3>
<P>
<B><TABLE BORDER cellpadding=4>
<TH></B>Message</TH>
<TH>Specifiers</TH>
<TH>Meaning</TH>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_GET_PROPERTY">B_GET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DIRECT_SPECIFIER">B_DIRECT_SPECIFIER</A></TT></B></TD>
<TD>Retur ns <B><TT>true</TT></B> if menu or menu item is enabled; <B><TT>false</TT></B> otherwise.</TD>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_SET_PROPERTY">B_SET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DIRECT_SPECIFIER">B_DIRECT_SPECIFIER</A></TT></B></TD>
<TD>Enables or disables menu or menu item.</TD>
</TABLE>
<P>
The "Enabled" property reflects whether the menu or menu item is enabled or disabled.
<P>
<HR>
<H3>
<A NAME="The%20Label%20Property"></A>The Label Property
</H3>
<P>
<B><TABLE BORDER cellpadding=4>
<TH></B>Message</TH>
<TH>Specifiers</TH>
<TH>Meaning</TH>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_GET_PROPERTY">B_GET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DIRECT_SPECIFIER">B_DIRECT_SPECIFIER</A></TT></B></TD>
<TD>Returns the string label of the menu or menu item.</TD>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_SET_PROPERTY">B_SET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DIRECT_SPECIFIER">B_DIRECT_SPECIFIER</A></TT></B></TD>
<TD>Sets the string label of the menu or menu item.</TD>
</TABLE>
<P>
The "Label" property refers to the text label of a menu or menu item.
<P>
<HR>
<H3>
<A NAME="The%20Mark%20Property"></A>The Mark Property
</H3>
<P>
<B><TABLE BORDER cellpadding=4>
<TH></B>Message</TH>
<TH>Specifiers</TH>
<TH>Meaning</TH>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_GET_PROPERTY">B_GET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DIRECT_SPECIFIER">B_DIRECT_SPECIFIER</A></TT></B></TD>
<TD>Returns <B><TT>true</TT></B> if the menu item or the menu's superitem is marked; <B><TT>false</TT></B> otherwise.</TD>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_SET_PROPERTY">B_SET_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DIRECT_SPECIFIER">B_DIRECT_SPECIFIER</A></TT></B></TD>
<TD>Marks or unmarks the menu item or the menu's superitem.</TD>
</TABLE>
<P>
The "Mark" property refers to whether or not a given menu item or a given menu's superitem is marked.
<P>
<HR>
<H3>
<A NAME="The%20Menu%20Property"></A>The Menu Property
</H3>
<P>
<B><TABLE BORDER cellpadding=4>
<TH></B>Message</TH>
<TH>Specifiers</TH>
<TH>Meaning</TH>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_CREATE_PROPERTY">B_CREATE_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_NAME_SPECIFIER">B_NAME_SPECIFIER</A>,
<br>
</TT></B>B_INDEX_SPECIFIER,
<br>
B_REVERSE_INDEX_SPECIFIER</TD>
<TD>Adds a new menu item at the specified index with the text label found in "data" and the int32 command found in "what" (used as the what field in the <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> sent by the item).</TD>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DELETE_PROPERTY">B_DELETE_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_NAME_SPECIFIER">B_NAME_SPECIFIER</A>,
<br>
</TT></B>B_INDEX_SPECIFIER,
<br>
B_REVERSE_INDEX_SPECIFIER</TD>
<TD>Removes the selected menu or menus.</TD>
<TR>
<TD>any other</TD>
<TD>B_NAME_SPECIFIER,
<br>
B_INDEX_SPECIFIER,
<br>
B_REVERSE_INDEX_SPECIFIER</TD>
<TD>Directs scripting message to the specified menu, first popping the current specifier off the stack.</TD>
</TABLE>
<P>
The "Menu" property refers to individual BMenus in the menu.
<P>
<HR>
<H3>
<A NAME="The%20MenuItem%20Property"></A>The MenuItem Property
</H3>
<P>
<B><TABLE BORDER cellpadding=4>
<TH></B>Message</TH>
<TH>Specifiers</TH>
<TH>Meaning</TH>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/topic_Scripting.html#B_COUNT_PROPERTIES">B_COUNT_PROPERTIES</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DIRECT_SPECIFIER">B_DIRECT_SPECIFIER</A></TT></B></TD>
<TD>Counts the number of menu items in the specified menu.</TD>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_CREATE_PROPERTY">B_CREATE_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_NAME_SPECIFIER">B_NAME_SPECIFIER</A>,
<br>
</TT></B>B_INDEX_SPECIFIER,
<br>
B_REVERSE_INDEX_SPECIFIER</TD>
<TD>Adds a new menu item at the specified index with the text label found in "data" and the int32 command found in "what" (used as the what field in the <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> sent by the item).</TD>
<TR>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_DELETE_PROPERTY">B_DELETE_PROPERTY</A></TT></B></TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_NAME_SPECIFIER">B_NAME_SPECIFIER</A>,
<br>
</TT></B>B_INDEX_SPECIFIER,
<br>
B_REVERSE_INDEX_SPECIFIER</TD>
<TD>Removes the specified menu item from its parent menu.</TD>
<TR>
<TD>B_EXECUTE_PROPERTY</TD>
<TD>B_NAME_SPECIFIER,
<br>
B_INDEX_SPECIFIER,
<br>
B_REVERSE_INDEX_SPECIFIER</TD>
<TD>Invokes the specified menu item.</TD>
<TR>
<TD>any other</TD>
<TD><B><TT><A HREF="../The%20Application%20Kit/misc.html#B_NAME_SPECIFIER">B_NAME_SPECIFIER</A>,
<br>
</TT></B>B_INDEX_SPECIFIER,
<br>
B_REVERSE_INDEX_SPECIFIER</TD>
<TD>Directs scripting message to the specified menu, first popping the current specifier off the stack.</TD>
</TABLE>
<P>
The "MenuItem" property refers to individual BMenuItems in the menu.
<P>
<HR>
<H2>
<A NAME="Archived%20Fields"></A><FONT SIZE=6>A</FONT>rchived <FONT SIZE=6>F</FONT>ields
</H2>
<P>
The <B><TT><A HREF="#Archive()">Archive()</A></TT></B> function adds the following fields to its <A HREF="../Release%20Notes/AppKit.html#BMessage">BMessage</A> argument:<B>
<P>
</B><TABLE BORDER cellpadding=4>
<TH><B>Field</B></TH>
<TH><B>Type code</B></TH>
<TH><B>Meaning</TH>
<TR>
<TD></B>"_layout"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD>Menu layout (Exists only if layout not <B><TT>B_ITEMS_IN_ROW</TT></B>).</TD>
<TR>
<TD>"_rsize_to_fit"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD><B><TT>true</TT></B> if menu resizes to fit items.</TD>
<TR>
<TD>"_disable"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD><B><TT>true</TT></B> if menu is disabled.</TD>
<TR>
<TD>"_radio"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD><B><TT>true</TT></B> if menu is in radio mode.</TD>
<TR>
<TD>"_trig_disabled"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD><B><TT>true</TT></B> if menu triggers are disabled.</TD>
<TR>
<TD>"_dyn_label"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD><B><TT>true</TT></B> if menu label mirrors the currently selected item.</TD>
<TR>
<TD>"_maxwidth"</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_FLOAT_TYPE">B_FLOAT_TYPE</A></TT></B></TD>
<TD>Maximum content width of the menu.</TD>
<TR>
<TD>"_items" (array)</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_MESSAGE_TYPE">B_MESSAGE_TYPE</A></TT></B></TD>
<TD>Menu items (only in deep copy).</TD>
<TR>
<TD>"_i_frames" (array)</TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_MESSAGE_TYPE">B_MESSAGE_TYPE</A></TT></B></TD>
<TD>Location of items (only in deep copy of layout <B><TT>B_ITEMS_IN_MATRIX</TT></B>)</TD>
</TABLE>
<P>
Some of these fields may not be present if the setting they represent isn't used, or is the default value.  For example, if the menu is disabled, the "_disable" field won't be found in the archive.
<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Interface Kit Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Interface%20Kit%20Master%20Index.html"><FONT face=HELVETICA>The Interface Kit Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

