<HTML><HEAD><TITLE>The Input Server: The Input Server</TITLE></HEAD><BODY BGCOLOR=#ffffff>


<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Input Server Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Input%20Server%20Master%20Index.html"><FONT face=HELVETICA>The Input Server Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<HR>
<H1>
<A NAME="The%20Input%20Server"></A>The Input Server
</H1>
<P>
The Input Server is a system service that accepts user events (on the mouse and keyboard, typically) at one end, and dispatches them to the App Server at the other.  In between, the Input Server runs the events through a series of filters that can inspect and modify them.  The generation and filtering of events is performed by the add-ons that the Input Server loads; the Server itself just provides the plumbing.  Event-generating add-ons (called <I>input devices</I>) typically correspond to one or more device drivers, although this isn't a requirement.  An event-filtering add-on (<I>input filter</I>) processes the events that are fed to it; input filters aren't intended to correspond to hardware.   A third type of Input Server add-on&mdash;an <I>input method</I>&mdash;is used to implement input method mechanisms, which convert keyboard events into character sets that can't be easily represented on a standard keyboard, such as Kanji.
<P>
Each of these add-on types (input devices, filters, and methods) is represented by a C++ class:  <A HREF="InputServerDevice.html#BInputServerDevice">BInputServerDevice</A>, <A HREF="InputServerFilter.html#BInputServerFilter">BInputServerFilter</A>, and BInputServerMethod.  For each add-on you want to create, you subclass the appropriate class and override its hook functions.  An additional class&mdash;<A HREF="InputDevice.html#BInputDevice">BInputDevice</A>&mdash;lets a "normal" application send messages back through the Input Server to the input devices; a <A HREF="InputDevice.html#BInputDevice">BInputDevice</A> object can be useful if you're creating a preference app for a custom Input Server add-on, for example.
<P>
A map of the Input Server world looks like this:
<P>
<IMG SRC="art/InputServer_map.gif" ALIGN="bottom">
<P>
Note that the Input Server and its add-ons (and BInputDevice) all live in user space, so, in theory, there's nothing that a "normal" application can do that an Input Server add-on can't do.   However, Input Server add-ons are loaded early in the boot process, before some system services (such as the Media and Network servers) have started.  Attempting to use services from these servers before they've started is a good way to wedge the system.
<P>
The BeOS provides a few Input Server add-ons:  It installs input devices that handle a variety of mice and keyboard drivers, and an input filter that the Screen Saver engine uses to detect user activity (on the mouse and keyboard).  BeOS's only built-in input method is installed when you choose the Japanese language option during the installation process.
<P>
<TABLE  CELLPADDING=4>
	<TR>
		<TD>&nbsp;
		<TD>
			<HR NOSHADE>
			<TABLE CELLPADDING=4>
				<TR>
					<TD VALIGN=TOP>
						<IMG SRC="../art/warningBullet.gif">
					<TD><FONT FACE="helvetica">
Currently, events that are generated by the BeOS joystick drivers do not go through the Input Server.  
<P>
						</FONT>			
			</TABLE>
			<HR NOSHADE>
</TABLE>

<P>
<HR>
<H2>
<A NAME="Drivers%20and%20Input%20Devices"></A><FONT SIZE=6>D</FONT>rivers and <FONT SIZE=6>I</FONT>nput <FONT SIZE=6>D</FONT>evices
</H2>
<P>
As mentioned above, most input devices (i.e. input-generating add-ons) correspond to one or more device drivers.  For example, the BeOS <B>mouse</B> input device manages all the mouse drivers that the OS provides.
<P>
It's important to keep in mind that an input device is not the same as the device driver(s) it manages&mdash;they're separate pieces of code that execute in separate address spaces:  the drivers run in the kernel, the add-ons run in the Input Server.  An input device can <B><TT>open()</TT></B> a driver, but it must not explicitly load the driver.  In other words, the add-on shouldn't re-invent or subvert the kernel's driver-loading mechanism. 
<P>
Similar to drivers, Input Server add-ons must be scrupulous about managing their memory and threads:  
<P>
<UL>
<LI>Memory that an add-on allocates must be freed when the add-on is unloaded, otherwise the add-on will leak.  
<P>
<LI>The hook functions that are invoked on your add-on are executed in threads that must stay as "live" as possible.  If your add-on does a lot of processing that can be performed asynchronously&mdash;for example, if it's an input device that's "watching" a piece of hardware&mdash;the add-on should spawn a thread.
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="Building"></A>Building
</H3>
<P>
Like all add-ons, Input Server add-ons are compiled as shared libraries.  The add-ons must link against <B>input_server</B>, renamed (as a symbolic link) to <B>_APP_</B>.  In other words, you set up a symbolic link like this:
<P>
<PRE>&nbsp;&nbsp;&nbsp;$ cd &lt;<I>yourProjectDirectory</I>>
&nbsp;&nbsp;&nbsp;$ ln -s /boot/beos/system/servers/input_server _APP_</PRE>
<P>
And then link against <B>_APP_</B>.
<P>
<HR>
<H3>
<A NAME="Installing"></A>Installing
</H3>
<P>
The input server looks for add-ons in the "<B>input_server</B>" directory within <B><TT>B_BEOS_ADDONS_DIRECTORY</TT></B>, <B><TT>B_COMMON_ADDONS_DIRECTORY,</TT></B> and <B><TT>B_USER_ADDONS_DIRECTORY</TT></B>.  Where you install your add-ons depends on what type of add-on it is:
<P>
<UL>
<LI><B>input_server/devices</B> is for input devices
<P>
<LI><B>input_server/filters</B> is for input filters
<P>
<LI><B>input_server/methods</B> is for input methods
<P>
<LI>You can install your input devices in the latter two directories&mdash;i.e. those under <B><TT>B_COMMON_ADDONS_DIRECTORY</TT></B>, and <B><TT>B_USER_ADDONS_DIRECTORY</TT></B>.  
<P>
<LI>The <B><TT>B_BEOS_ADDONS_DIRECTORY</TT></B> is reserved for add-ons that are supplied by the BeOS. 
<P>
</UL>
<P>
<HR>
<H3>
<A NAME="Loading"></A>Loading
</H3>
<P>
The Input Server automatically loads (or attempts to load) all add-ons at boot time.
<P>
Currently, the Input Server doesn't dynamically load add-ons.  This is a particular annoyance if you're developing and testing an add-on.  To work around this lack, move your add-on into the appropriate directory, and then quit and restart the Input Server from a Terminal:
<P>
<PRE>&nbsp;&nbsp;&nbsp;/system/servers/input_server -q</PRE>
<P>
This will gracefully shutdown the Input Server and then re-launch it.  The first thing the Server does when it comes back up is re-load the add-ons from its add-on directories.  
<P>
Your mouse and keyboard (and other input devices) will go dead for a moment while this is happening.  This is normal.
<P>
<HR>
<H2>
<A NAME="Input%20Server%20and%20You"></A><FONT SIZE=6>I</FONT>nput <FONT SIZE=6>S</FONT>erver and <FONT SIZE=6>Y</FONT>ou
</H2>
<P>
The Input Server gives applications a chance to take advantage of useful features present in input devices more interesting than your typical 101-key keyboard and 3-button mouse.
<P>
<HR>
<H3>
<A NAME="Mice%20and%20Tablets"></A>Mice and Tablets
</H3>
<P>
The Input Server extends the plain <B><TT><A HREF="../Messages/GeneralMessages.html#B_MOUSE_MOVED">B_MOUSE_MOVED</A></TT></B> message (which triggers a BView&gt;s <B><TT><A HREF="../The%20Interface%20Kit/TextView.html#MouseMoved()">MouseMoved()</A></TT></B> function) beyond its ordinary existence to let things like tablets pass along extra information about a user&gt;s actions.  For example, drawing tablets can track the user&gt;s movement with greater precision than a mouse, and can include drawing pressure and tilt information.  Some also include an "eraser."
<P>
If an application can do something useful with this information (and let's face it; drawing applications that respond to pressure and tilt on a drawing pad are useful as well as being cool), it&gt;ll be present in the <B><TT><A HREF="../Messages/GeneralMessages.html#B_MOUSE_MOVED">B_MOUSE_MOVED</A></TT></B> message:
<P>
<PRE>&nbsp;&nbsp;&nbsp;void MyView::MouseMoved(BPoint *where, uint32 transit, BMessage *drag_msg)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BMessage *moved_msg = Window()->CurrentMessage();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;} </PRE>
<P>
The extra information that a "mouse" input device could add to the <B><TT><A HREF="../Messages/GeneralMessages.html#B_MOUSE_MOVED">B_MOUSE_MOVED</A></TT></B> messages includes:
<P>
<UL>
<LI>more precise position information
<P>
<LI>drawing pressure
<P>
<LI>pen tilt
<P>
<LI>"eraser" mode
<P>
</UL>
<P>
<H4>
<A NAME="Precision%20Position%20Information"></A>Precision Position Information
</H4>
<P>
Tablets store the absolute position of the pointer with as much precision as they can in the <I><FONT  color=991122 face=HELVETICA>be:tablet_x</I></FONT> and <I><FONT  color=991122 face=HELVETICA>be:tablet_y</I></FONT> fields:
<P>
<PRE>&nbsp;&nbsp;&nbsp;float x, y;
&nbsp;&nbsp;&nbsp;x = moved_msg-FindFloat( "be:tablet_x" );
&nbsp;&nbsp;&nbsp;y = moved_msg->FindFloat( "be:tablet_y" );</PRE>
<P>
These entries will be scaled to the range [0.0 to 1.0].
<P>
<H4>
<A NAME="Pressure"></A>Pressure
</H4>
<P>
Tablet pressure is stored as a float in the range [0.0 to 1.0] (minimum to maximum), present in the <I><FONT  color=991122 face=HELVETICA>be:tablet_pressure</I></FONT> field:
<P>
<PRE>&nbsp;&nbsp;&nbsp;float pressure;
&nbsp;&nbsp;&nbsp;pressure = moved_msg->FindFloat( "be:tablet_pressure" );</PRE>
<P>
<H4>
<A NAME="Tilt"></A>Tilt
</H4>
<P>
Pen tilt is expressed as a pair of floats in the range [0.0 to 1.0], where (-1.0, -1.0) tilts to the left-top, (1.0, 1.0) tilts to the right-bottom, and (0.0, 0.0) is no tilt.  These floats are found in the <I><FONT  color=991122 face=HELVETICA>be:tablet_tilt_x</I></FONT> and <I><FONT  color=991122 face=HELVETICA>be:tablet_tilt_y</I></FONT> fields:
<P>
<PRE>&nbsp;&nbsp;&nbsp;float tilt_x, tilt_y;
&nbsp;&nbsp;&nbsp;tilt_x = moved_msg->FindFloat( "be:tablet_tilt_x" );
&nbsp;&nbsp;&nbsp;tilt_y = moved_msg->FindFloat( "be:tablet_tilt_y" );</PRE>
<P>
<H4>
<A NAME="Eraser%20Mode"></A>Eraser Mode
</H4>
<P>
The pen&gt;s eraser mode is expressed as an int32 in the <I><FONT  color=991122 face=HELVETICA>be:tablet_eraser</I></FONT> field:
<P>
<PRE>&nbsp;&nbsp;&nbsp;int32 erase_mode;
&nbsp;&nbsp;&nbsp;erase_mode = moved_msg->FindInt32( "be:tablet_eraser" );</PRE>
<P>
A value of 1 means the pen is reversed (i.e. the eraser is on) and 0 means the pen is behaving normally.  Other eraser modes may be defined in the future.
<P>
<HR>
<H2>
<A NAME="Supporting%20Input%20Methods%20in%20Views"></A><FONT SIZE=6>S</FONT>upporting <FONT SIZE=6>I</FONT>nput <FONT SIZE=6>M</FONT>ethods in <FONT SIZE=6>V</FONT>iews
</H2>
<P>
When the user is entering text using an input method, such as the Japanese language input method that became an installation option in R4, there are two ways that applications can handle their input:
<P>
<UL>
<LI><I>in-line</I>: the text entry interface object lets them enter text directly
<P>
<LI><I>bottom-line</I>: the input method itself pops up a window to accept the user&gt;s input, and then passes <B><TT><A HREF="../Messages/GeneralMessages.html#B_KEY_DOWN">B_KEY_DOWN</A></TT></B> messages simulating the characters to the application; the app doesn't have to do anything to support bottom-line input
<P>
</UL>
<P>
If your application&gt;s text-entry needs are met by the Interface Kit&gt;s <A HREF="../The%20Interface%20Kit/TextControl.html#BTextControl">BTextControl</A> and <A HREF="../Release%20Notes/InterfaceKit.html#BTextView">BTextView</A> objects, it&gt;ll automatically use the in-line mode, which gives the user a much better experience.  If you&gt;re writing your own text widget, you&gt;ll have to do a little work to let the user input text directly.
<P>
Doing this is a very good idea; making your application behave well when dealing with foreign (to you) languages will improve your application&gt;s acceptance around the world.
<P>
<HR>
<H3>
<A NAME="Messages%20from%20Input%20Methods"></A>Messages from Input Methods
</H3>
<P>
When interacting with an input method, your view&gt;s <B><TT><A HREF="../The%20Application%20Kit/Handler.html#MessageReceived()">MessageReceived()</A></TT></B> function will receive <B><TT><A HREF="../Messages/GeneralMessages.html#B_INPUT_METHOD_EVENT">B_INPUT_METHOD_EVENT</A></TT></B> messages; inside is a <I><FONT  color=991122 face=HELVETICA>be:opcode</I></FONT> field (an int32 value) indicating the kind of event:
<P>
<UL>
<LI><B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_STARTED">B_INPUT_METHOD_STARTED</A>
<P>
</TT></B><LI><B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_STOPPED">B_INPUT_METHOD_STOPPED</A>
<P>
</TT></B><LI><B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_CHANGED">B_INPUT_METHOD_CHANGED</A>
<P>
</TT></B><LI><B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_LOCATION_REQUEST">B_INPUT_METHOD_LOCATION_REQUEST</A>
<P>
</TT></B></UL>
<P>
<B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_STARTED">B_INPUT_METHOD_STARTED</A></TT></B> tells your view that a new input transaction has begun.  Inside the message is a <A HREF="../The%20Application%20Kit/Messenger.html#BMessenger">BMessenger</A> named <I><FONT  color=991122 face=HELVETICA>be:reply_to</I></FONT>; you should store this because it&gt;s your only way of talking to the input method while the transaction is going on.
<P>
<B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_STOPPED">B_INPUT_METHOD_STOPPED</A></TT></B> lets you know the transaction is over; you should discard the <A HREF="../The%20Application%20Kit/Messenger.html#BMessenger">BMessenger</A> at this point because it&gt;s gone stale.
<P>
In between the <B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_STARTED">B_INPUT_METHOD_STARTED</A></TT></B> and <B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_STOPPED">B_INPUT_METHOD_STOPPED</A></TT></B> messages, you&gt;ll receive various <B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_CHANGED">B_INPUT_METHOD_CHANGED</A></TT></B> and <B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_LOCATION_REQUEST">B_INPUT_METHOD_LOCATION_REQUEST</A></TT></B> messages as the transaction proceeds.
<P>
<B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_CHANGED">B_INPUT_METHOD_CHANGED</A></TT></B> does most of the work in an input transaction; its message contains the following important fields:
<P>
<TABLE BORDER cellpadding=4>
<TH><B>Entry</B></TH>
<TH>Type</TH>
<TH>Description</TH>
<TR>
<TD><I><FONT  color=991122 face=HELVETICA>be:string</I></FONT></TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_STRING_TYPE">B_STRING_TYPE</A></TT></B></TD>
<TD>The text the user is currently entering; display it at the insertion point.  <A HREF="../Release%20Notes/InterfaceKit.html#BTextView">BTextView</A> also highlights the text in blue to show that it&gt;s part of a transitory transaction.</TD>
<TR>
<TD><I><FONT  color=991122 face=HELVETICA>be:selection</I></FONT></TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD>A pair of <B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B> offsets into the <I><FONT  color=991122 face=HELVETICA>be:string</I></FONT> if any of the text <I><FONT  color=991122 face=HELVETICA>be:string</I></FONT> is currently selected by the user.  <A HREF="../Release%20Notes/InterfaceKit.html#BTextView">BTextView</A> highlights this selection in red instead of drawing it in blue.</TD>
<TR>
<TD><I><FONT  color=991122 face=HELVETICA>be:clause_start</I></FONT></TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD>Zero or more offsets into the <I><FONT  color=991122 face=HELVETICA>be:string</I></FONT> for handling languages (such as Japanese) that separate a sentence or phrase into numerous clauses.  An equal number of <I><FONT  color=991122 face=HELVETICA>be:clause_start</I></FONT> and <I><FONT  color=991122 face=HELVETICA>be:clause_end</I></FONT> pairs delimit these clauses; <A HREF="../Release%20Notes/InterfaceKit.html#BTextView">BTextView</A> separates the blue/red highlighting wherever there is a clause boundary.</TD>
<TR>
<TD><I><FONT  color=991122 face=HELVETICA>be:clause_end</I></FONT></TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD>Zero or more offsets into <I><FONT  color=991122 face=HELVETICA>be:string</I></FONT>; there will be as many <I><FONT  color=991122 face=HELVETICA>be:clause_end</I></FONT> entries as there are <I><FONT  color=991122 face=HELVETICA>be:clause_start</I></FONT>.</TD>
<TR>
<TD><I><FONT  color=991122 face=HELVETICA>be:confirmed</I></FONT></TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_BOOL_TYPE">B_BOOL_TYPE</A></TT></B></TD>
<TD>True when the user has entered and "confirmed" the current string and wishes to end the transaction.  <A HREF="../Release%20Notes/InterfaceKit.html#BTextView">BTextView</A> unhighlights the blue/red text and waits for a <B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_STOPPED">B_INPUT_METHOD_STOPPED</A></TT></B> (to close the transaction) or another <B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_CHANGED">B_INPUT_METHOD_CHANGED</A></TT></B> (to start a new transaction immediately).</TD>
</TABLE>
<P>
<B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_LOCATION_REQUEST">B_INPUT_METHOD_LOCATION_REQUEST</A></TT></B> is the input method&gt;s way of asking you for the on-screen location of each character in your representation of the <I><FONT  color=991122 face=HELVETICA>be:string</I></FONT>.  This information can be used by the input method to pop up additional windows giving the user an opportunity to select characters from a list or anything else that makes sense.  When you get a <B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_LOCATION_REQUEST">B_INPUT_METHOD_LOCATION_REQUEST</A></TT></B>, reply to the <I><FONT  color=991122 face=HELVETICA>be:reply_to</I></FONT> messenger (that you saved from the <B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_STARTED">B_INPUT_METHOD_STARTED</A></TT></B> message) with a <B><TT><A HREF="../Messages/GeneralMessages.html#B_INPUT_METHOD_EVENT">B_INPUT_METHOD_EVENT</A></TT></B> message, filling in the following fields:
<P>
<TABLE BORDER cellpadding=4>
<TH>Entry</TH>
<TH>Type</TH>
<TH>Description</TH>
<TR>
<TD><I><FONT  color=991122 face=HELVETICA>be:opcode</I></FONT></TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_INT32_TYPE">B_INT32_TYPE</A></TT></B></TD>
<TD>Use <B><TT><A HREF="InputServerMessages.html#B_INPUT_METHOD_LOCATION_REQUEST">B_INPUT_METHOD_LOCATION_REQUEST</A></TT></B> for the opcode.</TD>
<TR>
<TD><I><FONT  color=991122 face=HELVETICA>be:location_reply</I></FONT></TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_POINT_TYPE">B_POINT_TYPE</A></TT></B></TD>
<TD>The co-ordinates of each character (there should be one <I><FONT  color=991122 face=HELVETICA>be:location_reply</I></FONT> for every character in <I><FONT  color=991122 face=HELVETICA>be:string</I></FONT>) in screen co-ordinates not view or window co-ordinates).</TD>
<TR>
<TD><I><FONT  color=991122 face=HELVETICA>be:height_reply</I></FONT></TD>
<TD><B><TT><A HREF="../The%20Support%20Kit/misc.html#B_FLOAT_TYPE">B_FLOAT_TYPE</A></TT></B></TD>
<TD>The height of each character in <I><FONT  color=991122 face=HELVETICA>be:string</I></FONT>.</TD>
</TABLE>
<P>
<HR>
<H2>
<A NAME="App%20and%20Input%20Events"></A><FONT SIZE=6>A</FONT>pp and <FONT SIZE=6>I</FONT>nput <FONT SIZE=6>E</FONT>vents
</H2>
<P>
If you're writing an application and want to record or react to input events without writing an Input Server add-on (which, of course, requires an Input Server restart), you can:
<P>
<B>1. </B>&nbsp;&nbsp;&nbsp;Create a window off-screen, at a co-ordinate like (-10.0, -10.0).
<P>
<B>2. </B>&nbsp;&nbsp;&nbsp;Add a view to the window at (0.0, 0.0).
<P>
<B>3. </B>&nbsp;&nbsp;&nbsp;<B><TT><A HREF="../The%20Game%20Kit/WindowScreen.html#Show()">Show()</A></TT></B> and then <B><TT><A HREF="../The%20Game%20Kit/WindowScreen.html#Hide()">Hide()</A></TT></B> the window; this is necessary or the App Server won't send you any messages.
<P>
<B>4. </B>&nbsp;&nbsp;&nbsp;Move the hidden window to (0.0, 0.0).
<P>
<B>5. </B>&nbsp;&nbsp;&nbsp;Implement the window's <B><TT><A HREF="../The%20Application%20Kit/Looper.html#DispatchMessage()">DispatchMessage()</A></TT></B> function to handle <B><TT><A HREF="../Messages/GeneralMessages.html#B_KEY_DOWN">B_KEY_DOWN</A></TT></B>, <B><TT><A HREF="../Messages/GeneralMessages.html#B_MOUSE_UP">B_MOUSE_UP</A></TT></B>, or whatever other input events you're interested in observing.
<P>
Modifying these messages won't affect any other applications in the system; by the time they reach your application, they've already passed through the Input Server.
<P>
You can see this trick in action in Doug Fulton's masterful Whistle application (found at <B>ftp://ftp.be.com/pub/samples/midi_kit/Whistle.zip</B>).
<P>
</PRE></TABLE></UL></MENU></B></I></TT>



<!--TOP LINKS-->
<HR>
<center>
<TABLE bgcolor=ddeeee>
<TR><TD>
<A HREF="index.html"><FONT face=HELVETICA>The Input Server Table of Contents</FONT></A>&nbsp;&nbsp;
<TD>
&nbsp;&nbsp;<A HREF="The%20Input%20Server%20Master%20Index.html"><FONT face=HELVETICA>The Input Server Index</FONT></A>
</TABLE></center>
<!--TOP LINKS-->


<!-- Footer for Release 5 HTML Be Book -->
<hr>
<br>
<p>
<center>
<i><FONT size=6>T</FONT>he <FONT size=6 color=blue>B</FONT><FONT size=6 color=red>e</font> <FONT size=6>B</FONT>ook</i>,
<br>...in lovely HTML...
<br>for BeOS Release 5.
<center>
<br>
<p><font face=helvetiva>Copyright &copy; 2000 Be, Inc.  All rights reserved..
</body>
</html>

