<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0034)https://www.haiku-os.org/tags/hvif -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" class="js"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>HVIF | Haiku Project</title>
    
<link rel="canonical" href="https://www.haiku-os.org/tags/hvif">
</script>

  </head>

            <div id="content">
                          
              
              <div id="content-inner">
                                <h1 class="title">HVIF</h1>
                                <div id="content-content">
                  
<!-- start node.tpl.php -->
<div id="node-199" class="node odd teaser node-type-content_news">
  
    <h2 class="title"><a href="https://www.haiku-os.org/news/2006-11-06/icon_facts" title="Icon Facts">Icon Facts</a></h2>
  
  <div class="meta">

News posted by stippi on Mon, 2006-11-06 22:19

<!--        <span class="submitted">Posted Mon, 2006-11-06 22:19 by stippi</span>
    -->

  <div class="content">
    <div class="field field-type-text field-field-body">
    <div class="field-items">
            <div class="field-item odd">
                    <p>With this article, I want to introduce you to some interesting facts about the new Icon format that Haiku is using. At first sight, they are just scalable vector icons, and Haiku is not the only operating system to have them. But the interesting bits are in the implementation details which should make Haiku stand out from the rest.</p>

<p>The first unique feature is that Haiku uses a special vector storage format, that has been specifically designed to store icons; we call it the Haiku Vector Icon Format, or HVIF for short. Haiku is not using the SVG format. Support for that is available through SVG import and export features in the Haiku icon editor "Icon-O-Matic". HVIF saves so much space, that icons are typically even smaller than the BeOS bitmap icons, which use 1280 bytes. The average Haiku vector icon uses about 500-700 bytes, with some icons slightly over 1000 bytes and some even below 250 bytes. This means that an icon stored as an attribute of a file will fit in the so-called <i>small data region</i>, which resides within the inode of the file. When Tracker reads information about a file to display it, its name, size, date and also the icon are all read within a single disk operation, when the files inode is fetched. Obviously, this is very beneficial for speed, since the hard disk remains one of the slowest components of a computer. The only performance hit is rendering the icons, which is fast compared to the disk operation. If Haiku were to use SVG icons, we would need <b>at least</b> one extra seek after fetching the inode (as the icon is too big to fit in there), and this would have a severe impact in performance. To put the size of the Haiku icons into perspective, Windows Vista icons can use around 80Kb, as they use PNG images to store an icon at different sizes. SVG icons in ZETA can be stored compressed, and use 2-10 KB.</p>

<p>Another unique feature of the new icon format is that rendering is done in a single pass, touching each pixel only once. Typically, vector shapes are rendered in multiple passes, on top of each other if they overlap. With the Haiku icons, the geometrical information of every shape is collected all at once, solving the problem of visible seams between shapes that can often be observed with traditional multi-pass rendering. This comes through new features in the Anti-Grain Geometry rendering library that Haiku uses already for its on-screen drawing. The way it is done in AGG is also more efficient than multi-pass rendering.</p>

<p>Most of the vector icon code sits in a static library called <i>libicon</i> that is linked into libbe. As of yet, the classes it contains are not intended for widespread usage, as the implementation might still change and improve. But there is a new class available called <span class="geshifilter"><code class="cpp geshifilter-cpp">BIconUtils</code></span>, similar to <span class="geshifilter"><code class="cpp geshifilter-cpp">BTranslationUtils</code></span>. The purpose of this class is to give unified access to icons, and for loading them into <span class="geshifilter"><code class="cpp geshifilter-cpp">BBitmaps</code></span>. It handles old BeOS icons and the new vector icons transparently. <span class="geshifilter"><code class="cpp geshifilter-cpp">BNode</code></span>, <span class="geshifilter"><code class="cpp geshifilter-cpp">BNodeInfo</code></span>, <span class="geshifilter"><code class="cpp geshifilter-cpp">BAppFileInfo</code></span> and <span class="geshifilter"><code class="cpp geshifilter-cpp">BMimeType</code></span> have all been adjusted to load and save icons through the <span class="geshifilter"><code class="cpp geshifilter-cpp">BIconUtils</code></span> class. There was a lot of code duplication before that too. The vector icons are loaded through the same API that was available before. For example <span class="geshifilter"><code class="cpp geshifilter-cpp">BNodeInfo<span style="color: #008080;">::</span><span style="color: #007788;">GetIcon</span><span style="color: #008000;">(</span>BBitmap<span style="color: #000040;">*</span> bitmap, icon_size size<span style="color: #008000;">)</span></code></span>. The <span class="geshifilter"><code class="cpp geshifilter-cpp">size</code></span> argument is unfortunately a bit redundant, since the bitmap, which the caller must preallocate, provides a size anyways. In BeOS, the bitmap size must match the <span class="geshifilter"><code class="cpp geshifilter-cpp">icon_size</code></span> given. In Haiku, which icon an application gets, is determined by the colorspace of the provided bitmap. If it is <span class="geshifilter"><code class="cpp geshifilter-cpp">B_RGBA32</code></span> (in which case the bitmap may be of any size with the <span class="geshifilter"><code class="cpp geshifilter-cpp">icon_size</code></span> argument being ignored), the vector icon is preferred. If the bitmap is <span class="geshifilter"><code class="cpp geshifilter-cpp">B_CMAP8</code></span>, the old BeOS icon is preferred. If only one type of icon is available from a file, it will be put into the provided bitmap with the necessary conversion. Unfortunately, BeOS will return just a white bitmap if you pass a <span class="geshifilter"><code class="cpp geshifilter-cpp">B_RGBA32</code></span> bitmap to the icon loading functions - without returning an error. This means you need to take a bit of extra effort to write applications that use truecolor vector icons when running on Haiku and BeOS icons otherwise. If BeOS returned an error, you could have simply tried to pass a 32 bit bitmap first, and if that fails try again with 8 bit. Bummer.</p>

<p><span class="inline left"><a href="https://www.haiku-os.org/files/screenshots/screenshot_stippi-icon-set.jpg" onclick="return launch_popup(208,640,480),!1" target="_blank"><img src="data:image/jpeg;base64,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" alt="Best rated Stippi icon set by Stephan Assmus" title="Best rated Stippi icon set by Stephan Assmus" class="image thumbnail" height="150" width="200"></a></span>Most applications in the Haiku tree already support the new vector icons. But Tracker and Deskbar have not received any special icon code. They have just been adopted to use <span class="geshifilter"><code class="cpp geshifilter-cpp">B_RGBA32</code></span> bitmaps instead of <span class="geshifilter"><code class="cpp geshifilter-cpp">B_CMAP8</code></span> bitmaps, and most problems have been fixed related to drawing icons with alpha blending. Where Tracker reads icons from its own resources, it has been adopted to prefer flat vector icon data which it passes through <span class="geshifilter"><code class="cpp geshifilter-cpp">BIconUtils</code></span>. Other than that, Tracker and Deskbar use the normal system API available to any other application. So in that sense, the vector icons are completely integrated with the system and thoroughly implemented in all API classes dealing with icons.</p>

<p>As of yet, the work on HVIF is not 100% complete yet. There are a few bugs to iron out, and support has yet to be added to device drivers which return icons. The biggest chunk of work is designing all the other icons in the system. An icon design guide is also currently in the works, which will explain the artistic rules of Haiku icons. Another document will explain how to use Icon-O-Matic, which is at the moment in quite a rough state. Hopefully, both document will encourage other artists to help us complete the Haiku icon set.</p>
        </div>
        </div>
</div>
  </div>

  </div>
<!-- /#node-199 -->
<div class=row id=main-front>
<div class=col-md-12>
<div class=node>
<h1 class=title><a href=https://www.haiku-os.org/articles/2006-11-13_why_haiku_vector_icons_are_so_small/>Why Haiku Vector Icons are So Small</a></h1>
<div class=meta>
posted on Mon, 2006-11-13 13:01
</div>
<p><h3>Coordinates</h3>
<p>For example, I decided that icons would have a native resolution of 64 by 64 pixels. For crispness, it is very good to snap vector path coordinates to integer pixels. I thought it wouldn't be a bad idea to be able to have points outside the icon too, so I defined a range of -32 to +95 of valid integer coordinates - and these fit into just 7 bits. If a coordinate is not on an integer pixel, or falls outside the -32+95 range, I'm using the 8th bit to indicate a 2 byte coordinate, with which a much larger range can be expressed. In this case, the range is extended to -128 to +192 and the additional precision is used to encode non-integer coordinates as well.</p>
<h3>Paths</h3>
<p>I also realized that it is beneficial to optimize for common forms of vector paths. HVIF distinguishes between three basic types: <b>path with commands</b>, <b>path with straight lines only</b> and <b>path with curves only</b>. An all curves path could represent the other two forms of paths, but it would take the most storage space, because six coordinates need to be stored for each path segment. If a path consists of many straight segments, or even many horizontal and vertical lines, it is better to associate commands with the segments, which greatly reduces the number of coordinates needing to be stored per segment. The SVG format defines many more, but I found four different path commands to be all one would need for the icons. These are <b>horizontal line</b>, <b>vertical line</b>, <b>line</b> and <b>cubic curve</b>. The first two need only one coordinate to be encoded (X or Y), since the other stays the same with regards to the previous point. Line needs 2 coordinates and Curve needs 6. The four path commands can be encoded in 2 bits, and to make things less tricky, I decided to write them separate from the coordinate data, one byte encoding up to four commands. So a simple rectangle aligned to integer pixels needs this storage space:</p>
<ul>
<li>
1 byte for telling how many path points there are (4)
</li>
<li>
1 byte for four path commands (2 bits could remain unused, but there is a command (<i>line</i>) encoded for the first point anyways)
</li>
<li>
5 bytes for the coordinates (2 bytes for the first point, 3 bytes for the others)
</li>
</ul>
<p>The HVIF implementation does analyze which of the three basic path encodings would take the least amount of storage space. So if a path is mostly curves, or all straight lines anyways, it doesn't need to store a commands section.</p>
<h3>Flags</h3>
<p>Most icon objects are encoded with one byte reserved for "flags", which specify what aspects of it need to be stored in the file. For example, if a shape is not transformed in any way, no transformation matrix is stored for it. So "empty tags" for unneeded things are pretty much avoided.</p>
<h3>Matrices</h3>
<p>Speaking of transformation matrices, these can take up quite some space if no extra care is taken. HVIF uses normal affine matrices for transformations, which are normally encoded using 6 doubles (48 bytes) or floats if you don't care so much about precision (24 bytes). To reduce storage requirements even further (because the precision is not needed for icons), HVIF uses it's own floating point format which uses only 3 bytes per value, and so we are down to 18 bytes for a matrix. Many times, a shape is only translated, not rotated, skewed or scaled. In that case, we store only the translation using the same coordinate format used for path points.</p>
<h3>Styles</h3>
<p>There are two types of styles: plain color and gradient. The style section can use significant space, so a number of steps is taken to reduce it. Colors or gradients that don't use any alpha don't get it encoded, and grays are encoded with one byte only. Which type of encoding for colors is used is again determined by the flags byte of any given style. There is also a special gradient type for gradients with only two colors, one at 0% and one at 100% offset (a very common type of gradient). Here, the offsets of the colors are not encoded.</p>
<p>HVIF data consists of three sections. The first encodes all styles, the second all paths and the last all shapes. Styles and Paths are global to a Haiku icon, so that they may be reused by different shapes. There cannot be more than 256 styles or 256 paths in total. So the shapes can reference them with only one byte again, which represents the index of a style or path in the global lists. Shapes can also have Transformers attached, a Stroke transformer can for example convert a path into an outline. Nothing special was invented to store transformers though.</p>
<p>As you can see, you wouldn't really want to use HVIF to store generic vector graphics. It is really a format that is suited for a very special task only. But as was said before, it will turn out to be beneficial, ultimately in terms of desktop responsiveness. This won't come automatically though. If icons are designed without knowledge of how HVIF works, then a lot of potential is wasted. For example, if vector path points are not snapped to integer pixels or if paths are not reused where they could be, then an icon can take much more space than it should. This is especially true if an SVG icon is imported into Icon-O-Matic and simply saved to HVIF as is. This is not such a good idea. Some work remains to remove redundant or unnecessary information from the icon, but I'm hoping that with the information that I have just given, everyone will take advantage of the optimization tricks when creating icons for Haiku.</p></p>
</div>
</div>
</div>
                </div>
              </div><!-- /content-inner -->
            </div><!-- /content -->

</body></html>
